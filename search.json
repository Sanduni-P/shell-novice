[
  {
    "objectID": "slides/00-intro-overview.html#workshop-overview",
    "href": "slides/00-intro-overview.html#workshop-overview",
    "title": "Unix Shell Workshop",
    "section": "Workshop Overview",
    "text": "Workshop Overview\nMaster the Unix shell (Bash) to:\n\nNavigate your file system efficiently\nCreate, copy, move, and delete files and directories\nCombine commands with pipes and filters\nAutomate repetitive tasks with loops\nWrite and execute shell scripts\nSearch files and text patterns"
  },
  {
    "objectID": "slides/00-intro-overview.html#prerequisites",
    "href": "slides/00-intro-overview.html#prerequisites",
    "title": "Unix Shell Workshop",
    "section": "Prerequisites",
    "text": "Prerequisites\nStep 1: Download Files\nDownload shell-lesson-data.zip and move it to your Desktop.\nStep 2: Extract the Archive\nUnzip/extract the file. You should end up with a new folder called:\nshell-lesson-data on your Desktop\nStep 3: You‚Äôre Ready!\nAll data files will be in this directory for use throughout the workshop."
  },
  {
    "objectID": "slides/00-intro-overview.html#workshop-structure",
    "href": "slides/00-intro-overview.html#workshop-structure",
    "title": "Unix Shell Workshop",
    "section": "Workshop Structure",
    "text": "Workshop Structure\n\n\n\nEpisode\nTopic\n\n\n\n\n1\nIntroducing the Shell\n\n\n2\nNavigating Files and Directories\n\n\n3\nWorking With Files and Directories\n\n\n4\nFile Permissions\n\n\n5\nPipes and Filters\n\n\n6\nLoops\n\n\n7\nShell Scripts\n\n\n8\nFinding Things\n\n\n9\nAWK for Text Processing"
  },
  {
    "objectID": "slides/00-intro-overview.html#before-we-begin",
    "href": "slides/00-intro-overview.html#before-we-begin",
    "title": "Unix Shell Workshop",
    "section": "Before We Begin‚Ä¶",
    "text": "Before We Begin‚Ä¶\nYou can copy any command directly from the slides by clicking the clipboard icon on the right-hand side of each code block. Then paste it straight into your terminal."
  },
  {
    "objectID": "slides/00-intro-overview.html#why-use-the-shell",
    "href": "slides/00-intro-overview.html#why-use-the-shell",
    "title": "Unix Shell Workshop",
    "section": "Why Use the Shell?",
    "text": "Why Use the Shell?\nThe Problem with GUIs\nImagine: Copy the 3rd line from 1,000 text files across 1,000 folders into one file.\n\nUsing a GUI:\n\nHours of clicking\nHigh chance of error\nRepetitive and tedious\n\n\n\nUsing the Shell:\n\nA few commands\nRepeatable\nFast and accurate (seconds!)"
  },
  {
    "objectID": "slides/00-intro-overview.html#what-is-the-shell",
    "href": "slides/00-intro-overview.html#what-is-the-shell",
    "title": "Unix Shell Workshop",
    "section": "What is the Shell?",
    "text": "What is the Shell?\n\n\nA program that reads commands you type\nA command-line interface (CLI) - text-based\nAlso a scripting language for automation\nAllows combining simple programs into powerful workflows\nThe default way to interact with servers and supercomputers"
  },
  {
    "objectID": "slides/00-intro-overview.html#bash-the-shell-were-using",
    "href": "slides/00-intro-overview.html#bash-the-shell-were-using",
    "title": "Unix Shell Workshop",
    "section": "Bash: The Shell We‚Äôre Using",
    "text": "Bash: The Shell We‚Äôre Using\nBash = Bourne Again SHell\n\n\nMost popular Unix shell\nDefault on macOS, Linux, and Windows (via Git Bash)\nThe standard for shell scripting\nSmall number of ‚Äúwords‚Äù (commands) gets you far!"
  },
  {
    "objectID": "slides/00-intro-overview.html#the-prompt",
    "href": "slides/00-intro-overview.html#the-prompt",
    "title": "Unix Shell Workshop",
    "section": "The Prompt",
    "text": "The Prompt\nWhen you open the shell, you see:\n$\nor\n%\nThe prompt indicates the shell is waiting for input.\n\n\n\n\n\n\nNote\n\n\nYour prompt might look different:\nnelle@localhost $\nor even:\nuser@computer:~$\nThis shows your username and computer name."
  },
  {
    "objectID": "slides/00-intro-overview.html#typing-commands",
    "href": "slides/00-intro-overview.html#typing-commands",
    "title": "Unix Shell Workshop",
    "section": "Typing Commands",
    "text": "Typing Commands\n\n\nType a command after the $/%\nPress Enter to execute\nResults appear below\nNever type the $/% - it‚Äôs just the prompt!"
  },
  {
    "objectID": "slides/00-intro-overview.html#example-your-first-command",
    "href": "slides/00-intro-overview.html#example-your-first-command",
    "title": "Unix Shell Workshop",
    "section": "Example: Your First Command",
    "text": "Example: Your First Command\n\n\nls is short for listing.\nThis command will list the contents of the current directory:\n\n\nls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\n\nCommand not found\n\n\nIf the shell can‚Äôt find a program whose name is the command you typed, it will print an error message such as:\nks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem",
    "href": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: A Typical Problem",
    "text": "Nelle‚Äôs Pipeline: A Typical Problem\nüß™ The Scenario\nNelle Nemo, a marine biologist, has:\n\nüåä Returned from a 6-month North Pacific Gyre survey\nüß´ Collected 1520 samples\nüß¨ Measured 300 proteins per sample\nüíª Needs to process all files using goostats.sh\nüìù Must submit her paper by the end of the month"
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem-1",
    "href": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem-1",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: A Typical Problem",
    "text": "Nelle‚Äôs Pipeline: A Typical Problem\nüö® The Challenge\nIf Nelle runs goostats.sh manually (GUI):\n\nOpen & process 1520 files\n‚è± 30 seconds per file\nüïí 12+ hours of manual work\n‚ùå Time lost that could be spent writing her paper"
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem-2",
    "href": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem-2",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: A Typical Problem",
    "text": "Nelle‚Äôs Pipeline: A Typical Problem\nüí° The Solution: Use the Shell\nWith a command shell, Nelle can:\n\nAutomate repetitive processing\nUse loops to iterate over files\nRun the pipeline once and reuse it\nLet the computer work while she writes"
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem-3",
    "href": "slides/00-intro-overview.html#nelles-pipeline-a-typical-problem-3",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: A Typical Problem",
    "text": "Nelle‚Äôs Pipeline: A Typical Problem\nüõ† Skills Nelle Needs\nTo build her pipeline, she must know how to:\n\nNavigate to a file/directory\nCreate a file/directory\nCheck the length of a file\nChain commands together\nRetrieve a set of files\nIterate over files\nRun a shell script containing her pipeline"
  },
  {
    "objectID": "slides/00-intro-overview.html#the-file-system",
    "href": "slides/00-intro-overview.html#the-file-system",
    "title": "Unix Shell Workshop",
    "section": "The File System",
    "text": "The File System\n\nFiles = store information\nDirectories (folders) = store files or other directories"
  },
  {
    "objectID": "slides/00-intro-overview.html#the-file-system-tree",
    "href": "slides/00-intro-overview.html#the-file-system-tree",
    "title": "Unix Shell Workshop",
    "section": "The File System Tree",
    "text": "The File System Tree\n/ (root)\n‚îú‚îÄ‚îÄ bin\n‚îú‚îÄ‚îÄ data\n‚îú‚îÄ‚îÄ Users\n‚îÇ   ‚îî‚îÄ‚îÄ nelle\n‚îú‚îÄ‚îÄ tmp\n‚îî‚îÄ‚îÄ ...\nThe root directory is / - everything else is inside it."
  },
  {
    "objectID": "slides/00-intro-overview.html#what-these-folders-mean",
    "href": "slides/00-intro-overview.html#what-these-folders-mean",
    "title": "Unix Shell Workshop",
    "section": "What these folders mean",
    "text": "What these folders mean\n\nbin = built-in programs and commands\ndata = miscellaneous data files\nUsers = user home directories (e.g., /Users/nelle)\ntmp = temporary files that don‚Äôt need long-term storage"
  },
  {
    "objectID": "slides/00-intro-overview.html#pwd---print-working-directory",
    "href": "slides/00-intro-overview.html#pwd---print-working-directory",
    "title": "Unix Shell Workshop",
    "section": "pwd - Print Working Directory",
    "text": "pwd - Print Working Directory\nWhere are you right now?\n$ pwd\n/Users/nelle\nThis shows your current working directory (your current location)."
  },
  {
    "objectID": "slides/00-intro-overview.html#your-home-directory",
    "href": "slides/00-intro-overview.html#your-home-directory",
    "title": "Unix Shell Workshop",
    "section": "Your Home Directory",
    "text": "Your Home Directory\nThe shell usually starts in your home directory:\n\nmacOS: /Users/username\nLinux: /home/username\nWindows: C:\\Users\\username"
  },
  {
    "objectID": "slides/00-intro-overview.html#ls---list-files-and-directories",
    "href": "slides/00-intro-overview.html#ls---list-files-and-directories",
    "title": "Unix Shell Workshop",
    "section": "ls - List Files and Directories",
    "text": "ls - List Files and Directories\nWhat‚Äôs in your current location?\n$ ls\nApplications  Documents    Library      Music        Public\nDesktop      Downloads    Movies       Pictures"
  },
  {
    "objectID": "slides/00-intro-overview.html#making-ls-output-clearer",
    "href": "slides/00-intro-overview.html#making-ls-output-clearer",
    "title": "Unix Shell Workshop",
    "section": "Making ls Output Clearer",
    "text": "Making ls Output Clearer\nUse the -F flag to mark file types:\n$ ls -F\nApplications/  Documents/    Library/      Music/        Public/\nDesktop/       Downloads/    Movies/       Pictures/\n\n\n\n\n\n\nNote\n\n\n\n/ after name = directory\n* after name = executable file\n@ after name = symbolic link\nNo marker = regular file"
  },
  {
    "objectID": "slides/00-intro-overview.html#clearing-your-terminal",
    "href": "slides/00-intro-overview.html#clearing-your-terminal",
    "title": "Unix Shell Workshop",
    "section": "Clearing Your Terminal",
    "text": "Clearing Your Terminal\nIf your screen gets cluttered:\nclear -x\nYou can still access previous commands using ‚Üë and ‚Üì to move line-by-line, or by scrolling in your terminal after clear -x.\nFor some Bash configurations, clear may also clear the scrollbuffer\n\n\n\n\n\n\nTip\n\n\nShortcut: Press Ctrl+L to clear the screen."
  },
  {
    "objectID": "slides/00-intro-overview.html#getting-help",
    "href": "slides/00-intro-overview.html#getting-help",
    "title": "Unix Shell Workshop",
    "section": "Getting Help",
    "text": "Getting Help\nThere are two common ways to learn command options:\n\n--help (Linux and Git Bash)\n\nls --help\n\nman (Linux and macOS)\n\nman ls\nPress q to quit the manual.\n\n\n\n\n\n\nTip\n\n\nBuilt-in commands: If man cd fails, try help cd instead."
  },
  {
    "objectID": "slides/00-intro-overview.html#the---help-option",
    "href": "slides/00-intro-overview.html#the---help-option",
    "title": "Unix Shell Workshop",
    "section": "The --help Option",
    "text": "The --help Option\n--help option displays more information on how to use the command or program.\nls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if neither -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options, too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n  -C                         list entries by columns\n      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n                               if omitted), 'auto', or 'never'; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=&gt;@|) to entries\n...        ...        ..."
  },
  {
    "objectID": "slides/00-intro-overview.html#short-vs-long-options",
    "href": "slides/00-intro-overview.html#short-vs-long-options",
    "title": "Unix Shell Workshop",
    "section": "Short vs Long Options",
    "text": "Short vs Long Options\nUse short options when typing commands into the shell to minimize keystrokes and get your task done faster:\nls -F\nUse long options in scripts for clarity:\nls --classify"
  },
  {
    "objectID": "slides/00-intro-overview.html#unsupported-command-options",
    "href": "slides/00-intro-overview.html#unsupported-command-options",
    "title": "Unix Shell Workshop",
    "section": "Unsupported Command Options",
    "text": "Unsupported Command Options\nIf you use an option the command doesn‚Äôt support, you‚Äôll see an error:\nls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information."
  },
  {
    "objectID": "slides/00-intro-overview.html#the-man-command",
    "href": "slides/00-intro-overview.html#the-man-command",
    "title": "Unix Shell Workshop",
    "section": "The man command",
    "text": "The man command\nThis command will turn your terminal into a page with a description of the ls command and its options.\nman ls\nTo navigate through the man pages,\n\nuse ‚Üë and ‚Üì to move line-by-line\ntry b and Spacebar to skip up and down by a full page.\nuse / followed by the character or word you are searching for to find it in the manual.\nSometimes a search will result in multiple hits. If so, you can move between hits using N (for moving forward) and Shift+N (for moving backward).\npress q to quit the manual and return to the command prompt."
  },
  {
    "objectID": "slides/00-intro-overview.html#manual-pages-on-the-web",
    "href": "slides/00-intro-overview.html#manual-pages-on-the-web",
    "title": "Unix Shell Workshop",
    "section": "Manual pages on the web",
    "text": "Manual pages on the web\n\nThe third way to access help for commands is to search for the manual page on the web.\nWhen using internet search, including the phrase unix man page in your search query will help to find relevant results."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge",
    "href": "slides/00-intro-overview.html#challenge",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nExploring More ls Options\n\n\nYou can also use two options at the same time. What does the command ls do when used with the -l option? What about if you use both the -l and the -h option?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution",
    "href": "slides/00-intro-overview.html#solution",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe -l option makes ls use a long listing format, showing not only the file/directory names but also additional information, such as the file size and the time of its last modification. If you use both the -h option and the -l option, this makes the file size ‚Äòhuman readable‚Äô, i.e.¬†displaying something like 5.3K instead of 5369."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-1",
    "href": "slides/00-intro-overview.html#challenge-1",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nListing in Reverse Chronological Order\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-2",
    "href": "slides/00-intro-overview.html#solution-2",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written."
  },
  {
    "objectID": "slides/00-intro-overview.html#exploring-other-directories",
    "href": "slides/00-intro-overview.html#exploring-other-directories",
    "title": "Unix Shell Workshop",
    "section": "Exploring Other Directories",
    "text": "Exploring Other Directories\nList contents of the Desktop directory:\n$ ls -F Desktop\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error."
  },
  {
    "objectID": "slides/00-intro-overview.html#cd---change-directory",
    "href": "slides/00-intro-overview.html#cd---change-directory",
    "title": "Unix Shell Workshop",
    "section": "cd - Change Directory",
    "text": "cd - Change Directory\nMove to a different location\n$ cd Desktop\n$ pwd\n/Users/nelle/Desktop\nNotice: cd produces no output, but pwd confirms you moved!"
  },
  {
    "objectID": "slides/00-intro-overview.html#moving-into-subdirectories",
    "href": "slides/00-intro-overview.html#moving-into-subdirectories",
    "title": "Unix Shell Workshop",
    "section": "Moving Into Subdirectories",
    "text": "Moving Into Subdirectories\nGo deeper into the file structure:\n$ cd Desktop/shell-lesson-data\n$ cd exercise-data\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data/exercise-data"
  },
  {
    "objectID": "slides/00-intro-overview.html#listing-current-directory",
    "href": "slides/00-intro-overview.html#listing-current-directory",
    "title": "Unix Shell Workshop",
    "section": "Listing Current Directory",
    "text": "Listing Current Directory\nCheck what‚Äôs here:\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/"
  },
  {
    "objectID": "slides/00-intro-overview.html#moving-up-one-level-..",
    "href": "slides/00-intro-overview.html#moving-up-one-level-..",
    "title": "Unix Shell Workshop",
    "section": "Moving Up One Level: ..",
    "text": "Moving Up One Level: ..\nTo go to the parent directory (one level up):\n$ cd ..\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\n.. = ‚Äúthe directory containing this one‚Äù"
  },
  {
    "objectID": "slides/00-intro-overview.html#current-directory-.",
    "href": "slides/00-intro-overview.html#current-directory-.",
    "title": "Unix Shell Workshop",
    "section": "Current Directory: .",
    "text": "Current Directory: .\nTo refer to the current directory:\n$ ls -F .\nThis lists the current directory (same as just ls -F)."
  },
  {
    "objectID": "slides/00-intro-overview.html#special-symbols-in-paths",
    "href": "slides/00-intro-overview.html#special-symbols-in-paths",
    "title": "Unix Shell Workshop",
    "section": "Special Symbols in Paths",
    "text": "Special Symbols in Paths\n\n\n\nSymbol\nMeaning\n\n\n\n\n/ at start\nRoot directory\n\n\n/ between names\nPath separator\n\n\n..\nParent directory\n\n\n.\nCurrent directory\n\n\n~\nHome directory\n\n\n-\nPrevious directory"
  },
  {
    "objectID": "slides/00-intro-overview.html#hidden-files-and-directories",
    "href": "slides/00-intro-overview.html#hidden-files-and-directories",
    "title": "Unix Shell Workshop",
    "section": "Hidden Files and Directories",
    "text": "Hidden Files and Directories\nThe special directory .. doesn‚Äôt usually show up when we run ls. To display it, add the -a option:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/"
  },
  {
    "objectID": "slides/00-intro-overview.html#other-hidden-files",
    "href": "slides/00-intro-overview.html#other-hidden-files",
    "title": "Unix Shell Workshop",
    "section": "Other Hidden Files",
    "text": "Other Hidden Files\n\n\n\n\n\n\n\nNote\n\n\nIn addition to .. and ., you may see files like .bash_profile or .gitignore.\n\nThese files usually contain shell configuration settings\nThe prefix . prevents them from cluttering the terminal\nUse ls -a to see them\nMultiple options can be combined: ls -F -a = ls -Fa"
  },
  {
    "objectID": "slides/00-intro-overview.html#two-types-of-paths",
    "href": "slides/00-intro-overview.html#two-types-of-paths",
    "title": "Unix Shell Workshop",
    "section": "Two Types of Paths",
    "text": "Two Types of Paths\n\nAbsolute Path\n\nStarts with /\nWorks from anywhere on the computer\nExample: /Users/nelle/Desktop/shell-lesson-data\n\n\n\nRelative Path\n\nDoes not start with /\nDepends on where you are now\nExample: Desktop/shell-lesson-data"
  },
  {
    "objectID": "slides/00-intro-overview.html#home-directory-shortcut",
    "href": "slides/00-intro-overview.html#home-directory-shortcut",
    "title": "Unix Shell Workshop",
    "section": "Home Directory Shortcut",
    "text": "Home Directory Shortcut\nUse ~ to mean your home directory:\n$ cd ~/Desktop\n$ pwd\n/Users/nelle/Desktop"
  },
  {
    "objectID": "slides/00-intro-overview.html#return-to-home",
    "href": "slides/00-intro-overview.html#return-to-home",
    "title": "Unix Shell Workshop",
    "section": "Return to Home",
    "text": "Return to Home\ncd with no arguments returns to home:\n$ cd\n$ pwd\n/Users/nelle"
  },
  {
    "objectID": "slides/00-intro-overview.html#navigate-back-and-forth",
    "href": "slides/00-intro-overview.html#navigate-back-and-forth",
    "title": "Unix Shell Workshop",
    "section": "Navigate Back and Forth",
    "text": "Navigate Back and Forth\nGo to previous directory with -:\n$ cd -\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nGreat for switching between two locations!"
  },
  {
    "objectID": "slides/00-intro-overview.html#tab-completion",
    "href": "slides/00-intro-overview.html#tab-completion",
    "title": "Unix Shell Workshop",
    "section": "Tab Completion",
    "text": "Tab Completion\nSave typing! Use Tab to auto-complete:\nType: ls nor then press Tab\n$ ls nor[TAB]\nBecomes:\n$ ls north-pacific-gyre/\nIf multiple options, press Tab twice to see all."
  },
  {
    "objectID": "slides/00-intro-overview.html#general-syntax-of-a-shell-command",
    "href": "slides/00-intro-overview.html#general-syntax-of-a-shell-command",
    "title": "Unix Shell Workshop",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments.\nConsider this example:\nls -F /"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-2",
    "href": "slides/00-intro-overview.html#challenge-2",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nAbsolute vs Relative Paths\n\n\nStarting from /Users/nelle/data, which of the following commands could Nelle use to navigate to her home directory, which is /Users/nelle?\n\ncd .\ncd /\ncd /home/nelle\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd .."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-4",
    "href": "slides/00-intro-overview.html#solution-4",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: Nelle‚Äôs home directory is /Users/nelle.\nNo: this command goes up two levels, i.e.¬†ends in /Users.\nYes: ~ stands for the user‚Äôs home directory, in this case /Users/nelle.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user‚Äôs home directory.\nYes: goes up one level."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-3",
    "href": "slides/00-intro-overview.html#challenge-3",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nRelative Path Resolution\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-6",
    "href": "slides/00-intro-overview.html#solution-6",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-4",
    "href": "slides/00-intro-overview.html#challenge-4",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nls Reading Comprehension\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-8",
    "href": "slides/00-intro-overview.html#solution-8",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-organizing-files",
    "href": "slides/00-intro-overview.html#nelles-pipeline-organizing-files",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: Organizing Files",
    "text": "Nelle‚Äôs Pipeline: Organizing Files\nNelle is ready to organize the files from the protein assay machine.\n\n\nCreates directory north-pacific-gyre for her data\nEach sample has a unique 10-character ID (e.g., NENE01729A)\nFiles named like NENE01729A.txt, NENE01812A.txt, etc.\nAll 1520 files in the same directory"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-tab-completion",
    "href": "slides/00-intro-overview.html#using-tab-completion",
    "title": "Unix Shell Workshop",
    "section": "Using Tab Completion",
    "text": "Using Tab Completion\nNelle can see her files:\n$ ls north-pacific-gyre/\nBut that‚Äôs a lot to type! She can use tab completion:\n\n\nType ls nor and press Tab\nShell completes to ls north-pacific-gyre/\nPressing Tab again shows multiple files\nType ls north-pacific-gyre/goo and press Tab for files starting with ‚Äúgoo‚Äù"
  },
  {
    "objectID": "slides/00-intro-overview.html#creating-directories",
    "href": "slides/00-intro-overview.html#creating-directories",
    "title": "Unix Shell Workshop",
    "section": "Creating Directories",
    "text": "Creating Directories\nWe now know how to explore files and directories, but how do we create them?\nWhere Are We?\nFirst, check where we are:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nMove to exercise-data/writing and see what‚Äôs there:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#creating-a-directory",
    "href": "slides/00-intro-overview.html#creating-a-directory",
    "title": "Unix Shell Workshop",
    "section": "Creating a Directory",
    "text": "Creating a Directory\nCreate a new directory called thesis:\nmkdir thesis\nmkdir means ‚Äúmake directory‚Äù\nCheck it was created:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/"
  },
  {
    "objectID": "slides/00-intro-overview.html#verify-the-directory-is-empty",
    "href": "slides/00-intro-overview.html#verify-the-directory-is-empty",
    "title": "Unix Shell Workshop",
    "section": "Verify the Directory is Empty",
    "text": "Verify the Directory is Empty\nSince we just created it:\nls -F thesis\nNo output means the directory is empty."
  },
  {
    "objectID": "slides/00-intro-overview.html#creating-nested-directories",
    "href": "slides/00-intro-overview.html#creating-nested-directories",
    "title": "Unix Shell Workshop",
    "section": "Creating Nested Directories",
    "text": "Creating Nested Directories\nThe -p option creates nested subdirectories in one operation:\nmkdir -p ../project/data ../project/results\nUse ls -FR to recursively list the new hierarchy:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:"
  },
  {
    "objectID": "slides/00-intro-overview.html#two-ways-of-doing-the-same-thing",
    "href": "slides/00-intro-overview.html#two-ways-of-doing-the-same-thing",
    "title": "Unix Shell Workshop",
    "section": "Two Ways of Doing the Same Thing",
    "text": "Two Ways of Doing the Same Thing\n\n\n\n\n\n\nNote\n\n\nUsing the shell to create a directory is no different than using a file explorer.\nIf you open the current directory using your operating system‚Äôs graphical file explorer, the thesis directory will appear there too.\nThe shell and the file explorer are two different ways of interacting with the files, but the files and directories themselves are the same."
  },
  {
    "objectID": "slides/00-intro-overview.html#good-names-for-files-and-directories",
    "href": "slides/00-intro-overview.html#good-names-for-files-and-directories",
    "title": "Unix Shell Workshop",
    "section": "Good Names for Files and Directories",
    "text": "Good Names for Files and Directories\n\n\n\n\n\n\nTip\n\n\nTips for naming files and directories:\n\nDon‚Äôt use spaces - Use - or _ instead\n\nGood: north-pacific-gyre/\nBad: north pacific gyre/\n\nDon‚Äôt begin with - - Commands treat these as options\nStick with: lowercase letters, numbers, ., -, _\n\nMany special characters have special meanings"
  },
  {
    "objectID": "slides/00-intro-overview.html#spaces-and-special-characters",
    "href": "slides/00-intro-overview.html#spaces-and-special-characters",
    "title": "Unix Shell Workshop",
    "section": "Spaces and Special Characters",
    "text": "Spaces and Special Characters\nIf you need to refer to names with spaces or special characters, surround the name in quotes:\n'my file with spaces.txt'\nBest practice:\n\n\nUse all lowercase letters\nWindows and macOS are typically case insensitive\nCan‚Äôt distinguish between thesis and Thesis in same directory"
  },
  {
    "objectID": "slides/00-intro-overview.html#creating-a-text-file",
    "href": "slides/00-intro-overview.html#creating-a-text-file",
    "title": "Unix Shell Workshop",
    "section": "Creating a Text File",
    "text": "Creating a Text File\nChange to thesis directory and create a file with nano:\ncd thesis\nnano draft.txt\nnano is a simple text editor that runs in your terminal."
  },
  {
    "objectID": "slides/00-intro-overview.html#which-editor",
    "href": "slides/00-intro-overview.html#which-editor",
    "title": "Unix Shell Workshop",
    "section": "Which Editor?",
    "text": "Which Editor?\n\n\n\n\n\n\n\nNote\n\n\nnano is a text editor - it only works with plain character data.\nOther options:\n\nUnix: Emacs, Vim, Gedit, VSCode\nWindows: Notepad++, notepad\n\nImportant: Know where your editor searches for and saves files!"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-nano",
    "href": "slides/00-intro-overview.html#using-nano",
    "title": "Unix Shell Workshop",
    "section": "Using nano",
    "text": "Using nano\nType some text,\n\nThen,\n\nPress Ctrl+O to write data to disk\nPress Return to accept filename draft.txt\nPress Ctrl+X to quit and return to shell"
  },
  {
    "objectID": "slides/00-intro-overview.html#control-key-notation",
    "href": "slides/00-intro-overview.html#control-key-notation",
    "title": "Unix Shell Workshop",
    "section": "Control Key Notation",
    "text": "Control Key Notation\n\n\n\n\n\n\n\nTip\n\n\nThe Control key can be described in various ways:\n\nControl-X, Control+X\nCtrl-X, Ctrl+X\n^X\nC-x\n\nIn nano, the bottom shows: ^G Get Help ^O WriteOut\nThis means Ctrl+G for help, Ctrl+O to save."
  },
  {
    "objectID": "slides/00-intro-overview.html#verify-file-creation",
    "href": "slides/00-intro-overview.html#verify-file-creation",
    "title": "Unix Shell Workshop",
    "section": "Verify File Creation",
    "text": "Verify File Creation\nnano doesn‚Äôt leave output, but ls confirms the file exists:\nls\ndraft.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-5",
    "href": "slides/00-intro-overview.html#challenge-5",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nCreating Files a Different Way\n\n\nTry this command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-10",
    "href": "slides/00-intro-overview.html#solution-10",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you‚Äôve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#whats-in-a-name",
    "href": "slides/00-intro-overview.html#whats-in-a-name",
    "title": "Unix Shell Workshop",
    "section": "What‚Äôs In A Name?",
    "text": "What‚Äôs In A Name?\n\n\n\n\n\n\n\nNote\n\n\nMost file names are something.extension:\n\n.txt = plain text file\n.pdf = PDF document\n.cfg = configuration file\n.png = PNG image\n\nImportant: This is just a convention! Files contain bytes. Naming whale.png as whale.mp3 doesn‚Äôt make it a sound file - it might just confuse programs trying to open it."
  },
  {
    "objectID": "slides/00-intro-overview.html#moving-files-and-directories",
    "href": "slides/00-intro-overview.html#moving-files-and-directories",
    "title": "Unix Shell Workshop",
    "section": "Moving Files and Directories",
    "text": "Moving Files and Directories\nReturn to the writing directory:\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\ndraft.txt isn‚Äôt a very informative name. Let‚Äôs rename it using mv:\nmv thesis/draft.txt thesis/quotes.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#how-mv-works",
    "href": "slides/00-intro-overview.html#how-mv-works",
    "title": "Unix Shell Workshop",
    "section": "How mv Works",
    "text": "How mv Works\nmv [old] [new] moves or renames files\nCheck the result:\nls thesis\nquotes.txt\nWarning: mv will silently overwrite existing files with the same name!\nUse mv -i or mv --interactive to ask for confirmation before overwriting."
  },
  {
    "objectID": "slides/00-intro-overview.html#moving-to-current-directory",
    "href": "slides/00-intro-overview.html#moving-to-current-directory",
    "title": "Unix Shell Workshop",
    "section": "Moving to Current Directory",
    "text": "Moving to Current Directory\nMove quotes.txt to the current working directory:\nmv thesis/quotes.txt .\nThe . means ‚Äúcurrent directory‚Äù\nVerify thesis is now empty:\nls thesis\n$"
  },
  {
    "objectID": "slides/00-intro-overview.html#confirming-file-location",
    "href": "slides/00-intro-overview.html#confirming-file-location",
    "title": "Unix Shell Workshop",
    "section": "Confirming File Location",
    "text": "Confirming File Location\nTry to list the file in thesis:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nConfirm it‚Äôs in current directory:\nls quotes.txt\nquotes.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-6",
    "href": "slides/00-intro-overview.html#challenge-6",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nMoving Files to a new folder\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e.¬†the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-12",
    "href": "slides/00-intro-overview.html#solution-12",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e.¬†one above the current directory) and that . refers to the current directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#copying-files-and-directories",
    "href": "slides/00-intro-overview.html#copying-files-and-directories",
    "title": "Unix Shell Workshop",
    "section": "Copying Files and Directories",
    "text": "Copying Files and Directories\nThe cp command copies instead of moving:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nls can take multiple paths to show multiple files at once."
  },
  {
    "objectID": "slides/00-intro-overview.html#copying-directories",
    "href": "slides/00-intro-overview.html#copying-directories",
    "title": "Unix Shell Workshop",
    "section": "Copying Directories",
    "text": "Copying Directories\nUse the -r (recursive) option to copy directories:\ncp -r thesis thesis_backup\nCheck both directories:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#forgetting--r-when-copying-directories",
    "href": "slides/00-intro-overview.html#forgetting--r-when-copying-directories",
    "title": "Unix Shell Workshop",
    "section": "Forgetting -r When Copying Directories",
    "text": "Forgetting -r When Copying Directories\nIf you omit -r when copying a directory:\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\nThe -r flag is required to copy directories."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-7",
    "href": "slides/00-intro-overview.html#challenge-7",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nRenaming Files\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt ."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-14",
    "href": "slides/00-intro-overview.html#solution-14",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nNo.¬†While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-8",
    "href": "slides/00-intro-overview.html#challenge-8",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nMoving and Copying\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-16",
    "href": "slides/00-intro-overview.html#solution-16",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‚Äògo up a level‚Äô, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie"
  },
  {
    "objectID": "slides/00-intro-overview.html#removing-files-and-directories",
    "href": "slides/00-intro-overview.html#removing-files-and-directories",
    "title": "Unix Shell Workshop",
    "section": "Removing Files and Directories",
    "text": "Removing Files and Directories\nReturn to the writing directory and remove quotes.txt:\nrm quotes.txt\nConfirm it‚Äôs gone:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory"
  },
  {
    "objectID": "slides/00-intro-overview.html#deleting-is-forever",
    "href": "slides/00-intro-overview.html#deleting-is-forever",
    "title": "Unix Shell Workshop",
    "section": "Deleting Is Forever",
    "text": "Deleting Is Forever\n\n\n\n\n\n\nCaution\n\n\nThe Unix shell doesn‚Äôt have a trash bin!\nWhen we delete files, they are unlinked from the file system so their storage space can be recycled.\nTools for finding and recovering deleted files exist, but there‚Äôs no guarantee they‚Äôll work - the computer may recycle the file‚Äôs disk space right away."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-9",
    "href": "slides/00-intro-overview.html#challenge-9",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nUsing rm Safely\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-18",
    "href": "slides/00-intro-overview.html#solution-18",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn‚Äôt have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove."
  },
  {
    "objectID": "slides/00-intro-overview.html#removing-directories",
    "href": "slides/00-intro-overview.html#removing-directories",
    "title": "Unix Shell Workshop",
    "section": "Removing Directories",
    "text": "Removing Directories\nIf we try to remove a directory with just rm:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nrm by default only works on files, not directories."
  },
  {
    "objectID": "slides/00-intro-overview.html#removing-directories-with--r",
    "href": "slides/00-intro-overview.html#removing-directories-with--r",
    "title": "Unix Shell Workshop",
    "section": "Removing Directories with -r",
    "text": "Removing Directories with -r\nUse -r (recursive) to remove a directory and all contents:\nrm -r thesis\n‚ö†Ô∏è Warning: This works without confirmation prompts!\nGiven that files can‚Äôt be retrieved, use rm -r with great caution.\nConsider using rm -r -i for interactive confirmation."
  },
  {
    "objectID": "slides/00-intro-overview.html#operations-with-multiple-files",
    "href": "slides/00-intro-overview.html#operations-with-multiple-files",
    "title": "Unix Shell Workshop",
    "section": "Operations with Multiple Files",
    "text": "Operations with Multiple Files\nOftentimes we need to copy or move several files at once.\nThis can be done by:\n\n\nProviding a list of individual filenames\nSpecifying a naming pattern using wildcards\n\n\nWildcards are special characters that represent unknown characters or sets of characters."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-10",
    "href": "slides/00-intro-overview.html#challenge-10",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nCopy with Multiple Filenames\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let‚Äôs try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-20",
    "href": "slides/00-intro-overview.html#solution-20",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nWhen cp is given two arguments and the second is a destination directory, cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-wildcards",
    "href": "slides/00-intro-overview.html#using-wildcards",
    "title": "Unix Shell Workshop",
    "section": "Using Wildcards",
    "text": "Using Wildcards\n\n\n\n\n\n\n\nNote\n\n\n* is a wildcard - represents zero or more characters.\nIn shell-lesson-data/exercise-data/alkanes:\n\n*.pdb matches ethane.pdb, propane.pdb, and all files ending in .pdb\np*.pdb only matches pentane.pdb and propane.pdb\n\n? is also a wildcard\n\nrepresents exactly one character.\n?ethane.pdb matches methane.pdb\n*ethane.pdb matches ethane.pdb and methane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#wildcards-in-combination",
    "href": "slides/00-intro-overview.html#wildcards-in-combination",
    "title": "Unix Shell Workshop",
    "section": "Wildcards in Combination",
    "text": "Wildcards in Combination\nWildcards can be used together:\n\n\n???ane.pdb = three characters followed by ane.pdb\n\nMatches: cubane.pdb, ethane.pdb, octane.pdb\n\n\n\nHow wildcards work:\nThe shell expands wildcards to create a list of matching filenames before running the command.\nException: If no files match, Bash passes the expression as-is to the command."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-11",
    "href": "slides/00-intro-overview.html#challenge-11",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nList filenames matching a pattern\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-22",
    "href": "slides/00-intro-overview.html#solution-22",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn‚Äôt match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane.."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-12",
    "href": "slides/00-intro-overview.html#challenge-12",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nMore on Wildcards\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îî‚îÄ‚îÄ all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-13",
    "href": "slides/00-intro-overview.html#challenge-13",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nMore on Wildcards\n\n\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n    ‚îî‚îÄ‚îÄ all_november_files\n        ‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n        ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-24",
    "href": "slides/00-intro-overview.html#solution-24",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-14",
    "href": "slides/00-intro-overview.html#challenge-14",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nOrganizing Directories and Files\n\n\nJamie is working on a project, and she sees that her files aren‚Äôt very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-26",
    "href": "slides/00-intro-overview.html#solution-26",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‚Äòanalyzed‚Äô directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-15",
    "href": "slides/00-intro-overview.html#challenge-15",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nReproduce a folder structure\n\n\nYou‚Äôre starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n‚îî‚îÄ‚îÄ data\n   ‚îú‚îÄ‚îÄ processed\n   ‚îî‚îÄ‚îÄ raw"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-16",
    "href": "slides/00-intro-overview.html#challenge-16",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nReproduce a folder structure\n\n\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-28",
    "href": "slides/00-intro-overview.html#solution-28",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won‚Äôt create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‚Äòraw‚Äô and ‚Äòprocessed‚Äô directories at the same level as the ‚Äòdata‚Äô directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#file-permissions",
    "href": "slides/00-intro-overview.html#file-permissions",
    "title": "Unix Shell Workshop",
    "section": "File Permissions",
    "text": "File Permissions\nEvery file/folder has permissions defining who can access them\nThree permission categories:\n\nowner - applies only to file owner\ngroup - applies only to assigned group\nall users - applies to all other users (watch this closely!)"
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-example",
    "href": "slides/00-intro-overview.html#permission-example",
    "title": "Unix Shell Workshop",
    "section": "Permission Example",
    "text": "Permission Example\nFor example, if a file had the following set of permissions:\n\n\n\n\n\nuser\n\n\ngroup\n\n\nall\n\n\n\n\nread\n\n\nyes\n\n\nyes\n\n\nno\n\n\n\n\nwrite\n\n\nyes\n\n\nno\n\n\nno\n\n\n\n\nexecute\n\n\nno\n\n\nno\n\n\nno"
  },
  {
    "objectID": "slides/00-intro-overview.html#viewing-permissions",
    "href": "slides/00-intro-overview.html#viewing-permissions",
    "title": "Unix Shell Workshop",
    "section": "Viewing Permissions",
    "text": "Viewing Permissions\nView file permissions with ls -l:\ncd alkanes\nls -l methane.pdb\n-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#understanding-ls--l-output",
    "href": "slides/00-intro-overview.html#understanding-ls--l-output",
    "title": "Unix Shell Workshop",
    "section": "Understanding ls -l Output",
    "text": "Understanding ls -l Output\n-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb\n\nA set of ten permission flags\nLink count (which is irrelevant to this course)\nThe owner of the file\nThe associated group\nThe size of the file in bytes\nThe date that the file was last modified\nThe name of the file"
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-flags",
    "href": "slides/00-intro-overview.html#permission-flags",
    "title": "Unix Shell Workshop",
    "section": "Permission Flags",
    "text": "Permission Flags\nThree basic permission types:\n\nRead (r) - capability to read file contents\nWrite (w) - capability to write/modify files or directories\nExecute (x) - capability to execute files or view directory contents"
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-string-structure",
    "href": "slides/00-intro-overview.html#permission-string-structure",
    "title": "Unix Shell Workshop",
    "section": "Permission String Structure",
    "text": "Permission String Structure\n_rwxrwxrwx breakdown:\n\nFirst character - special permission flag (e.g., d = directory)\nFirst rwx - owner permissions\nSecond rwx - group permissions\nThird rwx - all users permissions"
  },
  {
    "objectID": "slides/00-intro-overview.html#users-and-groups",
    "href": "slides/00-intro-overview.html#users-and-groups",
    "title": "Unix Shell Workshop",
    "section": "Users and Groups",
    "text": "Users and Groups\n\n\n\n\n\n\nOn users and groups\n\n\nWhen listing the contents of a directory you may come across files that have the same text for both the user and group. An example of this is in the output:\n-rw-r--r--  1 nelle  nelle   422B  1 Sep  2019 test.txt\nIn Linux, users will usually have a group associated with them that shares the same name that the user does. While this can seem strange, make sure that you understand the difference in the output so you know who has access to your files."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-17",
    "href": "slides/00-intro-overview.html#challenge-17",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nCan you spot the difference here? What does it mean?\n\n\nLet‚Äôs take a look at some files in a different folder.\ncd Desktop/data-shell/north-pacific-gyre/2012-07-03\nls -l\n-rw-r--r-- 1 nelle  bio  4406  8 Aug  2019 NENE01729A.txt\n-rw-r--r-- 1 nelle  bio  4400  8 Aug  2019 NENE01729B.txt\n-rw-r--r-- 1 nelle  bio  4371  8 Aug  2019 NENE01736A.txt\n-rw-r--r-- 1 nelle  bio  4411  8 Aug  2019 NENE01751A.txt\n-rw-r--r-- 1 nelle  bio  4409  8 Aug  2019 NENE01751B.txt\n-rw-r--r-- 1 nelle  bio  4401  8 Aug  2019 NENE01812A.txt\n-rw-r--r-- 1 nelle  bio  4395  8 Aug  2019 NENE01843A.txt\n-rw-r--r-- 1 nelle  bio  4375  8 Aug  2019 NENE01843B.txt\n-rw-r--r-- 1 nelle  bio  4372  8 Aug  2019 NENE01971Z.txt\n-rw-r--r-- 1 nelle  bio  4381  8 Aug  2019 NENE01978A.txt\n-rw-r--r-- 1 nelle  bio  4389  8 Aug  2019 NENE01978B.txt\n-rw-r--r-- 1 nelle  bio  3517  8 Aug  2019 NENE02018B.txt\n-rw-r--r-- 1 nelle  bio  4391  8 Aug  2019 NENE02040A.txt\n-rw-r--r-- 1 nelle  bio  4367  8 Aug  2019 NENE02040B.txt\n-rw-r--r-- 1 nelle  bio  4381  8 Aug  2019 NENE02040Z.txt\n-rw-r--r-- 1 nelle  bio  4386  8 Aug  2019 NENE02043A.txt\n-rw-r--r-- 1 nelle  bio  4393  8 Aug  2019 NENE02043B.txt\n-rwxr-xr-x 1 nelle  bio   345  8 Aug  2019 goodiff\n-rwxr-xr-x 1 nelle  bio   218  8 Aug  2019 goostats\nThe data files in this folder, e.g NENE01978A.txt have a different permission set to goodiff. Can you tell why this is and explain what this might mean for the goodiff file?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-30",
    "href": "slides/00-intro-overview.html#solution-30",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe goodiff file has the execution flags set for user, group and all. Which will allow anyone to execute the file. It‚Äôs therefore likely that goodiff is a script that performs some actions. In theory you could run this script using ./goodiff"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-18",
    "href": "slides/00-intro-overview.html#challenge-18",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nChallenge\n\n\nLets take a further look at things by looking at in the folder above this.\ncd ..\nls -l\ndrwxr-xr-x 21 nelle  bio  672  8 Aug  2019 2012-07-03\nCan you guess what the d at the beginning of the output line means?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-32",
    "href": "slides/00-intro-overview.html#solution-32",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe d indicates whether the file has any special type associated with it. In this case it‚Äôs indicating that this is a directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#modifying-permissions",
    "href": "slides/00-intro-overview.html#modifying-permissions",
    "title": "Unix Shell Workshop",
    "section": "Modifying Permissions",
    "text": "Modifying Permissions\nLet‚Äôs say we want to modify who can access some of the files in the alkanes/ directory.\nWe‚Äôll assume here that we‚Äôre members of the bio group on our system.\nOn the cluster, all users must be members of cluster group to run jobs on the system. Each lab has a group associated with it, so we can use this method to share files with other members of the same lab."
  },
  {
    "objectID": "slides/00-intro-overview.html#groups-note",
    "href": "slides/00-intro-overview.html#groups-note",
    "title": "Unix Shell Workshop",
    "section": "Groups Note",
    "text": "Groups Note\n\n\n\n\n\n\nGroups\n\n\nYou‚Äôll find that if you try to assign a group to a file and the group does not exist you‚Äôll get something similar to the following output.\nchown: bio: illegal group name\nIf you‚Äôre trying to do this locally, you can list the groups you‚Äôre currently a member of using the groups command like so:\ngroups\nJust pick one of these groups to demonstrate the method shown below."
  },
  {
    "objectID": "slides/00-intro-overview.html#using-chown",
    "href": "slides/00-intro-overview.html#using-chown",
    "title": "Unix Shell Workshop",
    "section": "Using chown",
    "text": "Using chown\nChange ownership to allow compbio group to read file:\ncd Desktop/shell-lesson-data/exercise-data/alkanes\nchown nelle:compbio methane.pdb\nchown breakdown:\n\nchown - command\nnelle - user\ncompbio - group\nmethane.pdb - filename"
  },
  {
    "objectID": "slides/00-intro-overview.html#after-chown",
    "href": "slides/00-intro-overview.html#after-chown",
    "title": "Unix Shell Workshop",
    "section": "After chown",
    "text": "After chown\nWhen we list the contents of the directory again, we would see the change reflected like so:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r--r-- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#changing-permissions-with-chmod",
    "href": "slides/00-intro-overview.html#changing-permissions-with-chmod",
    "title": "Unix Shell Workshop",
    "section": "Changing Permissions with chmod",
    "text": "Changing Permissions with chmod\n\nchmod = change mode = change permissions\nAllow members of the group to make changes to methane.pdb, but not others.\nTo explicitly define permissions, reference the Permission Group and Permission Types."
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-groups",
    "href": "slides/00-intro-overview.html#permission-groups",
    "title": "Unix Shell Workshop",
    "section": "Permission Groups",
    "text": "Permission Groups\nThe Permission Groups used are:\n\nu - Owner\ng - Group\no - Other / All Users\na - All (Owner, Group and All Users)"
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-types",
    "href": "slides/00-intro-overview.html#permission-types",
    "title": "Unix Shell Workshop",
    "section": "Permission Types",
    "text": "Permission Types\nThe Permission Types that are used are:\n\nr - Read\nw - Write\nx - Execute\n\nThe potential Assignment Operators are + (plus) and - (minus); these are used to tell the system whether to add or remove the specific permissions."
  },
  {
    "objectID": "slides/00-intro-overview.html#chmod---remove---other-read",
    "href": "slides/00-intro-overview.html#chmod---remove---other-read",
    "title": "Unix Shell Workshop",
    "section": "chmod - Remove - Other Read",
    "text": "chmod - Remove - Other Read\nTo remove the ability for other users to read the methane.pdb file,\nchmod o-r methane.pdb\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r----- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\nThe r flag removed from other users section."
  },
  {
    "objectID": "slides/00-intro-overview.html#chmod---add-group-write",
    "href": "slides/00-intro-overview.html#chmod---add-group-write",
    "title": "Unix Shell Workshop",
    "section": "chmod - Add Group Write",
    "text": "chmod - Add Group Write\nAllow group members to write/edit:\nchmod g+w methane.pdb\nChecking this has gone through using ls -l:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-rw---- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-20",
    "href": "slides/00-intro-overview.html#challenge-20",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nChanging permissions for all files in a directory?\n\n\nSay we want to change the permissions for all the files in the alkanes/ directory, how we would do this? Let‚Äôs try and give apply what we‚Äôve just learnt to give all other users write permissions over the files."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-34",
    "href": "slides/00-intro-overview.html#solution-34",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThere‚Äôs actually a few ways we can go about this and it really depends on how we target the files to change. First, we could use the wildcards we learnt about previously to target files based on a specific pattern. In this case a simple * would suffice to pick out every file in the current folder, e.g:\nchmod o+w *\nWe could also use the recursive flag available to the chmod command to run through every file in a directory (including sub-directories) and apply a set of permissions to every file. E.g:\ncd ..\nchmod -R o+w alkanes/\nEither method works in this case, however be wary that as the -R flag works through the folder and all sub-folders, you may end up changing the permission on something you didn‚Äôt intend."
  },
  {
    "objectID": "slides/00-intro-overview.html#using-binary-references-to-set-permissions",
    "href": "slides/00-intro-overview.html#using-binary-references-to-set-permissions",
    "title": "Unix Shell Workshop",
    "section": "Using Binary References to Set Permissions",
    "text": "Using Binary References to Set Permissions\n\nAnother way to set the permission using binary references.\nThis replaces the explicitly defined permissions with binary references to these.\nWhile more complex than the previous method, we can use this to define multiple different permissions to all three permissions groups with a single command."
  },
  {
    "objectID": "slides/00-intro-overview.html#binary-references-example",
    "href": "slides/00-intro-overview.html#binary-references-example",
    "title": "Unix Shell Workshop",
    "section": "Binary References Example",
    "text": "Binary References Example\nAn example permission string would be chmod 764 methane.pdb, which means:\n\n\nthe owner has read, write and execute permissions\nthe group has read and write permissions\nall other users have read permissions to the file"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-21",
    "href": "slides/00-intro-overview.html#challenge-21",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nUsing binary references, how can you make a file executable?\n\n\nNow we‚Äôve seen how to use binary references to change permissions on a file. Can you change the methane.pdb file to make it executable? In this case, you can‚Äôt actually execute the file as it doesn‚Äôt contain the right data to do this, but it will teach you how to do this for other files in future, most notably scripts."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-36",
    "href": "slides/00-intro-overview.html#solution-36",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nTo ensure that we don‚Äôt make unintended changes to the other permissions currently assigned to the file, we need to first check what permissions it currently has\nls -l methane.pdb\n-rw-r--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nWe can see that both the read permission flags are set for groups and others. This makes creating the binary reference here easy as we only need to take the integer 4 for both these flags.\nNow we have the end of the binary reference, we need to add up the rest to give execute permissions to the file. As we already have read and write permissions as the owner of the file, we only need to add 1 to the binary reference to get 7. Therefore, the full binary reference we need to set is 744.\ncd ..\nchmod 744 methane.pdb\n-rwxr--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nHere, the first 7 assigns read, write, execute to owner, the first 4 adds read to the group, and the last 4 adds read permissions to others."
  },
  {
    "objectID": "slides/00-intro-overview.html#necessary-but-not-sufficient",
    "href": "slides/00-intro-overview.html#necessary-but-not-sufficient",
    "title": "Unix Shell Workshop",
    "section": "Necessary But Not Sufficient",
    "text": "Necessary But Not Sufficient\n\n\n\n\n\n\nNote\n\n\nThe fact that something is marked as executable doesn‚Äôt actually mean it contains a runnable program. Marking an HTML file executable won‚Äôt make it run as a program; the OS may instead open it in the associated application."
  },
  {
    "objectID": "slides/00-intro-overview.html#directory-permissions",
    "href": "slides/00-intro-overview.html#directory-permissions",
    "title": "Unix Shell Workshop",
    "section": "Directory Permissions",
    "text": "Directory Permissions\nLet‚Äôs run ls -a -l to get a long-form listing that includes directories that are hidden:\nls -a -l\ntotal 48\ndrwxr-xr-x 1 nelle  bio        0  8 Aug  2019 .\ndrwxr-xr-x 1 nelle  bio     8192  8 Aug  2019 ..\n-rw-r--rw- 1 nelle  bio     1158  8 Aug  2019 cubane.pdb\n-rw-r--rw- 1 nelle  bio      622  8 Aug  2019 ethane.pdb\n-rwxr--r-- 1 nelle  compbio  422  8 Aug  2019 methane.pdb\n-rw-r--rw- 1 nelle  bio     1828  8 Aug  2019 octane.pdb\n-rw-r--rw- 1 nelle  bio     1226  8 Aug  2019 pentane.pdb\n-rw-r--rw- 1 nelle  bio      825  8 Aug  2019 propane.pdb\n\nThe permissions for . and .. (this directory and its parent) start with a d.\n‚Äòx‚Äô means that ‚Äúexecute‚Äù is turned on.\nA directory isn‚Äôt a program‚Äîhow can we ‚Äúrun‚Äù it?\nIt gives someone the right to traverse the directory, but not to look at its contents."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-directory-example",
    "href": "slides/00-intro-overview.html#nelles-directory-example",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Directory Example",
    "text": "Nelle‚Äôs Directory Example\nNelle‚Äôs home directory has three subdirectories called venus, mars, and pluto:\n\nEach of these has a subdirectory in turn called notes, and those sub-subdirectories contain various files."
  },
  {
    "objectID": "slides/00-intro-overview.html#scenario-1-r-x-on-venus",
    "href": "slides/00-intro-overview.html#scenario-1-r-x-on-venus",
    "title": "Unix Shell Workshop",
    "section": "Scenario 1: r-x on venus",
    "text": "Scenario 1: r-x on venus\n\n\n\n\n\nIf a user‚Äôs permissions on venus are ‚Äòr-x‚Äô, then if she tries to see the contents of venus and venus/notes using ls, the computer lets her see both."
  },
  {
    "objectID": "slides/00-intro-overview.html#scenario-2-r-on-mars",
    "href": "slides/00-intro-overview.html#scenario-2-r-on-mars",
    "title": "Unix Shell Workshop",
    "section": "Scenario 2: r‚Äì on mars",
    "text": "Scenario 2: r‚Äì on mars\n\n\n\n\n\nIf her permissions on mars are just ‚Äòr‚Äì‚Äô, then she is allowed to read the contents of both mars and mars/notes."
  },
  {
    "objectID": "slides/00-intro-overview.html#scenario-3-x-on-pluto",
    "href": "slides/00-intro-overview.html#scenario-3-x-on-pluto",
    "title": "Unix Shell Workshop",
    "section": "Scenario 3: ‚Äìx on pluto",
    "text": "Scenario 3: ‚Äìx on pluto\n\n\n\n\n\nBut if her permissions on pluto are only ‚Äò‚Äìx‚Äô, she cannot see what‚Äôs in the pluto directory: ls pluto will tell her she doesn‚Äôt have permission to view its contents.\nIf she tries to look in pluto/notes, though, the computer will let her do that. She‚Äôs allowed to go through pluto, but not to look at what‚Äôs there."
  },
  {
    "objectID": "slides/00-intro-overview.html#starting-directory",
    "href": "slides/00-intro-overview.html#starting-directory",
    "title": "Unix Shell Workshop",
    "section": "Starting Directory",
    "text": "Starting Directory\nShell‚Äôs most powerful feature: Combine existing programs in new ways\nWe‚Äôll start with the directory: shell-lesson-data/exercise-data/alkanes with six molecule files:\nls\ncubane.pdb    methane.pdb    pentane.pdb\nethane.pdb    octane.pdb     propane.pdb\n.pdb = Protein Data Bank format (simple text with atom positions)"
  },
  {
    "objectID": "slides/00-intro-overview.html#command-wc-word-count",
    "href": "slides/00-intro-overview.html#command-wc-word-count",
    "title": "Unix Shell Workshop",
    "section": "Command: wc (word count)",
    "text": "Command: wc (word count)\nwc counts: lines, words, characters (in that order)\nwc cubane.pdb\n20  156 1158 cubane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#wc-with-wildcards",
    "href": "slides/00-intro-overview.html#wc-with-wildcards",
    "title": "Unix Shell Workshop",
    "section": "wc with Wildcards",
    "text": "wc with Wildcards\n* matches zero or more characters ‚Üí shell converts *.pdb to list of all .pdb files:\nwc *.pdb\n  20  156  1158  cubane.pdb\n  12   84   622  ethane.pdb\n   9   57   422  methane.pdb\n  30  246  1828  octane.pdb\n  21  165  1226  pentane.pdb\n  15  111   825  propane.pdb\n 107  819  6081  total\nNote: wc *.pdb also shows total lines in last line of output."
  },
  {
    "objectID": "slides/00-intro-overview.html#wc-options",
    "href": "slides/00-intro-overview.html#wc-options",
    "title": "Unix Shell Workshop",
    "section": "wc Options",
    "text": "wc Options\n\nwc -l ‚Üí lines only\nwc -w ‚Üí words only\nwc -m ‚Üí characters only\n\nwc -l *.pdb\n  20  cubane.pdb\n  12  ethane.pdb\n  ...\n 107  total"
  },
  {
    "objectID": "slides/00-intro-overview.html#what-if-no-input",
    "href": "slides/00-intro-overview.html#what-if-no-input",
    "title": "Unix Shell Workshop",
    "section": "What If No Input?",
    "text": "What If No Input?\n\n\n\n\n\n\nWhy Isn‚Äôt It Doing Anything?\n\n\nWhat happens if a command is supposed to process a file, but we don‚Äôt give it a filename? For example, what if we type:\nwc -l\nbut don‚Äôt type *.pdb (or anything else) after the command? Since it doesn‚Äôt have any filenames, wc assumes it is supposed to process input given at the command prompt, so it just sits there and waits for us to give it some data interactively. From the outside, though, all we see is it sitting there, and the command doesn‚Äôt appear to do anything.\nIf you make this kind of mistake, you can escape out of this state by holding down the control key (Ctrl) and pressing the letter C once: Ctrl+C. Then release both keys."
  },
  {
    "objectID": "slides/00-intro-overview.html#capturing-output-from-commands",
    "href": "slides/00-intro-overview.html#capturing-output-from-commands",
    "title": "Unix Shell Workshop",
    "section": "Capturing Output from Commands",
    "text": "Capturing Output from Commands\n\nProblem - Which of these files contains the fewest lines? It‚Äôs an easy question to answer when there are only six files, but what if there were 6000?\n\n\nwc -l *.pdb &gt; lengths.txt\n\n&gt; - tells the shell to redirect the command‚Äôs output to a file instead of printing it to the screen.\nThis command prints no screen output.\nEverything that wc would have printed has gone into the file lengths.txt instead.\nIf the file doesn‚Äôt exist, the shell will create the file.\nIf the file exists already, it will be silently overwritten."
  },
  {
    "objectID": "slides/00-intro-overview.html#confirm-file-created",
    "href": "slides/00-intro-overview.html#confirm-file-created",
    "title": "Unix Shell Workshop",
    "section": "Confirm File Created",
    "text": "Confirm File Created\nls lengths.txt confirms that the file exists:\nls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt:\ncat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\nThe cat command (concatenate) prints file contents. Name comes from joining files together."
  },
  {
    "objectID": "slides/00-intro-overview.html#alternative-less",
    "href": "slides/00-intro-overview.html#alternative-less",
    "title": "Unix Shell Workshop",
    "section": "Alternative: less",
    "text": "Alternative: less\n\n\n\n\n\n\nOutput Page by Page\n\n\nWe‚Äôll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g.¬†less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit."
  },
  {
    "objectID": "slides/00-intro-overview.html#filtering-output",
    "href": "slides/00-intro-overview.html#filtering-output",
    "title": "Unix Shell Workshop",
    "section": "Filtering Output",
    "text": "Filtering Output\n\nNext we‚Äôll use the sort command to sort the contents of the lengths.txt file.\nBut first we‚Äôll do an exercise to learn a little about the sort command."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-what-does-sort--n-do",
    "href": "slides/00-intro-overview.html#challenge-what-does-sort--n-do",
    "title": "Unix Shell Workshop",
    "section": "Challenge: What Does sort -n Do?",
    "text": "Challenge: What Does sort -n Do?\n\n\n\n\nChallenge\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-38",
    "href": "slides/00-intro-overview.html#solution-38",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe -n option specifies numerical (not alphanumerical) sort."
  },
  {
    "objectID": "slides/00-intro-overview.html#sort-numerically",
    "href": "slides/00-intro-overview.html#sort-numerically",
    "title": "Unix Shell Workshop",
    "section": "sort Numerically",
    "text": "sort Numerically\n-n option specifies numerical (not alphabetical) sort\nsort -n lengths.txt\n   9  methane.pdb\n  12  ethane.pdb\n  15  propane.pdb\n  20  cubane.pdb\n  21  pentane.pdb\n  30  octane.pdb\n 107  total"
  },
  {
    "objectID": "slides/00-intro-overview.html#save-sorted-output",
    "href": "slides/00-intro-overview.html#save-sorted-output",
    "title": "Unix Shell Workshop",
    "section": "Save Sorted Output",
    "text": "Save Sorted Output\nRedirect sorted output to file, then view first line:\nsort -n lengths.txt &gt; sorted-lengths.txt\nhead -n 1 sorted-lengths.txt\n   9  methane.pdb\n\n-n 1 with head tells it that we only want the first line of the file.\n-n 20 would get the first 20, and so on.\nSince sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines."
  },
  {
    "objectID": "slides/00-intro-overview.html#warning-redirecting-to-same-file",
    "href": "slides/00-intro-overview.html#warning-redirecting-to-same-file",
    "title": "Unix Shell Workshop",
    "section": "Warning: Redirecting to Same File",
    "text": "Warning: Redirecting to Same File\n\n\n\n\n\n\nRedirecting to the same file\n\n\nIt‚Äôs a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\nsort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-what-does-mean",
    "href": "slides/00-intro-overview.html#challenge-what-does-mean",
    "title": "Unix Shell Workshop",
    "section": "Challenge: What Does >> Mean?",
    "text": "Challenge: What Does &gt;&gt; Mean?\n\n\n\n\nChallenge\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We‚Äôll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\necho The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\necho hello &gt; testfile01.txt\nand:\necho hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-40",
    "href": "slides/00-intro-overview.html#solution-40",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nIn the first example with &gt;, the string ‚Äòhello‚Äô is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‚Äòhello‚Äô to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e.¬†when we run it for the second time)."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-appending-data",
    "href": "slides/00-intro-overview.html#challenge-appending-data",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Appending Data",
    "text": "Challenge: Appending Data\n\n\n\n\nChallenge\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\nhead -n 3 animals.csv &gt; animals-subset.csv\ntail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nFirst 3 lines of animals.csv\nLast 2 lines of animals.csv\nFirst 3 lines AND last 2 lines of animals.csv\nSecond and third lines of animals.csv"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-42",
    "href": "slides/00-intro-overview.html#solution-42",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv"
  },
  {
    "objectID": "slides/00-intro-overview.html#passing-output-to-another-command",
    "href": "slides/00-intro-overview.html#passing-output-to-another-command",
    "title": "Unix Shell Workshop",
    "section": "Passing Output to Another Command",
    "text": "Passing Output to Another Command\n\nIn our example of finding the file with the fewest lines, we used two intermediate files lengths.txt and sorted-lengths.txt to store output.\nThose intermediate files make it hard to follow what‚Äôs going on.\n\nWe can make it easier to understand by running sort and head together:\nsort -n lengths.txt | head -n 1\n   9  methane.pdb\n\nThe vertical bar, |, between the two commands is called a pipe.\nTells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis removes the need for intermediate file."
  },
  {
    "objectID": "slides/00-intro-overview.html#combining-multiple-commands",
    "href": "slides/00-intro-overview.html#combining-multiple-commands",
    "title": "Unix Shell Workshop",
    "section": "Combining Multiple Commands",
    "text": "Combining Multiple Commands\nWe can stack pipes. Send wc output ‚Üí sort, then ‚Üí head.\nwc -l *.pdb | sort -n\n   9  methane.pdb\n  12  ethane.pdb\n  15  propane.pdb\n  20  cubane.pdb\n  21  pentane.pdb\n  30  octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so the full pipeline becomes:\nwc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\n\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‚Äòthe log of three times x‚Äô.\nIn our case, the function is ‚Äòhead of sort of line count of *.pdb‚Äô."
  },
  {
    "objectID": "slides/00-intro-overview.html#redirects-and-pipes-diagram",
    "href": "slides/00-intro-overview.html#redirects-and-pipes-diagram",
    "title": "Unix Shell Workshop",
    "section": "Redirects and Pipes Diagram",
    "text": "Redirects and Pipes Diagram\nThe redirection and pipes used in the last few commands are illustrated below:"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-piping-commands-together",
    "href": "slides/00-intro-overview.html#challenge-piping-commands-together",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Piping Commands Together",
    "text": "Challenge: Piping Commands Together\n\n\n\n\nChallenge\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-44",
    "href": "slides/00-intro-overview.html#solution-44",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-pipe-reading-comprehension",
    "href": "slides/00-intro-overview.html#challenge-pipe-reading-comprehension",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Pipe Reading Comprehension",
    "text": "Challenge: Pipe Reading Comprehension\n\n\n\n\nChallenge\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\ncat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-46",
    "href": "slides/00-intro-overview.html#solution-46",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-pipe-construction",
    "href": "slides/00-intro-overview.html#challenge-pipe-construction",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Pipe Construction",
    "text": "Challenge: Pipe Construction\n\n\n\n\nChallenge\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\ncut -d , -f 2 animals.csv\nThe cut command is used to select or ‚Äòcut out‚Äô certain sections of each line in the file for further processing while leaving the original file unchanged. By default, cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter.\nIn the example above we use the -d option to specify the comma as our delimiter character instead of Tab. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-48",
    "href": "slides/00-intro-overview.html#solution-48",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\ncut -d , -f 2 animals.csv | sort | uniq"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-which-pipe",
    "href": "slides/00-intro-overview.html#challenge-which-pipe",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Which Pipe?",
    "text": "Challenge: Which Pipe?\n\n\n\n\nChallenge\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-50",
    "href": "slides/00-intro-overview.html#solution-50",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 4 is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory)."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-checking-files",
    "href": "slides/00-intro-overview.html#nelles-pipeline-checking-files",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: Checking Files",
    "text": "Nelle‚Äôs Pipeline: Checking Files\nNelle has run her samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, Nelle types:\ncd north-pacific-gyre\nwc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ..."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelle-identifies-a-problem",
    "href": "slides/00-intro-overview.html#nelle-identifies-a-problem",
    "title": "Unix Shell Workshop",
    "section": "Nelle Identifies a Problem",
    "text": "Nelle Identifies a Problem\nNow she types this:\nwc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others."
  },
  {
    "objectID": "slides/00-intro-overview.html#checking-the-short-file",
    "href": "slides/00-intro-overview.html#checking-the-short-file",
    "title": "Unix Shell Workshop",
    "section": "Checking the Short File",
    "text": "Checking the Short File\nWhen she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning ‚Äî someone was probably in using the machine on the weekend, and she forgot to reset it.\nBefore re-running that sample, she checks to see if any files have too much data:\nwc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total"
  },
  {
    "objectID": "slides/00-intro-overview.html#the-mystery-z-files",
    "href": "slides/00-intro-overview.html#the-mystery-z-files",
    "title": "Unix Shell Workshop",
    "section": "The Mystery ‚ÄòZ‚Äô Files",
    "text": "The Mystery ‚ÄòZ‚Äô Files\nThose numbers look good ‚Äî but what‚Äôs that ‚ÄòZ‚Äô doing there in the third-to-last line?\nAll of her samples should be marked ‚ÄòA‚Äô or ‚ÄòB‚Äô; by convention, her lab uses ‚ÄòZ‚Äô to indicate samples with missing information.\nTo find others like it, she does this:\nls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#dealing-with-missing-data",
    "href": "slides/00-intro-overview.html#dealing-with-missing-data",
    "title": "Unix Shell Workshop",
    "section": "Dealing with Missing Data",
    "text": "Dealing with Missing Data\nSure enough, when she checks the log on her laptop, there‚Äôs no depth recorded for either of those samples.\nSince it‚Äôs too late to get the information any other way, she must exclude those two files from her analysis.\nShe could delete them using rm, but there are actually some analyses she might do later where depth doesn‚Äôt matter, so instead, she‚Äôll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-removing-unneeded-files",
    "href": "slides/00-intro-overview.html#challenge-removing-unneeded-files",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Removing Unneeded Files",
    "text": "Challenge: Removing Unneeded Files\n\n\n\n\nChallenge\n\n\nSuppose you want to delete your processed data files, and only keep your raw files and processing script to save storage. The raw files end in .dat and the processed files end in .txt. Which of the following would remove all the processed data files, and only the processed data files?\n\nrm ?.txt\nrm *.txt\nrm * .txt\nrm *.*"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-52",
    "href": "slides/00-intro-overview.html#solution-52",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nThis would remove .txt files with one-character names\nThis is the correct answer\nThe shell would expand * to match everything in the current directory, so the command would try to remove all matched files and an additional file called .txt\nThe shell expands *.* to match all filenames containing at least one ., including the processed files (.txt) and raw files (.dat)"
  },
  {
    "objectID": "slides/00-intro-overview.html#what-are-loops",
    "href": "slides/00-intro-overview.html#what-are-loops",
    "title": "Unix Shell Workshop",
    "section": "What Are Loops?",
    "text": "What Are Loops?\nLoops are a programming construct which allow us to repeat a command or set of commands for each item in a list.\nAs such they are key to productivity improvements through automation.\nSimilar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes)."
  },
  {
    "objectID": "slides/00-intro-overview.html#loop-structure",
    "href": "slides/00-intro-overview.html#loop-structure",
    "title": "Unix Shell Workshop",
    "section": "Loop Structure",
    "text": "Loop Structure\n# The word \"for\" indicates the start of a \"For-loop\" command\nfor thing in list_of_things\n# The word \"do\" indicates the start of job execution list\ndo\n    # Execute command(s) using the variable\n    operation_using/command $thing\n# The word \"done\" indicates the end of a loop\ndone\nThree keywords: for, do, done"
  },
  {
    "objectID": "slides/00-intro-overview.html#example-files",
    "href": "slides/00-intro-overview.html#example-files",
    "title": "Unix Shell Workshop",
    "section": "Example Files",
    "text": "Example Files\nSuppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat.\nFor this example, we‚Äôll use the exercise-data/creatures directory which only has three example files, but the principles can be applied to many many more files at once.\nThe structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines."
  },
  {
    "objectID": "slides/00-intro-overview.html#looking-at-the-files",
    "href": "slides/00-intro-overview.html#looking-at-the-files",
    "title": "Unix Shell Workshop",
    "section": "Looking at the Files",
    "text": "Looking at the Files\nLet‚Äôs look at the files:\nhead -n 5 basilisk.dat minotaur.dat unicorn.dat\nWe would like to print out the classification for each species, which is given on the second line of each file.\nFor each file, we would need to execute the command head -n 2 and pipe this to tail -n 1."
  },
  {
    "objectID": "slides/00-intro-overview.html#general-form-of-a-loop",
    "href": "slides/00-intro-overview.html#general-form-of-a-loop",
    "title": "Unix Shell Workshop",
    "section": "General Form of a Loop",
    "text": "General Form of a Loop\nWe‚Äôll use a loop to solve this problem, but first let‚Äôs look at the general form of a loop:\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    echo $filename\ndone\nbasilisk.dat\nminotaur.dat\nunicorn.dat"
  },
  {
    "objectID": "slides/00-intro-overview.html#follow-the-prompt",
    "href": "slides/00-intro-overview.html#follow-the-prompt",
    "title": "Unix Shell Workshop",
    "section": "Follow the Prompt",
    "text": "Follow the Prompt\nWhen typing a loop, shell prompt changes:\n$ for filename in basilisk.dat minotaur.dat unicorn.dat\n&gt; do\n&gt;     echo $filename\n&gt; done\nThe &gt; prompt reminds you the command isn‚Äôt complete yet.\nA semicolon ; can separate commands on one line."
  },
  {
    "objectID": "slides/00-intro-overview.html#same-symbols-different-meanings",
    "href": "slides/00-intro-overview.html#same-symbols-different-meanings",
    "title": "Unix Shell Workshop",
    "section": "Same Symbols, Different Meanings",
    "text": "Same Symbols, Different Meanings\n\nShell prints &gt; or $: it‚Äôs a prompt (expects input)\nYou type &gt; or $: it‚Äôs an instruction (redirect or variable)\n\nContext matters!"
  },
  {
    "objectID": "slides/00-intro-overview.html#loop-iteration",
    "href": "slides/00-intro-overview.html#loop-iteration",
    "title": "Unix Shell Workshop",
    "section": "Loop Iteration",
    "text": "Loop Iteration\nEach time loop runs, variable holds next value:\n\nFirst: $filename = basilisk.dat\nSecond: $filename = minotaur.dat\nThird: $filename = unicorn.dat\n\nThen shell exits loop (no more items)."
  },
  {
    "objectID": "slides/00-intro-overview.html#variable-substitution",
    "href": "slides/00-intro-overview.html#variable-substitution",
    "title": "Unix Shell Workshop",
    "section": "Variable Substitution",
    "text": "Variable Substitution\nUse $varname to access the value.\nThe $ tells shell: treat this as a variable, not literal text.\nReplace with actual value before executing command."
  },
  {
    "objectID": "slides/00-intro-overview.html#practical-loop-example",
    "href": "slides/00-intro-overview.html#practical-loop-example",
    "title": "Unix Shell Workshop",
    "section": "Practical Loop Example",
    "text": "Practical Loop Example\nGet classification line from creature files:\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    echo $filename\n    head -n 2 $filename | tail -n 1\ndone\nbasilisk.dat\nCLASSIFICATION: basiliscus vulgaris\nminotaur.dat\nCLASSIFICATION: bos hominus\nunicorn.dat\nCLASSIFICATION: equus monoceros"
  },
  {
    "objectID": "slides/00-intro-overview.html#variable-name-vs-value",
    "href": "slides/00-intro-overview.html#variable-name-vs-value",
    "title": "Unix Shell Workshop",
    "section": "Variable Name vs Value",
    "text": "Variable Name vs Value\nVariable name: filename (the name)\nVariable value: basilisk.dat (the data)\nUse $filename to get the value, not the name."
  },
  {
    "objectID": "slides/00-intro-overview.html#variable-naming",
    "href": "slides/00-intro-overview.html#variable-naming",
    "title": "Unix Shell Workshop",
    "section": "Variable Naming",
    "text": "Variable Naming\nTwo syntaxes:\necho $filename      # Simple\necho ${filename}    # With braces (clearer)\nBraces useful when variable next to text:\necho ${filename}.bak    # Shows: basilisk.dat.bak\necho $filename.bak      # Looks for variable \"filename.bak\"!"
  },
  {
    "objectID": "slides/00-intro-overview.html#variable-naming-tips",
    "href": "slides/00-intro-overview.html#variable-naming-tips",
    "title": "Unix Shell Workshop",
    "section": "Variable Naming Tips",
    "text": "Variable Naming Tips\n\nUse meaningful names: filename, not x\nHelps others (and future you) understand code\nIncreases odds people interpret it correctly\n\nThe shell doesn‚Äôt care‚Äîonly we do!"
  },
  {
    "objectID": "slides/00-intro-overview.html#loops-with-numbers",
    "href": "slides/00-intro-overview.html#loops-with-numbers",
    "title": "Unix Shell Workshop",
    "section": "Loops with Numbers",
    "text": "Loops with Numbers\nLoops work with any list, not just filenames:\nfor number in 0 1 2 3 4 5\ndo\n    echo $number\ndone"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-write-your-own-loop",
    "href": "slides/00-intro-overview.html#challenge-write-your-own-loop",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Write Your Own Loop",
    "text": "Challenge: Write Your Own Loop\n\n\n\n\nChallenge\n\n\nHow would you write a loop that echoes all 10 numbers from 0 to 9?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-54",
    "href": "slides/00-intro-overview.html#solution-54",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nfor loop_variable in 0 1 2 3 4 5 6 7 8 9\ndo\n    echo $loop_variable\ndone\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nAlternatively, try replacing the enumeration of integers 0 1 2 3 4 5 6 7 8 9 by {0..9} to obtain an identical output."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-variables-in-loops",
    "href": "slides/00-intro-overview.html#challenge-variables-in-loops",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Variables in Loops",
    "text": "Challenge: Variables in Loops\n\n\n\n\nChallenge\n\n\nIn shell-lesson-data/exercise-data/alkanes, ls *.pdb gives:\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\nFirst code:\nfor datafile in *.pdb\ndo\n    ls *.pdb\ndone\nSecond code:\nfor datafile in *.pdb\ndo\n    ls $datafile\ndone\nWhat‚Äôs the difference?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-56",
    "href": "slides/00-intro-overview.html#solution-56",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nFirst code: lists ALL .pdb files each iteration (6 times total).\nShell expands *.pdb in loop body for each iteration.\nSecond code: lists ONE file per iteration (6 different files).\nVariable $datafile evaluates to current file each time.\nSecond code is cleaner and what we usually want!"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-limiting-sets-of-files-c",
    "href": "slides/00-intro-overview.html#challenge-limiting-sets-of-files-c",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Limiting Sets of Files (c*)",
    "text": "Challenge: Limiting Sets of Files (c*)\n\n\n\n\nChallenge\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop output?\nfor filename in c*\ndo\n    ls $filename\ndone\n\nNo files listed\nAll files are listed\nOnly cubane.pdb, octane.pdb, pentane.pdb\nOnly cubane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-58",
    "href": "slides/00-intro-overview.html#solution-58",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 4 is correct.\n* matches zero or more characters.\nc* matches any filename starting with ‚Äòc‚Äô (only cubane.pdb)."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-limiting-sets-c",
    "href": "slides/00-intro-overview.html#challenge-limiting-sets-c",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Limiting Sets (c)",
    "text": "Challenge: Limiting Sets (c)\n\n\n\n\nChallenge\n\n\nHow different is this loop?\nfor filename in *c*\ndo\n    ls $filename\ndone\n\nSame files listed\nAll files are listed now\nNo files listed now\ncubane.pdb and octane.pdb\nOnly octane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-60",
    "href": "slides/00-intro-overview.html#solution-60",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 4 is correct.\n*c* matches filename with ‚Äòc‚Äô anywhere in name (before or after).\nMatches: cubane.pdb (c at start) and octane.pdb (c in middle)."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-saving-to-file-with",
    "href": "slides/00-intro-overview.html#challenge-saving-to-file-with",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Saving to File with >",
    "text": "Challenge: Saving to File with &gt;\n\n\n\n\nChallenge\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop do?\nfor alkanes in *.pdb\ndo\n    echo $alkanes\n    cat $alkanes &gt; alkanes.pdb\ndone\n\nPrints all 6 files; only propane.pdb saved to alkanes.pdb\nPrints 3 files; all concatenated and saved to alkanes.pdb\nPrints 5 files; only propane.pdb saved to alkanes.pdb\nNone of the above"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-62",
    "href": "slides/00-intro-overview.html#solution-62",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 1 is correct.\nEach iteration: &gt; overwrites (not appends).\nLast file processed (propane.pdb) is final content.\nUse &gt;&gt; to append instead!"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-saving-to-file-with-1",
    "href": "slides/00-intro-overview.html#challenge-saving-to-file-with-1",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Saving to File with >>",
    "text": "Challenge: Saving to File with &gt;&gt;\n\n\n\n\nChallenge\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop do?\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\n\nAll files up to pentane.pdb concatenated\nOnly ethane.pdb saved\nAll 6 files concatenated to all.pdb\nAll 5 files concatenated"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-64",
    "href": "slides/00-intro-overview.html#solution-64",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 3 is correct.\n&gt;&gt; appends each file (doesn‚Äôt overwrite).\nAll 6 files concatenated to all.pdb.\nNothing printed (output redirected to file)."
  },
  {
    "objectID": "slides/00-intro-overview.html#another-practical-example",
    "href": "slides/00-intro-overview.html#another-practical-example",
    "title": "Unix Shell Workshop",
    "section": "Another Practical Example",
    "text": "Another Practical Example\nIn shell-lesson-data/exercise-data/creatures:\nfor filename in *.dat\ndo\n    echo $filename\n    head -n 100 $filename | tail -n 20\ndone\nLoop body: two commands - Echo filename - Select lines 81-100 (or all if fewer than 100)"
  },
  {
    "objectID": "slides/00-intro-overview.html#spaces-in-filenames",
    "href": "slides/00-intro-overview.html#spaces-in-filenames",
    "title": "Unix Shell Workshop",
    "section": "Spaces in Filenames",
    "text": "Spaces in Filenames\nShell uses spaces to separate items!\nFilenames with spaces: red dragon.dat, purple unicorn.dat\nMust quote them:\nfor filename in \"red dragon.dat\" \"purple unicorn.dat\"\ndo\n    head -n 100 \"$filename\" | tail -n 20\ndone\nAlways quote variables to be safe: \"$filename\"\nIt is simpler to avoid using spaces (or other special characters) in filenames."
  },
  {
    "objectID": "slides/00-intro-overview.html#what-happens-without-quotes",
    "href": "slides/00-intro-overview.html#what-happens-without-quotes",
    "title": "Unix Shell Workshop",
    "section": "What Happens Without Quotes?",
    "text": "What Happens Without Quotes?\nThe files red dragon.dat and purple unicorn.dat don‚Äôt exist, so if we run the code without quotes around $filename, we get errors:\nhead: cannot open 'red' for reading: No such file or directory\nhead: cannot open 'dragon.dat' for reading: No such file or directory\nhead: cannot open 'purple' for reading: No such file or directory\nWith quotes, we‚Äôd see:\nhead: cannot open 'red dragon.dat' for reading: No such file or directory\nhead: cannot open 'purple unicorn.dat' for reading: No such file or directory"
  },
  {
    "objectID": "slides/00-intro-overview.html#why-quote-variables",
    "href": "slides/00-intro-overview.html#why-quote-variables",
    "title": "Unix Shell Workshop",
    "section": "Why Quote Variables?",
    "text": "Why Quote Variables?\nWithout quotes: - Shell splits by spaces - \"red dragon.dat\" becomes two items: red, dragon.dat - Commands fail\nWith quotes: - Treated as single item - Commands work correctly\nBest practice: Avoid spaces in filenames entirely (use - or _)."
  },
  {
    "objectID": "slides/00-intro-overview.html#backing-up-files-in-a-loop",
    "href": "slides/00-intro-overview.html#backing-up-files-in-a-loop",
    "title": "Unix Shell Workshop",
    "section": "Backing Up Files in a Loop",
    "text": "Backing Up Files in a Loop\nProblem: Copy all .dat files to original- versions.\nCan‚Äôt do this:\ncp *.dat original-*.dat  # ERROR!\nExpands to: cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\nShell sees 4 arguments, expects last to be directory!"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-use-a-loop",
    "href": "slides/00-intro-overview.html#solution-use-a-loop",
    "title": "Unix Shell Workshop",
    "section": "Solution: Use a Loop",
    "text": "Solution: Use a Loop\nfor filename in *.dat\ndo\n    cp $filename original-$filename\ndone\nEach iteration: - $filename = basilisk.dat ‚Üí cp basilisk.dat original-basilisk.dat - $filename = minotaur.dat ‚Üí cp minotaur.dat original-minotaur.dat - $filename = unicorn.dat ‚Üí cp unicorn.dat original-unicorn.dat"
  },
  {
    "objectID": "slides/00-intro-overview.html#testing-loops-with-echo",
    "href": "slides/00-intro-overview.html#testing-loops-with-echo",
    "title": "Unix Shell Workshop",
    "section": "Testing Loops with echo",
    "text": "Testing Loops with echo\nHard to verify loop did what you want (no output from cp).\nSolution: Use echo to print commands without executing:\nfor filename in *.dat\ndo\n    echo cp $filename original-$filename\ndone\nSee what would run, verify correctness, then remove echo!\nThe judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "slides/00-intro-overview.html#loop-flow-chart",
    "href": "slides/00-intro-overview.html#loop-flow-chart",
    "title": "Unix Shell Workshop",
    "section": "Loop Flow Chart",
    "text": "Loop Flow Chart\nThe following diagram shows what happens when the modified loop is executed, and demonstrates how the judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-processing-files",
    "href": "slides/00-intro-overview.html#nelles-pipeline-processing-files",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: Processing Files",
    "text": "Nelle‚Äôs Pipeline: Processing Files\nNelle is now ready to process her data files using goostats.sh ‚Äî a shell script written by her supervisor.\nThis calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince she‚Äôs still learning how to use the shell, she decides to build up the required commands in stages."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelle-tests-file-selection",
    "href": "slides/00-intro-overview.html#nelle-tests-file-selection",
    "title": "Unix Shell Workshop",
    "section": "Nelle Tests File Selection",
    "text": "Nelle Tests File Selection\nHer first step is to make sure that she can select the right input files ‚Äî remember, these are ones whose names end in ‚ÄòA‚Äô or ‚ÄòB‚Äô, rather than ‚ÄòZ‚Äô.\nMoving to the north-pacific-gyre directory, Nelle types:\ncd\ncd Desktop/shell-lesson-data/north-pacific-gyre\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\ndone\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\nNENE02040B.txt\nNENE02043B.txt\nGood! Selects correct files."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelle-builds-output-filenames",
    "href": "slides/00-intro-overview.html#nelle-builds-output-filenames",
    "title": "Unix Shell Workshop",
    "section": "Nelle Builds Output Filenames",
    "text": "Nelle Builds Output Filenames\nHer next step is to decide what to call the files that the goostats.sh analysis program will create.\nPrefixing each input file‚Äôs name with ‚Äòstats‚Äô seems simple, so she modifies her loop:\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile stats-$datafile\ndone\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01736A.txt\nNENE01751A.txt stats-NENE01751A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nPerfect! Ready to process.\nShe hasn‚Äôt actually run goostats.sh yet, but now she‚Äôs sure she can select the right files and generate the right output filenames."
  },
  {
    "objectID": "slides/00-intro-overview.html#command-history",
    "href": "slides/00-intro-overview.html#command-history",
    "title": "Unix Shell Workshop",
    "section": "Command History",
    "text": "Command History\nTyping same command repeatedly is tedious!\nShell remembers recent commands.\nView history:\nhistory\nShows numbered list of previous commands."
  },
  {
    "objectID": "slides/00-intro-overview.html#accessing-history",
    "href": "slides/00-intro-overview.html#accessing-history",
    "title": "Unix Shell Workshop",
    "section": "Accessing History",
    "text": "Accessing History\n\n\n\nMethod\nWhat it does\n\n\n\n\n‚Üë\nPrevious command\n\n\n‚Üì\nNext command\n\n\n!42\nRun command #42\n\n\nCtrl-R\nSearch history"
  },
  {
    "objectID": "slides/00-intro-overview.html#one-liner-loop",
    "href": "slides/00-intro-overview.html#one-liner-loop",
    "title": "Unix Shell Workshop",
    "section": "One-Liner Loop",
    "text": "One-Liner Loop\nPress Up arrow:\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nEntire loop on one line using semicolons ;\nSame as multi-line version!"
  },
  {
    "objectID": "slides/00-intro-overview.html#beginning-and-end",
    "href": "slides/00-intro-overview.html#beginning-and-end",
    "title": "Unix Shell Workshop",
    "section": "Beginning and End",
    "text": "Beginning and End\n\n\n\n\n\n\nBeginning and End\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E."
  },
  {
    "objectID": "slides/00-intro-overview.html#those-who-know-history",
    "href": "slides/00-intro-overview.html#those-who-know-history",
    "title": "Unix Shell Workshop",
    "section": "Those Who Know History",
    "text": "Those Who Know History\n\n\n\n\n\n\nThose Who Know History Can Choose to Repeat It\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where 123 is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:\nhistory | tail -n 5\n  456  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n  457  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n  458  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; done\n  459  cd ..\n  460  history | tail -n 5\nthen she can re-run bash goostats.sh on all her files by typing !457."
  },
  {
    "objectID": "slides/00-intro-overview.html#other-history-commands",
    "href": "slides/00-intro-overview.html#other-history-commands",
    "title": "Unix Shell Workshop",
    "section": "Other history Commands",
    "text": "Other history Commands\n\n\n\n\n\n\nOther history Commands\n\n\nThere are a number of other shortcut commands for getting at the history:\n\nCtrl+R enters a history search mode ‚Äòreverse-i-search‚Äô and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ‚Üë)\n!$ retrieves the last word of the last command. That‚Äôs useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ‚Üë and editing the command-line."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-doing-a-dry-run",
    "href": "slides/00-intro-overview.html#challenge-doing-a-dry-run",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Doing a Dry Run",
    "text": "Challenge: Doing a Dry Run\n\n\n\n\nChallenge\n\n\nA loop is a way to do many things at once ‚Äî or to make many mistakes at once if it does the wrong thing. One way to check what a loop would do is to echo the commands it would run instead of actually running them.\nSuppose we want to preview the commands the following loop will execute without actually running those commands:\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\nWhat is the difference between the two loops below, and which one would we want to run?\n# Version 1\nfor datafile in *.pdb\ndo\n    echo cat $datafile &gt;&gt; all.pdb\ndone\n# Version 2\nfor datafile in *.pdb\ndo\n    echo \"cat $datafile &gt;&gt; all.pdb\"\ndone"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-66",
    "href": "slides/00-intro-overview.html#solution-66",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nThe second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also does not modify nor create the file all.pdb, as the &gt;&gt; is treated literally as part of a string rather than as a redirection instruction.\nThe first version appends the output from the command echo cat $datafile to the file, all.pdb. This file will just contain the list; cat cubane.pdb, cat ethane.pdb, cat methane.pdb etc.\nTry both versions for yourself to see the output! Be sure to open the all.pdb file to view its contents."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-nested-loops",
    "href": "slides/00-intro-overview.html#challenge-nested-loops",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Nested Loops",
    "text": "Challenge: Nested Loops\n\n\n\n\nChallenge\n\n\nSuppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds and different temperatures. What would be the result of the following code:\nfor species in cubane ethane methane\ndo\n    for temperature in 25 30 37 40\n    do\n        mkdir $species-$temperature\n    done\ndone"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-68",
    "href": "slides/00-intro-overview.html#solution-68",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nWe have a nested loop, i.e.¬†contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.\nTry running the code for yourself to see which directories are created!"
  },
  {
    "objectID": "slides/00-intro-overview.html#why-shell-scripts",
    "href": "slides/00-intro-overview.html#why-shell-scripts",
    "title": "Unix Shell Workshop",
    "section": "Why Shell Scripts?",
    "text": "Why Shell Scripts?\nA file containing shell commands = a small program\nBenefits of shell scripts:\n\nSpeed: No retyping commands\nAccuracy: Fewer chances for typos\nReproducibility: Same results every time\nDocumentation: Shows what was done\nSharing: Others can use your work\n\nLet‚Äôs turn repeated commands into reusable programs!"
  },
  {
    "objectID": "slides/00-intro-overview.html#creating-your-first-script",
    "href": "slides/00-intro-overview.html#creating-your-first-script",
    "title": "Unix Shell Workshop",
    "section": "Creating Your First Script",
    "text": "Creating Your First Script\nNavigate to alkanes/ directory and create a script:\ncd alkanes\nnano middle.sh\nThe nano command opens a text editor in the shell."
  },
  {
    "objectID": "slides/00-intro-overview.html#text-editors-vs.-word-processors",
    "href": "slides/00-intro-overview.html#text-editors-vs.-word-processors",
    "title": "Unix Shell Workshop",
    "section": "Text Editors vs.¬†Word Processors",
    "text": "Text Editors vs.¬†Word Processors\n\n\n\n\n\n\nText vs.¬†Whatever\n\n\nWord processors (Microsoft Word, LibreOffice) store formatting information about fonts, headings, etc.\nShell commands need plain text only ‚Äî no formatting codes.\nWhen editing programs, save as plain text, not .docx or .odt!"
  },
  {
    "objectID": "slides/00-intro-overview.html#your-first-script-content",
    "href": "slides/00-intro-overview.html#your-first-script-content",
    "title": "Unix Shell Workshop",
    "section": "Your First Script Content",
    "text": "Your First Script Content\nIn nano, type this pipe that selects lines 11-15:\nhead -n 15 octane.pdb | tail -n 5\nSave with: Ctrl-O, then Enter, then Ctrl-X to exit\nVerify it was created:\nls -l middle.sh"
  },
  {
    "objectID": "slides/00-intro-overview.html#running-your-script",
    "href": "slides/00-intro-overview.html#running-your-script",
    "title": "Unix Shell Workshop",
    "section": "Running Your Script",
    "text": "Running Your Script\nExecute the script:\nbash middle.sh\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOutput matches running the command manually!"
  },
  {
    "objectID": "slides/00-intro-overview.html#problem-not-flexible",
    "href": "slides/00-intro-overview.html#problem-not-flexible",
    "title": "Unix Shell Workshop",
    "section": "Problem: Not Flexible",
    "text": "Problem: Not Flexible\nCurrent issue: Script only works on octane.pdb\nSolution: Make it accept command-line arguments!\nThen same script works on any file."
  },
  {
    "objectID": "slides/00-intro-overview.html#making-scripts-flexible-using-1",
    "href": "slides/00-intro-overview.html#making-scripts-flexible-using-1",
    "title": "Unix Shell Workshop",
    "section": "Making Scripts Flexible: Using $1",
    "text": "Making Scripts Flexible: Using $1\nEdit middle.sh to use a variable:\nnano middle.sh\nReplace octane.pdb with special variable $1:\nhead -n 15 \"$1\" | tail -n 5\n$1 means: first command-line argument"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-the-1-argument",
    "href": "slides/00-intro-overview.html#using-the-1-argument",
    "title": "Unix Shell Workshop",
    "section": "Using the $1 Argument",
    "text": "Using the $1 Argument\nNow the script works on any file:\nbash middle.sh octane.pdb\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOr with a different file:\nbash middle.sh pentane.pdb\nSame script, different results!"
  },
  {
    "objectID": "slides/00-intro-overview.html#quoting-arguments-matters",
    "href": "slides/00-intro-overview.html#quoting-arguments-matters",
    "title": "Unix Shell Workshop",
    "section": "Quoting Arguments Matters",
    "text": "Quoting Arguments Matters\n\n\n\n\n\n\nDouble-Quotes Around Arguments\n\n\nAlways put double-quotes around variables to handle filenames with spaces:\nhead \"$1\" | tail -n 5     # Safe!\nhead $1 | tail -n 5       # Breaks if spaces in filename!\nThis also protects special characters in filenames."
  },
  {
    "objectID": "slides/00-intro-overview.html#making-it-more-flexible-2-3",
    "href": "slides/00-intro-overview.html#making-it-more-flexible-2-3",
    "title": "Unix Shell Workshop",
    "section": "Making It More Flexible: $2, $3",
    "text": "Making It More Flexible: $2, $3\nMake the script control all parameters:\nnano middle.sh\nEdit to:\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nNow: - $1 = filename - $2 = lines for head - $3 = lines for tail"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-multiple-arguments",
    "href": "slides/00-intro-overview.html#using-multiple-arguments",
    "title": "Unix Shell Workshop",
    "section": "Using Multiple Arguments",
    "text": "Using Multiple Arguments\nWith three parameters, we can change behavior:\nbash middle.sh pentane.pdb 15 5\nATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00\nATOM     10  H           1       1.271   1.378   0.122  1.00  0.00\nATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00\nATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00\nATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00\nOr with different numbers:\nbash middle.sh pentane.pdb 20 5\nATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00\nATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00\nATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00\nATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00\nTER      18              1"
  },
  {
    "objectID": "slides/00-intro-overview.html#adding-comments-for-documentation",
    "href": "slides/00-intro-overview.html#adding-comments-for-documentation",
    "title": "Unix Shell Workshop",
    "section": "Adding Comments for Documentation",
    "text": "Adding Comments for Documentation\nThe next reader won‚Äôt know what $2 and $3 mean!\nEdit middle.sh to add helpful comments:\nnano middle.sh\n# Select lines from the middle of a file.\n# Usage: bash middle.sh filename end_line num_lines\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nComments start with # and run to end of line."
  },
  {
    "objectID": "slides/00-intro-overview.html#comment-best-practices",
    "href": "slides/00-intro-overview.html#comment-best-practices",
    "title": "Unix Shell Workshop",
    "section": "Comment Best Practices",
    "text": "Comment Best Practices\nKeep comments accurate and up-to-date!\nAn inaccurate comment is worse than no comment.\nUpdate comments whenever you change code."
  },
  {
    "objectID": "slides/00-intro-overview.html#all-arguments-using",
    "href": "slides/00-intro-overview.html#all-arguments-using",
    "title": "Unix Shell Workshop",
    "section": "All Arguments: Using $@",
    "text": "All Arguments: Using $@\nChallenge: Process many files at once.\nExample: sort .pdb files by line count:\nwc -l *.pdb | sort -n\nWe need a way to pass any number of filenames.\nSolution: $@ = all command-line arguments"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-in-a-script",
    "href": "slides/00-intro-overview.html#using-in-a-script",
    "title": "Unix Shell Workshop",
    "section": "Using $@ in a Script",
    "text": "Using $@ in a Script\nCreate a new script that accepts many files:\nnano sorted.sh\n# Sort files by their length.\n# Usage: bash sorted.sh one_or_more_filenames\nwc -l \"$@\" | sort -n\n$@ automatically expands to all arguments!"
  },
  {
    "objectID": "slides/00-intro-overview.html#running-script-with-multiple-files",
    "href": "slides/00-intro-overview.html#running-script-with-multiple-files",
    "title": "Unix Shell Workshop",
    "section": "Running Script with Multiple Files",
    "text": "Running Script with Multiple Files\nbash sorted.sh *.pdb ../creatures/*.dat\n9 methane.pdb\n12 ethane.pdb\n15 propane.pdb\n20 cubane.pdb\n21 pentane.pdb\n30 octane.pdb\n163 ../creatures/basilisk.dat\n163 ../creatures/minotaur.dat\n163 ../creatures/unicorn.dat\n596 total\nWorks with any number of files!"
  },
  {
    "objectID": "slides/00-intro-overview.html#script-arguments-reference",
    "href": "slides/00-intro-overview.html#script-arguments-reference",
    "title": "Unix Shell Workshop",
    "section": "Script Arguments Reference",
    "text": "Script Arguments Reference\n\n\n\nVariable\nMeaning\n\n\n\n\n$1\nFirst argument\n\n\n$2\nSecond argument\n\n\n$3\nThird argument\n\n\n$@\nAll arguments\n\n\n$#\nNumber of arguments"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-list-unique-species",
    "href": "slides/00-intro-overview.html#challenge-list-unique-species",
    "title": "Unix Shell Workshop",
    "section": "Challenge: List Unique Species",
    "text": "Challenge: List Unique Species\n\n\n\n\nChallenge\n\n\nLeah has hundreds of data files formatted like animals.csv:\n2013-11-05,deer,5\n2013-11-05,rabbit,22\n2013-11-05,raccoon,7\n2013-11-06,rabbit,19\n2013-11-06,deer,2\n2013-11-06,fox,1\n2013-11-07,rabbit,18\n2013-11-07,bear,1\nCommand to extract unique species (second field, separated by commas):\ncut -d , -f 2 animals.csv | sort | uniq\nWrite a shell script called species.sh that takes any number of filenames as arguments and prints the unique species in each file (one file per section)."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-list-unique-species",
    "href": "slides/00-intro-overview.html#solution-list-unique-species",
    "title": "Unix Shell Workshop",
    "section": "Solution: List Unique Species",
    "text": "Solution: List Unique Species\n\n\n\n\nSolution\n\n\nCreate species.sh:\n# Script to find unique species in csv files \n# where species is the second data field\n# This script accepts any number of file names as command line arguments\n\n# Loop over all files\nfor file in $@\ndo\n    cut -d , -f 2 $file | sort | uniq\ndone\nUsage:\nbash species.sh animals.csv other-animals.csv"
  },
  {
    "objectID": "slides/00-intro-overview.html#the-shebang-binbash",
    "href": "slides/00-intro-overview.html#the-shebang-binbash",
    "title": "Unix Shell Workshop",
    "section": "The Shebang: #!/bin/bash",
    "text": "The Shebang: #!/bin/bash\nMost scripts start with a shebang line:\n#!/bin/bash\nThis tells the system: Use bash to run this script\nThen you can run the script directly:\n./middle.sh octane.pdb\nInstead of always typing:\nbash middle.sh octane.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#making-scripts-executable",
    "href": "slides/00-intro-overview.html#making-scripts-executable",
    "title": "Unix Shell Workshop",
    "section": "Making Scripts Executable",
    "text": "Making Scripts Executable\nAdd shebang as first line:\n#!/bin/bash\n# Select lines from middle of file\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nThen make it executable:\nchmod u+x middle.sh\nNow run it directly:\n./middle.sh pentane.pdb 15 5\nCongratulations! You‚Äôve created a true executable program!"
  },
  {
    "objectID": "slides/00-intro-overview.html#saving-command-history",
    "href": "slides/00-intro-overview.html#saving-command-history",
    "title": "Unix Shell Workshop",
    "section": "Saving Command History",
    "text": "Saving Command History\nYou‚Äôve run useful commands ‚Äî save them for later!\nhistory | tail -n 5 &gt; redo-figure-3.sh\nThe file redo-figure-3.sh now contains:\n297 bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n298 bash goodiff.sh stats-NENE01729B.txt /data/validated/01729.txt &gt; 01729-differences.txt\n299 cut -d ',' -f 2-3 01729-differences.txt &gt; 01729-time-series.txt\n300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png\n301 history | tail -n 5 &gt; redo-figure-3.sh\nEdit to remove line numbers and the history command itself.\nResult: Perfect reproduction record!"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-why-record-commands-in-the-history-before-running-them",
    "href": "slides/00-intro-overview.html#challenge-why-record-commands-in-the-history-before-running-them",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Why Record Commands in the History Before Running Them?",
    "text": "Challenge: Why Record Commands in the History Before Running Them?\n\n\n\n\nChallenge\n\n\nIf you run the command:\nhistory | tail -n 5 &gt; recent.sh\nthe last command in the file is the history command itself, i.e., the shell has added history to the command log before actually running it.\nIn fact, the shell always adds commands to the log before running them.\nWhy do you think it does this?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-why-record-commands-in-the-history-before-running-them",
    "href": "slides/00-intro-overview.html#solution-why-record-commands-in-the-history-before-running-them",
    "title": "Unix Shell Workshop",
    "section": "Solution: Why Record Commands in the History Before Running Them?",
    "text": "Solution: Why Record Commands in the History Before Running Them?\n\n\n\n\nSolution\n\n\nIf a command causes something to crash or hang, it might be useful to know what that command was, in order to investigate the problem.\nWere the command only be recorded after running it, we would not have a record of the last command run in the event of a crash."
  },
  {
    "objectID": "slides/00-intro-overview.html#developing-shell-scripts",
    "href": "slides/00-intro-overview.html#developing-shell-scripts",
    "title": "Unix Shell Workshop",
    "section": "Developing Shell Scripts",
    "text": "Developing Shell Scripts\nIn practice, most people develop shell scripts by running commands at the shell prompt a few times to make sure they‚Äôre doing the right thing, then saving them in a file for re-use.\nThis style of work allows people to recycle what they discover about their data and their workflow with one call to history and a bit of editing to clean up the output and save it as a shell script."
  },
  {
    "objectID": "slides/00-intro-overview.html#nelles-pipeline-creating-a-script",
    "href": "slides/00-intro-overview.html#nelles-pipeline-creating-a-script",
    "title": "Unix Shell Workshop",
    "section": "Nelle‚Äôs Pipeline: Creating a Script",
    "text": "Nelle‚Äôs Pipeline: Creating a Script\nNelle‚Äôs supervisor insisted that all her analytics must be reproducible.\nThe easiest way to capture all the steps is in a script.\nFirst we return to Nelle‚Äôs project directory:\ncd ../../north-pacific-gyre/"
  },
  {
    "objectID": "slides/00-intro-overview.html#nelle-creates-do-stats.sh",
    "href": "slides/00-intro-overview.html#nelle-creates-do-stats.sh",
    "title": "Unix Shell Workshop",
    "section": "Nelle Creates do-stats.sh",
    "text": "Nelle Creates do-stats.sh\nShe creates a file using nano:\nnano do-stats.sh\n‚Ä¶which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone"
  },
  {
    "objectID": "slides/00-intro-overview.html#running-nelles-script",
    "href": "slides/00-intro-overview.html#running-nelles-script",
    "title": "Unix Shell Workshop",
    "section": "Running Nelle‚Äôs Script",
    "text": "Running Nelle‚Äôs Script\nShe saves this in a file called do-stats.sh so that she can now re-do the first stage of her analysis by typing:\nbash do-stats.sh NENE*A.txt NENE*B.txt\nShe can also do this:\nbash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed."
  },
  {
    "objectID": "slides/00-intro-overview.html#script-design-tradeoffs",
    "href": "slides/00-intro-overview.html#script-design-tradeoffs",
    "title": "Unix Shell Workshop",
    "section": "Script Design Tradeoffs",
    "text": "Script Design Tradeoffs\nOne thing to note about Nelle‚Äôs script is that it lets the person running it decide what files to process.\nShe could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone"
  },
  {
    "objectID": "slides/00-intro-overview.html#hardcoded-vs.-flexible-scripts",
    "href": "slides/00-intro-overview.html#hardcoded-vs.-flexible-scripts",
    "title": "Unix Shell Workshop",
    "section": "Hardcoded vs.¬†Flexible Scripts",
    "text": "Hardcoded vs.¬†Flexible Scripts\nAdvantage: This always selects the right files ‚Äî she doesn‚Äôt have to remember to exclude the ‚ÄòZ‚Äô files.\nDisadvantage: It always selects just those files ‚Äî she can‚Äôt run it on all files (including the ‚ÄòZ‚Äô files), or on the ‚ÄòG‚Äô or ‚ÄòH‚Äô files her colleagues in Antarctica are producing, without editing the script.\nIf she wanted to be more adventurous, she could modify her script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided.\nOf course, this introduces another tradeoff between flexibility and complexity."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-variables-in-shell-scripts",
    "href": "slides/00-intro-overview.html#challenge-variables-in-shell-scripts",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Variables in Shell Scripts",
    "text": "Challenge: Variables in Shell Scripts\n\n\n\n\nChallenge\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\nbash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-variables-in-shell-scripts",
    "href": "slides/00-intro-overview.html#solution-variables-in-shell-scripts",
    "title": "Unix Shell Workshop",
    "section": "Solution: Variables in Shell Scripts",
    "text": "Solution: Variables in Shell Scripts\n\n\n\n\nSolution\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\nhead -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\ntail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks.\nAs such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-find-the-longest-file-with-a-given-extension",
    "href": "slides/00-intro-overview.html#challenge-find-the-longest-file-with-a-given-extension",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Find the Longest File With a Given Extension",
    "text": "Challenge: Find the Longest File With a Given Extension\n\n\n\n\nChallenge\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension.\nFor example:\nbash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\nbash longest.sh shell-lesson-data/exercise-data/writing txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-find-the-longest-file-with-a-given-extension",
    "href": "slides/00-intro-overview.html#solution-find-the-longest-file-with-a-given-extension",
    "title": "Unix Shell Workshop",
    "section": "Solution: Find the Longest File With a Given Extension",
    "text": "Solution: Find the Longest File With a Given Extension\n\n\n\n\nSolution\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nExplanation:\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last).\nWhen there‚Äôs more than one file, wc also outputs a final summary line, giving the total number of lines across all files.\nWe use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we‚Äôll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-script-reading-comprehension",
    "href": "slides/00-intro-overview.html#challenge-script-reading-comprehension",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Script Reading Comprehension",
    "text": "Challenge: Script Reading Comprehension\n\n\n\n\nChallenge\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created.\nExplain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\nScript 1:\necho *.*\nScript 2:\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\nScript 3:\necho $@.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-script-reading-comprehension",
    "href": "slides/00-intro-overview.html#solution-script-reading-comprehension",
    "title": "Unix Shell Workshop",
    "section": "Solution: Script Reading Comprehension",
    "text": "Solution: Script Reading Comprehension\n\n\n\n\nSolutions\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e.¬†all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-debugging-scripts",
    "href": "slides/00-intro-overview.html#challenge-debugging-scripts",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Debugging Scripts",
    "text": "Challenge: Debugging Scripts\n\n\n\n\nChallenge\n\n\nSuppose you have saved the following script in a file called do-errors.sh in Nelle‚Äôs north-pacific-gyre directory:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats.sh $datafile stats-$datafile\ndone\nWhen you run it from the north-pacific-gyre directory:\nbash do-errors.sh NENE*A.txt NENE*B.txt\nthe output is blank. To figure out why, re-run the script using the -x option:\nbash -x do-errors.sh NENE*A.txt NENE*B.txt\nWhat is the output showing you? Which line is responsible for the error?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-debugging-scripts",
    "href": "slides/00-intro-overview.html#solution-debugging-scripts",
    "title": "Unix Shell Workshop",
    "section": "Solution: Debugging Scripts",
    "text": "Solution: Debugging Scripts\n\n\n\n\nSolution\n\n\nThe -x option causes bash to run in debug mode. This prints out each command as it is run, which will help you to locate errors. In this example, we can see that echo isn‚Äôt printing anything. We have made a typo in the loop variable name, and the variable datfile doesn‚Äôt exist, hence returning an empty string."
  },
  {
    "objectID": "slides/00-intro-overview.html#why-grep",
    "href": "slides/00-intro-overview.html#why-grep",
    "title": "Unix Shell Workshop",
    "section": "Why ‚Äúgrep‚Äù?",
    "text": "Why ‚Äúgrep‚Äù?\n‚Äúgrep‚Äù is a contraction of global/regular expression/print.\nCommon sequence in early Unix text editors.\nNow a very useful command-line program."
  },
  {
    "objectID": "slides/00-intro-overview.html#what-grep-does",
    "href": "slides/00-intro-overview.html#what-grep-does",
    "title": "Unix Shell Workshop",
    "section": "What grep Does",
    "text": "What grep Does\ngrep finds and prints lines in files that match a pattern.\nWorks on any text file you can think of."
  },
  {
    "objectID": "slides/00-intro-overview.html#sample-haiku-file",
    "href": "slides/00-intro-overview.html#sample-haiku-file",
    "title": "Unix Shell Workshop",
    "section": "Sample Haiku File",
    "text": "Sample Haiku File\nThree haikus from 1998 Salon magazine poetry competition:\ncat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that."
  },
  {
    "objectID": "slides/00-intro-overview.html#finding-lines-with-not",
    "href": "slides/00-intro-overview.html#finding-lines-with-not",
    "title": "Unix Shell Workshop",
    "section": "Finding Lines with ‚Äúnot‚Äù",
    "text": "Finding Lines with ‚Äúnot‚Äù\ngrep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nPattern: not\nResult: All lines containing the word ‚Äúnot‚Äù"
  },
  {
    "objectID": "slides/00-intro-overview.html#understanding-grep-syntax",
    "href": "slides/00-intro-overview.html#understanding-grep-syntax",
    "title": "Unix Shell Workshop",
    "section": "Understanding grep Syntax",
    "text": "Understanding grep Syntax\ngrep pattern filename\n\ngrep: the command\npattern: what to search for\nfilename: which file to search in\n\nSearches line by line, outputs matching lines."
  },
  {
    "objectID": "slides/00-intro-overview.html#grep-is-case-sensitive",
    "href": "slides/00-intro-overview.html#grep-is-case-sensitive",
    "title": "Unix Shell Workshop",
    "section": "grep is Case-Sensitive",
    "text": "grep is Case-Sensitive\nSearch for ‚ÄúThe‚Äù:\ngrep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\nMatched ‚ÄúThe‚Äù at start AND ‚ÄúThe‚Äù inside ‚ÄúThesis‚Äù.\nDidn‚Äôt match lowercase ‚Äúthe‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#case-matters",
    "href": "slides/00-intro-overview.html#case-matters",
    "title": "Unix Shell Workshop",
    "section": "Case Matters",
    "text": "Case Matters\nBy default: case-sensitive\n\n‚ÄúThe‚Äù ‚â† ‚Äúthe‚Äù ‚â† ‚ÄúTHE‚Äù\nSearch pattern must match exactly"
  },
  {
    "objectID": "slides/00-intro-overview.html#searching-phrases",
    "href": "slides/00-intro-overview.html#searching-phrases",
    "title": "Unix Shell Workshop",
    "section": "Searching Phrases",
    "text": "Searching Phrases\nSearching for multiple words? Use quotes:\ngrep -w \"is not\" haiku.txt\nToday it is not working\nQuotes distinguish search term from filename.\nImportant when phrase contains spaces."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--w-word-boundaries",
    "href": "slides/00-intro-overview.html#option--w-word-boundaries",
    "title": "Unix Shell Workshop",
    "section": "Option: -w (Word Boundaries)",
    "text": "Option: -w (Word Boundaries)\nMatch whole words only\nWithout -w:\ngrep The haiku.txt\nMatches ‚ÄúThe‚Äù in ‚ÄúThe Tao‚Äù AND ‚Äúthe‚Äù in ‚ÄúThesis‚Äù.\nWith -w:\ngrep -w The haiku.txt\nThe Tao that is seen\nOnly ‚ÄúThe‚Äù as complete word (not part of ‚ÄúThesis‚Äù)."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--i-ignore-case",
    "href": "slides/00-intro-overview.html#option--i-ignore-case",
    "title": "Unix Shell Workshop",
    "section": "Option: -i (Ignore Case)",
    "text": "Option: -i (Ignore Case)\nCase-insensitive search:\ngrep -i the haiku.txt\nMatches ‚ÄúThe‚Äù, ‚Äúthe‚Äù, ‚ÄúTHE‚Äù, etc.\nThe Tao that is seen\nIs not the true Tao, until\nand the presence of absence:"
  },
  {
    "objectID": "slides/00-intro-overview.html#option--n-line-numbers",
    "href": "slides/00-intro-overview.html#option--n-line-numbers",
    "title": "Unix Shell Workshop",
    "section": "Option: -n (Line Numbers)",
    "text": "Option: -n (Line Numbers)\nShow line numbers with matches:\ngrep -n \"it\" haiku.txt\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\nLines 5, 9, 10 contain ‚Äúit‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#combining-options",
    "href": "slides/00-intro-overview.html#combining-options",
    "title": "Unix Shell Workshop",
    "section": "Combining Options",
    "text": "Combining Options\nUse multiple flags together:\ngrep -n -w \"the\" haiku.txt\n2:Is not the true Tao, until\n6:and the presence of absence:\nOr shorter form: grep -nw \"the\" haiku.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#more-option-combinations",
    "href": "slides/00-intro-overview.html#more-option-combinations",
    "title": "Unix Shell Workshop",
    "section": "More Option Combinations",
    "text": "More Option Combinations\nFind whole word ‚Äúthe‚Äù case-insensitive:\ngrep -n -w -i \"the\" haiku.txt\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:"
  },
  {
    "objectID": "slides/00-intro-overview.html#option--v-invert-match",
    "href": "slides/00-intro-overview.html#option--v-invert-match",
    "title": "Unix Shell Workshop",
    "section": "Option: -v (Invert Match)",
    "text": "Option: -v (Invert Match)\nShow lines that DON‚ÄôT match:\ngrep -n -w -v \"the\" haiku.txt\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\nAll lines without the word ‚Äúthe‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--r-recursive",
    "href": "slides/00-intro-overview.html#option--r-recursive",
    "title": "Unix Shell Workshop",
    "section": "Option: -r (Recursive)",
    "text": "Option: -r (Recursive)\nSearch through subdirectories:\ngrep -r Yesterday .\n./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n./haiku.txt:Yesterday it worked\nSearches all files under current directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#getting-help-with-grep",
    "href": "slides/00-intro-overview.html#getting-help-with-grep",
    "title": "Unix Shell Workshop",
    "section": "Getting Help with grep",
    "text": "Getting Help with grep\nSee all options:\ngrep --help\nShows usage, all flags, and examples.\nAlso: man grep for full documentation."
  },
  {
    "objectID": "slides/00-intro-overview.html#wildcards-and-regular-expressions",
    "href": "slides/00-intro-overview.html#wildcards-and-regular-expressions",
    "title": "Unix Shell Workshop",
    "section": "Wildcards and Regular Expressions",
    "text": "Wildcards and Regular Expressions\nSimple patterns vs complex patterns\nSearch pattern can include wildcards: - ^ = start of line - $ = end of line - . = any single character - * = previous character zero or more times\nTechnical name: regular expressions (regex)"
  },
  {
    "objectID": "slides/00-intro-overview.html#regex-start-of-line",
    "href": "slides/00-intro-overview.html#regex-start-of-line",
    "title": "Unix Shell Workshop",
    "section": "Regex: Start of Line (^)",
    "text": "Regex: Start of Line (^)\nFind lines starting with specific text:\ngrep -E \"^.o\" haiku.txt\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\n\n^ = start of line\n. = any one character\no = literal letter o\n\nSo: any line with ‚Äòo‚Äô in second position."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--e-extended-regex",
    "href": "slides/00-intro-overview.html#option--e-extended-regex",
    "title": "Unix Shell Workshop",
    "section": "Option: -E (Extended Regex)",
    "text": "Option: -E (Extended Regex)\nUse more powerful pattern syntax:\ngrep -E \"^The\" haiku.txt\nLines starting with ‚ÄúThe‚Äù.\ngrep -E \".aw|.ew\" haiku.txt\nLines containing ‚Äúaw‚Äù or ‚Äúew‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#text-vs-binary-files",
    "href": "slides/00-intro-overview.html#text-vs-binary-files",
    "title": "Unix Shell Workshop",
    "section": "Text vs Binary Files",
    "text": "Text vs Binary Files\nText files: human-readable - .txt, .csv, .py, .json, .sh\nBinary files: encoded/compiled - .pdf, .jpg, .png, .exe, .so\ngrep works on text, not binary!"
  },
  {
    "objectID": "slides/00-intro-overview.html#using-grep-on-binary",
    "href": "slides/00-intro-overview.html#using-grep-on-binary",
    "title": "Unix Shell Workshop",
    "section": "Using grep on Binary",
    "text": "Using grep on Binary\nBinary files cause issues:\ngrep pattern document.pdf\nMay show garbage or ‚Äúbinary file matches‚Äù.\nUse -a flag to search anyway:\ngrep -a pattern document.pdf\nResults usually useless (binary format gibberish)."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--c-count-matches",
    "href": "slides/00-intro-overview.html#option--c-count-matches",
    "title": "Unix Shell Workshop",
    "section": "Option: -c (Count Matches)",
    "text": "Option: -c (Count Matches)\nCount matching lines instead of showing them:\ngrep -c \"not\" haiku.txt\n3\nThree lines contain ‚Äúnot‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#finding-files-with-find",
    "href": "slides/00-intro-overview.html#finding-files-with-find",
    "title": "Unix Shell Workshop",
    "section": "Finding Files with find",
    "text": "Finding Files with find\nTwo types of searching: 1. Find text in files ‚Üí use grep 2. Find files themselves ‚Üí use find\nfind searches by: name, type, size, date, permissions."
  },
  {
    "objectID": "slides/00-intro-overview.html#find-basic-syntax",
    "href": "slides/00-intro-overview.html#find-basic-syntax",
    "title": "Unix Shell Workshop",
    "section": "find Basic Syntax",
    "text": "find Basic Syntax\nfind . -type f -name \"*.txt\"\n\n. = start from current directory\n-type f = search for regular files\n-name \"*.txt\" = matching this pattern\n\nShows all .txt files under current directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--type",
    "href": "slides/00-intro-overview.html#option--type",
    "title": "Unix Shell Workshop",
    "section": "Option: -type",
    "text": "Option: -type\nSearch by file type:\nfind . -type f        # Regular files\nfind . -type d        # Directories\nMost common types: f (file) and d (directory)."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--name",
    "href": "slides/00-intro-overview.html#option--name",
    "title": "Unix Shell Workshop",
    "section": "Option: -name",
    "text": "Option: -name\nSearch by filename pattern:\nfind . -name \"*.pdb\"\nAll .pdb files anywhere under current directory.\nfind . -name \"haiku*\"\nAll files starting with ‚Äúhaiku‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--size",
    "href": "slides/00-intro-overview.html#option--size",
    "title": "Unix Shell Workshop",
    "section": "Option: -size",
    "text": "Option: -size\nSearch by file size:\nfind . -type f -size +1M\nFiles larger than 1 megabyte.\nfind . -type f -size -100k\nFiles smaller than 100 kilobytes.\nUnits: k (kilobyte), M (megabyte), G (gigabyte).\n+ means ‚Äúlarger than‚Äù, - means ‚Äúsmaller than‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--mtime",
    "href": "slides/00-intro-overview.html#option--mtime",
    "title": "Unix Shell Workshop",
    "section": "Option: -mtime",
    "text": "Option: -mtime\nSearch by modification date:\nfind . -type f -mtime -7\nModified in last 7 days.\nfind . -type f -mtime -1\nModified last 24 hours.\n- means ‚Äúless than‚Äù (more recent)."
  },
  {
    "objectID": "slides/00-intro-overview.html#option--perm-permissions",
    "href": "slides/00-intro-overview.html#option--perm-permissions",
    "title": "Unix Shell Workshop",
    "section": "Option: -perm (Permissions)",
    "text": "Option: -perm (Permissions)\nFind by file permissions:\nfind . -type f -perm -u=x\nRegular files owner can execute.\nfind . -type f -perm -g=w\nFiles where group has write permission.\nfind . -type f -perm -o=r\nFiles where others can read.\n- before permission means ‚Äúbits are set‚Äù."
  },
  {
    "objectID": "slides/00-intro-overview.html#combining-find-options",
    "href": "slides/00-intro-overview.html#combining-find-options",
    "title": "Unix Shell Workshop",
    "section": "Combining find Options",
    "text": "Combining find Options\nFilter by multiple criteria:\nfind . -type f -name \"*.log\" -mtime -3\nAll .log files modified in last 3 days.\nOptions work together (AND logic)."
  },
  {
    "objectID": "slides/00-intro-overview.html#using-find-output-with-other-commands",
    "href": "slides/00-intro-overview.html#using-find-output-with-other-commands",
    "title": "Unix Shell Workshop",
    "section": "Using find Output with Other Commands",
    "text": "Using find Output with Other Commands\nProblem: Found files, now what?\nSolution: -exec to run command on each\nfind . -name \"*.pdb\" -exec grep -l \"ATOM\" {} \\;\n\n{} = the found file (placeholder)\n\\; = end of exec command\ngrep -l = show filename only if match found"
  },
  {
    "objectID": "slides/00-intro-overview.html#command-substitution",
    "href": "slides/00-intro-overview.html#command-substitution",
    "title": "Unix Shell Workshop",
    "section": "Command Substitution: $()",
    "text": "Command Substitution: $()\nUse output of one command as input to another:\necho \"Files found: $(find . -name \"*.txt\")\"\nOutput:\nFiles found: haiku.txt notes.txt\nReplace $() with command‚Äôs output."
  },
  {
    "objectID": "slides/00-intro-overview.html#practical-example",
    "href": "slides/00-intro-overview.html#practical-example",
    "title": "Unix Shell Workshop",
    "section": "Practical Example",
    "text": "Practical Example\nCount all ‚ÄúATOM‚Äù lines in all PDB files:\ngrep -c \"^ATOM\" $(find . -name \"*.pdb\")\nLists count for each file:\nfile1.pdb:1523\nfile2.pdb:2104\nfile3.pdb:1876"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-using-grep",
    "href": "slides/00-intro-overview.html#challenge-using-grep",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Using grep",
    "text": "Challenge: Using grep\n\n\n\n\nChallenge\n\n\nWhich command results in this output?\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-using-grep",
    "href": "slides/00-intro-overview.html#solution-using-grep",
    "title": "Unix Shell Workshop",
    "section": "Solution: Using grep",
    "text": "Solution: Using grep\n\n\n\n\nSolution\n\n\nAnswer: 3 (grep -w \"of\" haiku.txt)\n-w flag searches for whole words only.\nOptions 1, 2, 4 match ‚Äúof‚Äù inside other words (like ‚Äúof‚Äù in ‚Äúpresence of absence‚Äù, ‚Äúperfect‚Äù, etc.).\nOnly -w ensures ‚Äúof‚Äù stands alone."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-tracking-a-species",
    "href": "slides/00-intro-overview.html#challenge-tracking-a-species",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Tracking a Species",
    "text": "Challenge: Tracking a Species\n\n\n\n\nChallenge\n\n\nLeah has hundreds of data files on species sightings:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nShe wants a script taking: - Species name (argument 1) - Directory (argument 2)\nOutput: File &lt;species&gt;.txt with dates and counts:\n2012-11-05,22\n2012-11-06,19\n2012-11-07,16\nArrange these in correct order:\ncut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\nHint: Use man grep for recursive search, man cut for multiple fields.\nExample: shell-lesson-data/exercise-data/animal-counts/animals.csv"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-tracking-a-species",
    "href": "slides/00-intro-overview.html#solution-tracking-a-species",
    "title": "Unix Shell Workshop",
    "section": "Solution: Tracking a Species",
    "text": "Solution: Tracking a Species\n\n\n\n\nSolution\n\n\ngrep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\nHow it works:\n\ngrep -w $1 -r $2 = find species name in all files under directory\ncut -d : -f 2 = extract filename and data (remove grep‚Äôs first field)\ncut -d , -f 1,3 = extract date (field 1) and count (field 3)\n&gt; $1.txt = save to output file\n\nTwo cut commands can be swapped - same result!\nUsage example:\nbash count-species.sh bear .\nThis creates file bear.txt with all bear sightings."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-little-women",
    "href": "slides/00-intro-overview.html#challenge-little-women",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Little Women",
    "text": "Challenge: Little Women\n\n\n\n\nChallenge\n\n\nYou‚Äôve finished reading Little Women by Louisa May Alcott.\nArgument with friend: Which sister mentioned most? - Jo, Meg, Beth, or Amy?\nFile available: shell-lesson-data/exercise-data/writing/LittleWomen.txt\nUsing a for loop, tabulate mentions of each sister.\nHint: Combine grep and wc with |, or use grep options.\nMultiple solutions exist - choose for correctness, elegance, readability, and speed."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-little-women",
    "href": "slides/00-intro-overview.html#solution-little-women",
    "title": "Unix Shell Workshop",
    "section": "Solution: Little Women",
    "text": "Solution: Little Women\n\n\n\n\nSolution\n\n\nSolution 1: Using pipe with wc\nfor sis in Jo Meg Beth Amy\ndo\n    grep -ow $sis LittleWomen.txt | wc -l\ndone\nOutput shows count for each sister.\nSolution 2: Using grep -c option\nfor sis in Jo Meg Beth Amy\ndo\n    grep -ocw $sis LittleWomen.txt\ndone\nFlags explained: - -o = show matches only - -c = count them - -w = whole words only\nBoth count sister mentions correctly!"
  },
  {
    "objectID": "slides/00-intro-overview.html#listing-vs.-finding",
    "href": "slides/00-intro-overview.html#listing-vs.-finding",
    "title": "Unix Shell Workshop",
    "section": "Listing vs.¬†Finding",
    "text": "Listing vs.¬†Finding\nls and find can be made to do similar things given the right options, but under normal circumstances:\n\nls lists everything it can\nfind searches for things with certain properties and shows them"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-matching-and-subtracting",
    "href": "slides/00-intro-overview.html#challenge-matching-and-subtracting",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Matching and Subtracting",
    "text": "Challenge: Matching and Subtracting\n\n\n\n\nChallenge\n\n\nThe -v option to grep inverts pattern matching, so that only lines which do not match the pattern are printed.\nGiven that, which of the following commands will find all .dat files in creatures except unicorn.dat?\n\nfind creatures -name \"*.dat\" | grep -v unicorn\nfind creatures -name *.dat | grep -v unicorn\ngrep -v \"unicorn\" $(find creatures -name \"*.dat\")\nNone of the above\n\nOnce you have thought about your answer, you can test the commands in the shell-lesson-data/exercise-data directory."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-matching-and-subtracting",
    "href": "slides/00-intro-overview.html#solution-matching-and-subtracting",
    "title": "Unix Shell Workshop",
    "section": "Solution: Matching and Subtracting",
    "text": "Solution: Matching and Subtracting\n\n\n\n\nSolution\n\n\nOption 1 is correct: find creatures -name \"*.dat\" | grep -v unicorn\nPutting the match expression in quotes prevents the shell expanding it, so it gets passed to the find command.\nOption 2 also works in this instance because the shell tries to expand *.dat but there are no *.dat files in the current directory, so the wildcard expression gets passed to find.\nOption 3 is incorrect because it searches the contents of the files for lines which do not match ‚Äòunicorn‚Äô, rather than searching the file names."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-find-pipeline-reading-comprehension",
    "href": "slides/00-intro-overview.html#challenge-find-pipeline-reading-comprehension",
    "title": "Unix Shell Workshop",
    "section": "Challenge: find Pipeline Reading Comprehension",
    "text": "Challenge: find Pipeline Reading Comprehension\n\n\n\n\nChallenge\n\n\nWrite a short explanatory comment for the following shell script:\nwc -l $(find . -name \"*.dat\") | sort -n"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-find-pipeline-reading-comprehension",
    "href": "slides/00-intro-overview.html#solution-find-pipeline-reading-comprehension",
    "title": "Unix Shell Workshop",
    "section": "Solution: find Pipeline Reading Comprehension",
    "text": "Solution: find Pipeline Reading Comprehension\n\n\n\n\nSolution\n\n\n\nFind all files with a .dat extension recursively from the current directory\nCount the number of lines each of these files contains\nSort the output from step 2. numerically"
  },
  {
    "objectID": "slides/00-intro-overview.html#binary-files",
    "href": "slides/00-intro-overview.html#binary-files",
    "title": "Unix Shell Workshop",
    "section": "Binary Files",
    "text": "Binary Files\nWe have focused exclusively on finding patterns in text files. What if your data is stored as images, in databases, or in some other format?\nA handful of tools extend grep to handle a few non-text formats. But a more generalizable approach is to convert the data to text or extract the text-like elements from the data.\nOn one hand, it makes simple things easy to do. On the other hand, complex things are usually impossible. For example: - Easy: Write a program that extracts X and Y dimensions from image files for grep to use - Hard: Find values in a spreadsheet whose cells contained formulas\nA last option: recognize that the shell and text processing have their limits, and use another programming language.\nMany modern programming languages have borrowed ideas from the shell, and imitation is the sincerest form of praise."
  },
  {
    "objectID": "slides/00-intro-overview.html#counting-lines-the-problem",
    "href": "slides/00-intro-overview.html#counting-lines-the-problem",
    "title": "Unix Shell Workshop",
    "section": "Counting Lines: The Problem",
    "text": "Counting Lines: The Problem\nUsing wc -l:\nwc -l example.txt\nThe issue: wc counts newlines only.\nIf last line has no carriage return, result is off by one."
  },
  {
    "objectID": "slides/00-intro-overview.html#awk-a-better-solution",
    "href": "slides/00-intro-overview.html#awk-a-better-solution",
    "title": "Unix Shell Workshop",
    "section": "awk: A Better Solution",
    "text": "awk: A Better Solution\nAWK = command-line program for text processing.\n\nTakes instructions and one or more files\nExecutes on each line\nInstructions in single quotes or from file"
  },
  {
    "objectID": "slides/00-intro-overview.html#basic-awk-syntax",
    "href": "slides/00-intro-overview.html#basic-awk-syntax",
    "title": "Unix Shell Workshop",
    "section": "Basic awk Syntax",
    "text": "Basic awk Syntax\nawk '{print $0}' example.txt\nSame output as cat example.txt.\nStructure: - {} surrounds instructions - print sends output to terminal - $0 = entire current line (variable)"
  },
  {
    "objectID": "slides/00-intro-overview.html#how-awk-works",
    "href": "slides/00-intro-overview.html#how-awk-works",
    "title": "Unix Shell Workshop",
    "section": "How awk Works",
    "text": "How awk Works\nAWK automatically splits each line by spaces.\nColumns stored in variables: - $1 = first column - $2 = second column - $3 = third column - And so on‚Ä¶"
  },
  {
    "objectID": "slides/00-intro-overview.html#printing-entire-line",
    "href": "slides/00-intro-overview.html#printing-entire-line",
    "title": "Unix Shell Workshop",
    "section": "Printing Entire Line",
    "text": "Printing Entire Line\nawk '{print $0}' example.txt\n$0 means ‚Äúthe whole line‚Äù.\nSame as cat but using AWK!"
  },
  {
    "objectID": "slides/00-intro-overview.html#printing-specific-columns",
    "href": "slides/00-intro-overview.html#printing-specific-columns",
    "title": "Unix Shell Workshop",
    "section": "Printing Specific Columns",
    "text": "Printing Specific Columns\nPrint only second column:\nawk '{print $2}' example.txt\nPrint multiple columns (second and fourth):\nawk '{print $2, $4}' example.txt\nCommas add spaces between output values."
  },
  {
    "objectID": "slides/00-intro-overview.html#adding-text-to-output",
    "href": "slides/00-intro-overview.html#adding-text-to-output",
    "title": "Unix Shell Workshop",
    "section": "Adding Text to Output",
    "text": "Adding Text to Output\nPrint with custom text:\nawk '{print \"chr\", $2, $4}' example.txt\nchr value2 value4\nchr value2 value4\nchr value2 value4\nText must be in quotes."
  },
  {
    "objectID": "slides/00-intro-overview.html#the-nf-variable",
    "href": "slides/00-intro-overview.html#the-nf-variable",
    "title": "Unix Shell Workshop",
    "section": "The NF Variable",
    "text": "The NF Variable\nNF = Number of Fields (columns)\nawk '{print NF}' example.txt\nShows how many columns in each row.\nUseful when files have variable column counts."
  },
  {
    "objectID": "slides/00-intro-overview.html#example-lines-with-different-columns",
    "href": "slides/00-intro-overview.html#example-lines-with-different-columns",
    "title": "Unix Shell Workshop",
    "section": "Example: Lines with Different Columns",
    "text": "Example: Lines with Different Columns\nSome lines have 6 fields, others have 7:\nawk '{print \"This line has\", NF, \"columns. The last one contains\", $NF}' example.txt\nNF gives column count for current line."
  },
  {
    "objectID": "slides/00-intro-overview.html#the-last-column-nf",
    "href": "slides/00-intro-overview.html#the-last-column-nf",
    "title": "Unix Shell Workshop",
    "section": "The Last Column: $NF",
    "text": "The Last Column: $NF\nPrint the last column without knowing its number:\nawk '{print $NF}' example.txt\nPerfect when: - Files are huge - Lines have different column counts - You only need the final value"
  },
  {
    "objectID": "slides/00-intro-overview.html#field-separator-formats",
    "href": "slides/00-intro-overview.html#field-separator-formats",
    "title": "Unix Shell Workshop",
    "section": "Field Separator Formats",
    "text": "Field Separator Formats\n\n\n\n\n\n\nNote\n\n\nOut there we have different file formats: our data may be comma separated (CSV), tab separated (TSV), by semicolon or by any other character."
  },
  {
    "objectID": "slides/00-intro-overview.html#field-separators-default-behavior",
    "href": "slides/00-intro-overview.html#field-separators-default-behavior",
    "title": "Unix Shell Workshop",
    "section": "Field Separators: Default Behavior",
    "text": "Field Separators: Default Behavior\nBy default, AWK splits on spaces and tabs.\nFor other separators, use -F flag."
  },
  {
    "objectID": "slides/00-intro-overview.html#field-separator-comma--f",
    "href": "slides/00-intro-overview.html#field-separator-comma--f",
    "title": "Unix Shell Workshop",
    "section": "Field Separator: Comma (-F ‚Äú,‚Äù)",
    "text": "Field Separator: Comma (-F ‚Äú,‚Äù)\nFor CSV files:\nawk -F \",\" '{print $2}' example.csv\nNote: comma becomes the separator, not part of field!\nSpaces in fields are now part of the value."
  },
  {
    "objectID": "slides/00-intro-overview.html#field-separator-other-examples",
    "href": "slides/00-intro-overview.html#field-separator-other-examples",
    "title": "Unix Shell Workshop",
    "section": "Field Separator: Other Examples",
    "text": "Field Separator: Other Examples\nColon separator:\nawk -F \":\" '{print $1}' /etc/passwd\nTab separator:\nawk -F \"\\t\" '{print $2}' file.tsv"
  },
  {
    "objectID": "slides/00-intro-overview.html#pattern-action-model",
    "href": "slides/00-intro-overview.html#pattern-action-model",
    "title": "Unix Shell Workshop",
    "section": "Pattern-Action Model",
    "text": "Pattern-Action Model\nRun action only on matching lines\nawk '/PATTERN/ {action}' file\n\nPattern: regex to match\nAction: what to do if matched"
  },
  {
    "objectID": "slides/00-intro-overview.html#regex-pattern-start-of-line",
    "href": "slides/00-intro-overview.html#regex-pattern-start-of-line",
    "title": "Unix Shell Workshop",
    "section": "Regex Pattern: Start of Line (^)",
    "text": "Regex Pattern: Start of Line (^)\nPrint only lines starting with ‚ÄúATOM‚Äù:\nawk '/^ATOM/ {print $0}' example.pdb\n^ means beginning of line."
  },
  {
    "objectID": "slides/00-intro-overview.html#multiple-patterns",
    "href": "slides/00-intro-overview.html#multiple-patterns",
    "title": "Unix Shell Workshop",
    "section": "Multiple Patterns",
    "text": "Multiple Patterns\nApply different actions to different patterns:\nawk '/^ATOM/ {count1++} /^HEADER/ {count2++}' file.pdb\nOr print specific fields from matching lines:\nawk '/^ATOM/ {print $7, $8, $9}' file.pdb\nExample: Print x, y, z coordinates of atoms.\nCombined patterns printing fields and header last field (from episode example):\nawk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#the-end-block",
    "href": "slides/00-intro-overview.html#the-end-block",
    "title": "Unix Shell Workshop",
    "section": "The END Block",
    "text": "The END Block\nRuns after all lines are processed\nPerfect for printing totals and summaries.\nawk '{sum += $2} END {print sum}' file.txt\nSums values from column 2 across all lines."
  },
  {
    "objectID": "slides/00-intro-overview.html#the-nr-variable",
    "href": "slides/00-intro-overview.html#the-nr-variable",
    "title": "Unix Shell Workshop",
    "section": "The NR Variable",
    "text": "The NR Variable\nNR = Number of Records (total lines processed)\nAfter file is read, NR = line count:\nawk 'END {print NR}' example.txt\nMore robust than wc -l (handles missing final newline)."
  },
  {
    "objectID": "slides/00-intro-overview.html#comparing-line-counting-methods",
    "href": "slides/00-intro-overview.html#comparing-line-counting-methods",
    "title": "Unix Shell Workshop",
    "section": "Comparing Line Counting Methods",
    "text": "Comparing Line Counting Methods\nUsing wc:\nwc -l file.txt\nMay undercount if last line lacks newline!\nUsing AWK:\nawk 'END {print NR}' file.txt\nAlways counts correctly!"
  },
  {
    "objectID": "slides/00-intro-overview.html#counting-matching-lines",
    "href": "slides/00-intro-overview.html#counting-matching-lines",
    "title": "Unix Shell Workshop",
    "section": "Counting Matching Lines",
    "text": "Counting Matching Lines\nCount only lines starting with ‚ÄúATOM‚Äù:\nawk '/^ATOM/ {count++} END {print count}' file.pdb\n\n/^ATOM/ = match lines starting with ATOM\ncount++ = increment counter\nEND = print final count"
  },
  {
    "objectID": "slides/00-intro-overview.html#safe-counter-initialization",
    "href": "slides/00-intro-overview.html#safe-counter-initialization",
    "title": "Unix Shell Workshop",
    "section": "Safe Counter Initialization",
    "text": "Safe Counter Initialization\nAvoid errors if no lines match:\nawk '/^ATOM/ {c++} END {print c+0}' file.pdb\nAdding +0 safely prints 0 if no matches."
  },
  {
    "objectID": "slides/00-intro-overview.html#multiple-counters-in-a-pattern",
    "href": "slides/00-intro-overview.html#multiple-counters-in-a-pattern",
    "title": "Unix Shell Workshop",
    "section": "Multiple Counters in a Pattern",
    "text": "Multiple Counters in a Pattern\nCount atoms and sum their coordinates:\nawk '/^ATOM/ {count++; x += $7; y += $8; z += $9} \\\n    END {print count, x, y, z}' file.pdb\n\ncount++ = count atoms\nx += $7 = sum x coordinates\nEND = print all totals"
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-counting-and-selecting-simple",
    "href": "slides/00-intro-overview.html#challenge-counting-and-selecting-simple",
    "title": "Unix Shell Workshop",
    "section": "Challenge: Counting and Selecting (Simple)",
    "text": "Challenge: Counting and Selecting (Simple)\n\n\n\n\nChallenge\n\n\nUsing only the ideas covered above (field selection, patterns, NF, and END):\n\nWrite an awk command that prints the number of lines in example.txt.\nWrite an awk command that prints the number of lines in example.pdb that start with ATOM.\nWrite an awk command that prints the last field of each ATOM line in example.pdb (just the values, one per line).\n\nBonus (optional): Print both the count of ATOM lines and, at the end, the total number of characters across all those last fields."
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-counting-and-selecting",
    "href": "slides/00-intro-overview.html#solution-counting-and-selecting",
    "title": "Unix Shell Workshop",
    "section": "Solution: Counting and Selecting",
    "text": "Solution: Counting and Selecting\n\n\n\n\nSolution\n\n\n1) Total lines (robust):\nawk 'END {print NR}' example.txt\n2) Count lines starting with ATOM:\nawk '/^ATOM/ {c++} END {print c+0}' example.pdb\n3) Last field of each ATOM line:\nawk '/^ATOM/ {print $NF}' example.pdb\nBonus (count and accumulate character lengths of last field):\nawk '/^ATOM/ {c++; total += length($NF)} END {print \"ATOM lines:\", c+0; print \"Total chars in last field:\", total+0}' example.pdb\nExplanation: - NR gives total lines after reading the file. - /^ATOM/ pattern restricts actions to lines starting with ATOM. - $NF is the last field; length($NF) measures its size. - Counters (c, total) are printed in END."
  },
  {
    "objectID": "slides/00-intro-overview.html#built-in-functions",
    "href": "slides/00-intro-overview.html#built-in-functions",
    "title": "Unix Shell Workshop",
    "section": "Built-in Functions",
    "text": "Built-in Functions\nlength(): measure string length\nawk '{print length($1)}' file.txt\nString concatenation:\nawk '{print $1 \"_\" $2}' file.txt\nJoins fields with underscore."
  },
  {
    "objectID": "slides/00-intro-overview.html#arithmetic-and-aggregation",
    "href": "slides/00-intro-overview.html#arithmetic-and-aggregation",
    "title": "Unix Shell Workshop",
    "section": "Arithmetic and Aggregation",
    "text": "Arithmetic and Aggregation\nSum values:\nawk '{sum += $1} END {print sum}' numbers.txt\nCalculate average:\nawk '{sum += $1; count++} END {print sum/count}' numbers.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#variable-assignment",
    "href": "slides/00-intro-overview.html#variable-assignment",
    "title": "Unix Shell Workshop",
    "section": "Variable Assignment",
    "text": "Variable Assignment\nSet variables in AWK:\nawk '{x = $2 * 2; print x}' file.txt\nUse variables in calculations throughout."
  },
  {
    "objectID": "slides/00-intro-overview.html#begin-block-advanced",
    "href": "slides/00-intro-overview.html#begin-block-advanced",
    "title": "Unix Shell Workshop",
    "section": "BEGIN Block (Advanced)",
    "text": "BEGIN Block (Advanced)\nInitialize variables before processing:\nawk 'BEGIN {total=0} {total += $1} END {print total}' file.txt\n\nBEGIN runs first (before any lines)\n{total += $1} processes each line\nEND prints result"
  },
  {
    "objectID": "slides/00-intro-overview.html#awk-programs-from-files",
    "href": "slides/00-intro-overview.html#awk-programs-from-files",
    "title": "Unix Shell Workshop",
    "section": "awk Programs from Files",
    "text": "awk Programs from Files\nFor complex scripts, save to file.\nCreate script.awk:\n/^ATOM/ {\n    count++\n    x += $7\n    y += $8\n    z += $9\n}\n\nEND {\n    print \"Atoms:\", count\n    if (count &gt; 0) {\n        print \"Avg X:\", x/count\n        print \"Avg Y:\", y/count\n        print \"Avg Z:\", z/count\n    }\n}\nRun it:\nawk -f script.awk protein.pdb"
  },
  {
    "objectID": "slides/00-intro-overview.html#real-world-example-1",
    "href": "slides/00-intro-overview.html#real-world-example-1",
    "title": "Unix Shell Workshop",
    "section": "Real-World Example 1",
    "text": "Real-World Example 1\nExtract chromosome and position from BED file:\nawk -F \"\\t\" '{print $1, $2, $3}' file.bed"
  },
  {
    "objectID": "slides/00-intro-overview.html#real-world-example-2",
    "href": "slides/00-intro-overview.html#real-world-example-2",
    "title": "Unix Shell Workshop",
    "section": "Real-World Example 2",
    "text": "Real-World Example 2\nCount records by type:\nawk '{type[$1]++} END {for (t in type) print t, type[t]}' data.txt"
  },
  {
    "objectID": "slides/00-intro-overview.html#real-world-example-3",
    "href": "slides/00-intro-overview.html#real-world-example-3",
    "title": "Unix Shell Workshop",
    "section": "Real-World Example 3",
    "text": "Real-World Example 3\nFilter and sum:\nawk '$3 &gt; 1000 {sum += $3} END {print sum}' file.txt\nOnly sum values in column 3 greater than 1000."
  },
  {
    "objectID": "slides/00-intro-overview.html#key-concepts-summary",
    "href": "slides/00-intro-overview.html#key-concepts-summary",
    "title": "Unix Shell Workshop",
    "section": "Key Concepts Summary",
    "text": "Key Concepts Summary\n\n\n\nConcept\nMeaning\n\n\n\n\n$0\nEntire line\n\n\n$1, $2, ...\nColumns (fields)\n\n\nNF\nNumber of fields\n\n\n$NF\nLast field\n\n\nNR\nLine number / total lines\n\n\n-F\nField separator\n\n\n/pattern/\nRegex match\n\n\nEND\nAfter all lines"
  },
  {
    "objectID": "slides/00-intro-overview.html#youve-completed-the-unix-shell-workshop",
    "href": "slides/00-intro-overview.html#youve-completed-the-unix-shell-workshop",
    "title": "Unix Shell Workshop",
    "section": "You‚Äôve Completed the Unix Shell Workshop!",
    "text": "You‚Äôve Completed the Unix Shell Workshop!\nCongratulations! üéâ\nYou now know how to:\n‚úì Navigate files and directories\n‚úì Manage and create files\n‚úì Combine commands with pipes\n‚úì Write loops and shell scripts\n‚úì Find files and search text\n‚úì Process data with AWK"
  },
  {
    "objectID": "slides/02-filedir.html",
    "href": "slides/02-filedir.html",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I move around on my computer?\nHow can I see what files and directories I have?\nHow can I specify the location of a file or directory on my computer?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nExplain the similarities and differences between a file and a directory.\nTranslate an absolute path into a relative path and vice versa.\nConstruct absolute and relative paths that identify specific files and directories.\nUse options and arguments to change the behaviour of a shell command.\nDemonstrate the use of tab completion and explain its advantages.\n\n\n\n\n\n\nFiles = store information\nDirectories (folders) = store files or other directories\n\n\n\n\n/ (root)\n‚îú‚îÄ‚îÄ bin\n‚îú‚îÄ‚îÄ data\n‚îú‚îÄ‚îÄ Users\n‚îÇ   ‚îî‚îÄ‚îÄ nelle\n‚îú‚îÄ‚îÄ tmp\n‚îî‚îÄ‚îÄ ...\nThe root directory is / - everything else is inside it.\n\n\n\n\n\n\n\n\n\nbin = built-in programs and commands\ndata = miscellaneous data files\nUsers = user home directories (e.g., /Users/nelle)\ntmp = temporary files that don‚Äôt need long-term storage\n\n\n\n\nWhere are you right now?\n$ pwd\n/Users/nelle\nThis shows your current working directory (your current location).\n\n\n\nThe shell usually starts in your home directory:\n\nmacOS: /Users/username\nLinux: /home/username\nWindows: C:\\Users\\username\n\n\n\n\nWhat‚Äôs in your current location?\n$ ls\nApplications  Documents    Library      Music        Public\nDesktop      Downloads    Movies       Pictures\n\n\n\nUse the -F flag to mark file types:\n$ ls -F\nApplications/  Documents/    Library/      Music/        Public/\nDesktop/       Downloads/    Movies/       Pictures/\n\n\n\n\n\n\nNote\n\n\n\n\n/ after name = directory\n* after name = executable file\n@ after name = symbolic link\nNo marker = regular file\n\n\n\n\n\n\nIf your screen gets cluttered:\nclear -x\nYou can still access previous commands using ‚Üë and ‚Üì to move line-by-line, or by scrolling in your terminal after clear -x.\nFor some Bash configurations, clear may also clear the scrollbuffer\n\n\n\n\n\n\nTip\n\n\n\nShortcut: Press Ctrl+L to clear the screen.\n\n\n\n\n\nThere are two common ways to learn command options:\n\n--help (Linux and Git Bash)\n\nls --help\n\nman (Linux and macOS)\n\nman ls\nPress q to quit the manual.\n\n\n\n\n\n\nTip\n\n\n\nBuilt-in commands: If man cd fails, try help cd instead.\n\n\n\n\n\n--help option displays more information on how to use the command or program.\nls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if neither -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options, too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n  -C                         list entries by columns\n      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n                               if omitted), 'auto', or 'never'; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=&gt;@|) to entries\n...        ...        ...\n\n\n\nUse short options when typing commands into the shell to minimize keystrokes and get your task done faster:\nls -F\nUse long options in scripts for clarity:\nls --classify\n\n\n\nIf you use an option the command doesn‚Äôt support, you‚Äôll see an error:\nls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\nThis command will turn your terminal into a page with a description of the ls command and its options.\nman ls\nTo navigate through the man pages,\n\nuse ‚Üë and ‚Üì to move line-by-line\ntry b and Spacebar to skip up and down by a full page.\nuse / followed by the character or word you are searching for to find it in the manual.\nSometimes a search will result in multiple hits. If so, you can move between hits using N (for moving forward) and Shift+N (for moving backward).\npress q to quit the manual and return to the command prompt.\n\n\n\n\n\nThe third way to access help for commands is to search for the manual page on the web.\nWhen using internet search, including the phrase unix man page in your search query will help to find relevant results.\n\n\n\n\n\n\n\n\n\n\nExploring More ls Options\n\n\n\nYou can also use two options at the same time. What does the command ls do when used with the -l option? What about if you use both the -l and the -h option?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -l option makes ls use a long listing format, showing not only the file/directory names but also additional information, such as the file size and the time of its last modification. If you use both the -h option and the -l option, this makes the file size ‚Äòhuman readable‚Äô, i.e.¬†displaying something like 5.3K instead of 5369.\n\n\n\n\n\n\n\n\n\n\n\n\nListing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written.\n\n\n\n\n\n\nList contents of the Desktop directory:\n$ ls -F Desktop\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error.\n\n\n\nMove to a different location\n$ cd Desktop\n$ pwd\n/Users/nelle/Desktop\nNotice: cd produces no output, but pwd confirms you moved!\n\n\n\nGo deeper into the file structure:\n$ cd Desktop/shell-lesson-data\n$ cd exercise-data\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data/exercise-data\n\n\n\nCheck what‚Äôs here:\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/\n\n\n\nTo go to the parent directory (one level up):\n$ cd ..\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\n.. = ‚Äúthe directory containing this one‚Äù\n\n\n\nTo refer to the current directory:\n$ ls -F .\nThis lists the current directory (same as just ls -F).\n\n\n\n\n\n\nSymbol\nMeaning\n\n\n\n\n/ at start\nRoot directory\n\n\n/ between names\nPath separator\n\n\n..\nParent directory\n\n\n.\nCurrent directory\n\n\n~\nHome directory\n\n\n-\nPrevious directory\n\n\n\n\n\n\nThe special directory .. doesn‚Äôt usually show up when we run ls. To display it, add the -a option:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn addition to .. and ., you may see files like .bash_profile or .gitignore.\n\nThese files usually contain shell configuration settings\nThe prefix . prevents them from cluttering the terminal\nUse ls -a to see them\nMultiple options can be combined: ls -F -a = ls -Fa\n\n\n\n\n\n\n\n\n\n\nStarts with /\nWorks from anywhere on the computer\nExample: /Users/nelle/Desktop/shell-lesson-data\n\n\n\n\n\n\n\nDoes not start with /\nDepends on where you are now\nExample: Desktop/shell-lesson-data\n\n\n\n\n\n\nUse ~ to mean your home directory:\n$ cd ~/Desktop\n$ pwd\n/Users/nelle/Desktop\n\n\n\ncd with no arguments returns to home:\n$ cd\n$ pwd\n/Users/nelle\n\n\n\nGo to previous directory with -:\n$ cd -\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nGreat for switching between two locations!\n\n\n\nSave typing! Use Tab to auto-complete:\nType: ls nor then press Tab\n$ ls nor[TAB]\nBecomes:\n$ ls north-pacific-gyre/\nIf multiple options, press Tab twice to see all.\n\n\n\nWe have now encountered commands, options, and arguments.\nConsider this example:\nls -F /\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbsolute vs Relative Paths\n\n\n\nStarting from /Users/nelle/data, which of the following commands could Nelle use to navigate to her home directory, which is /Users/nelle?\n\ncd .\ncd /\ncd /home/nelle\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: Nelle‚Äôs home directory is /Users/nelle.\nNo: this command goes up two levels, i.e.¬†ends in /Users.\nYes: ~ stands for the user‚Äôs home directory, in this case /Users/nelle.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user‚Äôs home directory.\nYes: goes up one level.\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/.\n\n\n\n\n\n\n\n\n\n\n\n\n\nls Reading Comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly.\n\n\n\n\n\n\n\nNelle is ready to organize the files from the protein assay machine.\n\n\nCreates directory north-pacific-gyre for her data\nEach sample has a unique 10-character ID (e.g., NENE01729A)\nFiles named like NENE01729A.txt, NENE01812A.txt, etc.\nAll 1520 files in the same directory\n\n\n\n\n\nNelle can see her files:\n$ ls north-pacific-gyre/\nBut that‚Äôs a lot to type! She can use tab completion:\n\n\nType ls nor and press Tab\nShell completes to ls north-pacific-gyre/\nPressing Tab again shows multiple files\nType ls north-pacific-gyre/goo and press Tab for files starting with ‚Äúgoo‚Äù"
  },
  {
    "objectID": "slides/02-filedir.html#the-file-system",
    "href": "slides/02-filedir.html#the-file-system",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Files = store information\nDirectories (folders) = store files or other directories"
  },
  {
    "objectID": "slides/02-filedir.html#the-file-system-tree",
    "href": "slides/02-filedir.html#the-file-system-tree",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "/ (root)\n‚îú‚îÄ‚îÄ bin\n‚îú‚îÄ‚îÄ data\n‚îú‚îÄ‚îÄ Users\n‚îÇ   ‚îî‚îÄ‚îÄ nelle\n‚îú‚îÄ‚îÄ tmp\n‚îî‚îÄ‚îÄ ...\nThe root directory is / - everything else is inside it."
  },
  {
    "objectID": "slides/02-filedir.html#what-these-folders-mean",
    "href": "slides/02-filedir.html#what-these-folders-mean",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "bin = built-in programs and commands\ndata = miscellaneous data files\nUsers = user home directories (e.g., /Users/nelle)\ntmp = temporary files that don‚Äôt need long-term storage"
  },
  {
    "objectID": "slides/02-filedir.html#pwd---print-working-directory",
    "href": "slides/02-filedir.html#pwd---print-working-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Where are you right now?\n$ pwd\n/Users/nelle\nThis shows your current working directory (your current location)."
  },
  {
    "objectID": "slides/02-filedir.html#your-home-directory",
    "href": "slides/02-filedir.html#your-home-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "The shell usually starts in your home directory:\n\nmacOS: /Users/username\nLinux: /home/username\nWindows: C:\\Users\\username"
  },
  {
    "objectID": "slides/02-filedir.html#ls---list-files-and-directories",
    "href": "slides/02-filedir.html#ls---list-files-and-directories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "What‚Äôs in your current location?\n$ ls\nApplications  Documents    Library      Music        Public\nDesktop      Downloads    Movies       Pictures"
  },
  {
    "objectID": "slides/02-filedir.html#making-ls-output-clearer",
    "href": "slides/02-filedir.html#making-ls-output-clearer",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Use the -F flag to mark file types:\n$ ls -F\nApplications/  Documents/    Library/      Music/        Public/\nDesktop/       Downloads/    Movies/       Pictures/\n\n\n\n\n\n\nNote\n\n\n\n\n/ after name = directory\n* after name = executable file\n@ after name = symbolic link\nNo marker = regular file"
  },
  {
    "objectID": "slides/02-filedir.html#clearing-your-terminal",
    "href": "slides/02-filedir.html#clearing-your-terminal",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "If your screen gets cluttered:\nclear -x\nYou can still access previous commands using ‚Üë and ‚Üì to move line-by-line, or by scrolling in your terminal after clear -x.\nFor some Bash configurations, clear may also clear the scrollbuffer\n\n\n\n\n\n\nTip\n\n\n\nShortcut: Press Ctrl+L to clear the screen."
  },
  {
    "objectID": "slides/02-filedir.html#getting-help",
    "href": "slides/02-filedir.html#getting-help",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "There are two common ways to learn command options:\n\n--help (Linux and Git Bash)\n\nls --help\n\nman (Linux and macOS)\n\nman ls\nPress q to quit the manual.\n\n\n\n\n\n\nTip\n\n\n\nBuilt-in commands: If man cd fails, try help cd instead."
  },
  {
    "objectID": "slides/02-filedir.html#the---help-option",
    "href": "slides/02-filedir.html#the---help-option",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "--help option displays more information on how to use the command or program.\nls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if neither -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options, too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n  -C                         list entries by columns\n      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n                               if omitted), 'auto', or 'never'; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=&gt;@|) to entries\n...        ...        ..."
  },
  {
    "objectID": "slides/02-filedir.html#short-vs-long-options",
    "href": "slides/02-filedir.html#short-vs-long-options",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Use short options when typing commands into the shell to minimize keystrokes and get your task done faster:\nls -F\nUse long options in scripts for clarity:\nls --classify"
  },
  {
    "objectID": "slides/02-filedir.html#unsupported-command-options",
    "href": "slides/02-filedir.html#unsupported-command-options",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "If you use an option the command doesn‚Äôt support, you‚Äôll see an error:\nls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information."
  },
  {
    "objectID": "slides/02-filedir.html#the-man-command",
    "href": "slides/02-filedir.html#the-man-command",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "This command will turn your terminal into a page with a description of the ls command and its options.\nman ls\nTo navigate through the man pages,\n\nuse ‚Üë and ‚Üì to move line-by-line\ntry b and Spacebar to skip up and down by a full page.\nuse / followed by the character or word you are searching for to find it in the manual.\nSometimes a search will result in multiple hits. If so, you can move between hits using N (for moving forward) and Shift+N (for moving backward).\npress q to quit the manual and return to the command prompt."
  },
  {
    "objectID": "slides/02-filedir.html#manual-pages-on-the-web",
    "href": "slides/02-filedir.html#manual-pages-on-the-web",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "The third way to access help for commands is to search for the manual page on the web.\nWhen using internet search, including the phrase unix man page in your search query will help to find relevant results."
  },
  {
    "objectID": "slides/02-filedir.html#challenge",
    "href": "slides/02-filedir.html#challenge",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Exploring More ls Options\n\n\n\nYou can also use two options at the same time. What does the command ls do when used with the -l option? What about if you use both the -l and the -h option?"
  },
  {
    "objectID": "slides/02-filedir.html#solution",
    "href": "slides/02-filedir.html#solution",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe -l option makes ls use a long listing format, showing not only the file/directory names but also additional information, such as the file size and the time of its last modification. If you use both the -h option and the -l option, this makes the file size ‚Äòhuman readable‚Äô, i.e.¬†displaying something like 5.3K instead of 5369."
  },
  {
    "objectID": "slides/02-filedir.html#challenge-1",
    "href": "slides/02-filedir.html#challenge-1",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Listing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates."
  },
  {
    "objectID": "slides/02-filedir.html#solution-2",
    "href": "slides/02-filedir.html#solution-2",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written."
  },
  {
    "objectID": "slides/02-filedir.html#exploring-other-directories",
    "href": "slides/02-filedir.html#exploring-other-directories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "List contents of the Desktop directory:\n$ ls -F Desktop\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error."
  },
  {
    "objectID": "slides/02-filedir.html#cd---change-directory",
    "href": "slides/02-filedir.html#cd---change-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Move to a different location\n$ cd Desktop\n$ pwd\n/Users/nelle/Desktop\nNotice: cd produces no output, but pwd confirms you moved!"
  },
  {
    "objectID": "slides/02-filedir.html#moving-into-subdirectories",
    "href": "slides/02-filedir.html#moving-into-subdirectories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Go deeper into the file structure:\n$ cd Desktop/shell-lesson-data\n$ cd exercise-data\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data/exercise-data"
  },
  {
    "objectID": "slides/02-filedir.html#listing-current-directory",
    "href": "slides/02-filedir.html#listing-current-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Check what‚Äôs here:\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/"
  },
  {
    "objectID": "slides/02-filedir.html#moving-up-one-level-..",
    "href": "slides/02-filedir.html#moving-up-one-level-..",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "To go to the parent directory (one level up):\n$ cd ..\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\n.. = ‚Äúthe directory containing this one‚Äù"
  },
  {
    "objectID": "slides/02-filedir.html#current-directory-.",
    "href": "slides/02-filedir.html#current-directory-.",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "To refer to the current directory:\n$ ls -F .\nThis lists the current directory (same as just ls -F)."
  },
  {
    "objectID": "slides/02-filedir.html#special-symbols-in-paths",
    "href": "slides/02-filedir.html#special-symbols-in-paths",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Symbol\nMeaning\n\n\n\n\n/ at start\nRoot directory\n\n\n/ between names\nPath separator\n\n\n..\nParent directory\n\n\n.\nCurrent directory\n\n\n~\nHome directory\n\n\n-\nPrevious directory"
  },
  {
    "objectID": "slides/02-filedir.html#hidden-files-and-directories",
    "href": "slides/02-filedir.html#hidden-files-and-directories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "The special directory .. doesn‚Äôt usually show up when we run ls. To display it, add the -a option:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/"
  },
  {
    "objectID": "slides/02-filedir.html#other-hidden-files",
    "href": "slides/02-filedir.html#other-hidden-files",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nIn addition to .. and ., you may see files like .bash_profile or .gitignore.\n\nThese files usually contain shell configuration settings\nThe prefix . prevents them from cluttering the terminal\nUse ls -a to see them\nMultiple options can be combined: ls -F -a = ls -Fa"
  },
  {
    "objectID": "slides/02-filedir.html#two-types-of-paths",
    "href": "slides/02-filedir.html#two-types-of-paths",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Starts with /\nWorks from anywhere on the computer\nExample: /Users/nelle/Desktop/shell-lesson-data\n\n\n\n\n\n\n\nDoes not start with /\nDepends on where you are now\nExample: Desktop/shell-lesson-data"
  },
  {
    "objectID": "slides/02-filedir.html#home-directory-shortcut",
    "href": "slides/02-filedir.html#home-directory-shortcut",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Use ~ to mean your home directory:\n$ cd ~/Desktop\n$ pwd\n/Users/nelle/Desktop"
  },
  {
    "objectID": "slides/02-filedir.html#return-to-home",
    "href": "slides/02-filedir.html#return-to-home",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "cd with no arguments returns to home:\n$ cd\n$ pwd\n/Users/nelle"
  },
  {
    "objectID": "slides/02-filedir.html#navigate-back-and-forth",
    "href": "slides/02-filedir.html#navigate-back-and-forth",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Go to previous directory with -:\n$ cd -\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nGreat for switching between two locations!"
  },
  {
    "objectID": "slides/02-filedir.html#tab-completion",
    "href": "slides/02-filedir.html#tab-completion",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Save typing! Use Tab to auto-complete:\nType: ls nor then press Tab\n$ ls nor[TAB]\nBecomes:\n$ ls north-pacific-gyre/\nIf multiple options, press Tab twice to see all."
  },
  {
    "objectID": "slides/02-filedir.html#general-syntax-of-a-shell-command",
    "href": "slides/02-filedir.html#general-syntax-of-a-shell-command",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "We have now encountered commands, options, and arguments.\nConsider this example:\nls -F /"
  },
  {
    "objectID": "slides/02-filedir.html#challenge-2",
    "href": "slides/02-filedir.html#challenge-2",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Absolute vs Relative Paths\n\n\n\nStarting from /Users/nelle/data, which of the following commands could Nelle use to navigate to her home directory, which is /Users/nelle?\n\ncd .\ncd /\ncd /home/nelle\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd .."
  },
  {
    "objectID": "slides/02-filedir.html#solution-4",
    "href": "slides/02-filedir.html#solution-4",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: Nelle‚Äôs home directory is /Users/nelle.\nNo: this command goes up two levels, i.e.¬†ends in /Users.\nYes: ~ stands for the user‚Äôs home directory, in this case /Users/nelle.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user‚Äôs home directory.\nYes: goes up one level."
  },
  {
    "objectID": "slides/02-filedir.html#challenge-3",
    "href": "slides/02-filedir.html#challenge-3",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Relative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/"
  },
  {
    "objectID": "slides/02-filedir.html#solution-6",
    "href": "slides/02-filedir.html#solution-6",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/."
  },
  {
    "objectID": "slides/02-filedir.html#challenge-4",
    "href": "slides/02-filedir.html#challenge-4",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "ls Reading Comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup"
  },
  {
    "objectID": "slides/02-filedir.html#solution-8",
    "href": "slides/02-filedir.html#solution-8",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly."
  },
  {
    "objectID": "slides/02-filedir.html#nelles-pipeline-organizing-files",
    "href": "slides/02-filedir.html#nelles-pipeline-organizing-files",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Nelle is ready to organize the files from the protein assay machine.\n\n\nCreates directory north-pacific-gyre for her data\nEach sample has a unique 10-character ID (e.g., NENE01729A)\nFiles named like NENE01729A.txt, NENE01812A.txt, etc.\nAll 1520 files in the same directory"
  },
  {
    "objectID": "slides/02-filedir.html#using-tab-completion",
    "href": "slides/02-filedir.html#using-tab-completion",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Nelle can see her files:\n$ ls north-pacific-gyre/\nBut that‚Äôs a lot to type! She can use tab completion:\n\n\nType ls nor and press Tab\nShell completes to ls north-pacific-gyre/\nPressing Tab again shows multiple files\nType ls north-pacific-gyre/goo and press Tab for files starting with ‚Äúgoo‚Äù"
  },
  {
    "objectID": "slides/03-create.html",
    "href": "slides/03-create.html",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I create, copy, and delete files and directories?\nHow can I edit files?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nDelete, copy and move specified files and/or directories.\nCreate files in that hierarchy using an editor or by copying and renaming existing files.\nCreate a directory hierarchy that matches a given diagram.\n\n\n\n\n\nWe now know how to explore files and directories, but how do we create them?\n\n\nFirst, check where we are:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nMove to exercise-data/writing and see what‚Äôs there:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt\n\n\n\n\nCreate a new directory called thesis:\nmkdir thesis\nmkdir means ‚Äúmake directory‚Äù\nCheck it was created:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/\n\n\n\nSince we just created it:\nls -F thesis\nNo output means the directory is empty.\n\n\n\nThe -p option creates nested subdirectories in one operation:\nmkdir -p ../project/data ../project/results\nUse ls -FR to recursively list the new hierarchy:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nUsing the shell to create a directory is no different than using a file explorer.\nIf you open the current directory using your operating system‚Äôs graphical file explorer, the thesis directory will appear there too.\nThe shell and the file explorer are two different ways of interacting with the files, but the files and directories themselves are the same.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nTips for naming files and directories:\n\nDon‚Äôt use spaces - Use - or _ instead\n\nGood: north-pacific-gyre/\nBad: north pacific gyre/\n\nDon‚Äôt begin with - - Commands treat these as options\nStick with: lowercase letters, numbers, ., -, _\n\nMany special characters have special meanings\n\n\n\n\n\n\n\nIf you need to refer to names with spaces or special characters, surround the name in quotes:\n'my file with spaces.txt'\nBest practice:\n\n\nUse all lowercase letters\nWindows and macOS are typically case insensitive\nCan‚Äôt distinguish between thesis and Thesis in same directory\n\n\n\n\n\nChange to thesis directory and create a file with nano:\ncd thesis\nnano draft.txt\nnano is a simple text editor that runs in your terminal.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nnano is a text editor - it only works with plain character data.\nOther options:\n\nUnix: Emacs, Vim, Gedit, VSCode\nWindows: Notepad++, notepad\n\nImportant: Know where your editor searches for and saves files!\n\n\n\n\n\nType some text,\n\nThen,\n\nPress Ctrl+O to write data to disk\nPress Return to accept filename draft.txt\nPress Ctrl+X to quit and return to shell\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe Control key can be described in various ways:\n\nControl-X, Control+X\nCtrl-X, Ctrl+X\n^X\nC-x\n\nIn nano, the bottom shows: ^G Get Help ^O WriteOut\nThis means Ctrl+G for help, Ctrl+O to save.\n\n\n\n\n\nnano doesn‚Äôt leave output, but ls confirms the file exists:\nls\ndraft.txt\n\n\n\n\n\n\n\n\n\nCreating Files a Different Way\n\n\n\nTry this command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you‚Äôve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMost file names are something.extension:\n\n.txt = plain text file\n.pdf = PDF document\n.cfg = configuration file\n.png = PNG image\n\nImportant: This is just a convention! Files contain bytes. Naming whale.png as whale.mp3 doesn‚Äôt make it a sound file - it might just confuse programs trying to open it.\n\n\n\n\n\nReturn to the writing directory:\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\ndraft.txt isn‚Äôt a very informative name. Let‚Äôs rename it using mv:\nmv thesis/draft.txt thesis/quotes.txt\n\n\n\nmv [old] [new] moves or renames files\nCheck the result:\nls thesis\nquotes.txt\nWarning: mv will silently overwrite existing files with the same name!\nUse mv -i or mv --interactive to ask for confirmation before overwriting.\n\n\n\nMove quotes.txt to the current working directory:\nmv thesis/quotes.txt .\nThe . means ‚Äúcurrent directory‚Äù\nVerify thesis is now empty:\nls thesis\n$\n\n\n\nTry to list the file in thesis:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nConfirm it‚Äôs in current directory:\nls quotes.txt\nquotes.txt\n\n\n\n\n\n\n\n\n\nMoving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e.¬†the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e.¬†one above the current directory) and that . refers to the current directory.\n\n\n\n\n\n\nThe cp command copies instead of moving:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nls can take multiple paths to show multiple files at once.\n\n\n\nUse the -r (recursive) option to copy directories:\ncp -r thesis thesis_backup\nCheck both directories:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\n\n\n\nIf you omit -r when copying a directory:\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\nThe -r flag is required to copy directories.\n\n\n\n\n\n\n\n\n\nRenaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo.¬†While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‚Äògo up a level‚Äô, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\n\n\n\n\n\n\n\nReturn to the writing directory and remove quotes.txt:\nrm quotes.txt\nConfirm it‚Äôs gone:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThe Unix shell doesn‚Äôt have a trash bin!\nWhen we delete files, they are unlinked from the file system so their storage space can be recycled.\nTools for finding and recovering deleted files exist, but there‚Äôs no guarantee they‚Äôll work - the computer may recycle the file‚Äôs disk space right away.\n\n\n\n\n\n\n\n\n\n\n\nUsing rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn‚Äôt have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\n\n\n\nIf we try to remove a directory with just rm:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nrm by default only works on files, not directories.\n\n\n\nUse -r (recursive) to remove a directory and all contents:\nrm -r thesis\n‚ö†Ô∏è Warning: This works without confirmation prompts!\nGiven that files can‚Äôt be retrieved, use rm -r with great caution.\nConsider using rm -r -i for interactive confirmation.\n\n\n\nOftentimes we need to copy or move several files at once.\nThis can be done by:\n\n\nProviding a list of individual filenames\nSpecifying a naming pattern using wildcards\n\n\nWildcards are special characters that represent unknown characters or sets of characters.\n\n\n\n\n\n\n\n\n\nCopy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let‚Äôs try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory, cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n* is a wildcard - represents zero or more characters.\nIn shell-lesson-data/exercise-data/alkanes:\n\n*.pdb matches ethane.pdb, propane.pdb, and all files ending in .pdb\np*.pdb only matches pentane.pdb and propane.pdb\n\n? is also a wildcard\n\nrepresents exactly one character.\n?ethane.pdb matches methane.pdb\n*ethane.pdb matches ethane.pdb and methane.pdb\n\n\n\n\n\n\nWildcards can be used together:\n\n\n???ane.pdb = three characters followed by ane.pdb\n\nMatches: cubane.pdb, ethane.pdb, octane.pdb\n\n\n\nHow wildcards work:\nThe shell expands wildcards to create a list of matching filenames before running the command.\nException: If no files match, Bash passes the expression as-is to the command.\n\n\n\n\n\n\n\n\n\nList filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn‚Äôt match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îî‚îÄ‚îÄ all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n    ‚îî‚îÄ‚îÄ all_november_files\n        ‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n        ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\n\n\n\nOrganizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren‚Äôt very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‚Äòanalyzed‚Äô directory.\n\n\n\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nYou‚Äôre starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n‚îî‚îÄ‚îÄ data\n   ‚îú‚îÄ‚îÄ processed\n   ‚îî‚îÄ‚îÄ raw\n\n\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won‚Äôt create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‚Äòraw‚Äô and ‚Äòprocessed‚Äô directories at the same level as the ‚Äòdata‚Äô directory."
  },
  {
    "objectID": "slides/03-create.html#creating-directories",
    "href": "slides/03-create.html#creating-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "We now know how to explore files and directories, but how do we create them?\n\n\nFirst, check where we are:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nMove to exercise-data/writing and see what‚Äôs there:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt"
  },
  {
    "objectID": "slides/03-create.html#creating-a-directory",
    "href": "slides/03-create.html#creating-a-directory",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Create a new directory called thesis:\nmkdir thesis\nmkdir means ‚Äúmake directory‚Äù\nCheck it was created:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/"
  },
  {
    "objectID": "slides/03-create.html#verify-the-directory-is-empty",
    "href": "slides/03-create.html#verify-the-directory-is-empty",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Since we just created it:\nls -F thesis\nNo output means the directory is empty."
  },
  {
    "objectID": "slides/03-create.html#creating-nested-directories",
    "href": "slides/03-create.html#creating-nested-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "The -p option creates nested subdirectories in one operation:\nmkdir -p ../project/data ../project/results\nUse ls -FR to recursively list the new hierarchy:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:"
  },
  {
    "objectID": "slides/03-create.html#two-ways-of-doing-the-same-thing",
    "href": "slides/03-create.html#two-ways-of-doing-the-same-thing",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nUsing the shell to create a directory is no different than using a file explorer.\nIf you open the current directory using your operating system‚Äôs graphical file explorer, the thesis directory will appear there too.\nThe shell and the file explorer are two different ways of interacting with the files, but the files and directories themselves are the same."
  },
  {
    "objectID": "slides/03-create.html#good-names-for-files-and-directories",
    "href": "slides/03-create.html#good-names-for-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Tip\n\n\n\nTips for naming files and directories:\n\nDon‚Äôt use spaces - Use - or _ instead\n\nGood: north-pacific-gyre/\nBad: north pacific gyre/\n\nDon‚Äôt begin with - - Commands treat these as options\nStick with: lowercase letters, numbers, ., -, _\n\nMany special characters have special meanings"
  },
  {
    "objectID": "slides/03-create.html#spaces-and-special-characters",
    "href": "slides/03-create.html#spaces-and-special-characters",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "If you need to refer to names with spaces or special characters, surround the name in quotes:\n'my file with spaces.txt'\nBest practice:\n\n\nUse all lowercase letters\nWindows and macOS are typically case insensitive\nCan‚Äôt distinguish between thesis and Thesis in same directory"
  },
  {
    "objectID": "slides/03-create.html#creating-a-text-file",
    "href": "slides/03-create.html#creating-a-text-file",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Change to thesis directory and create a file with nano:\ncd thesis\nnano draft.txt\nnano is a simple text editor that runs in your terminal."
  },
  {
    "objectID": "slides/03-create.html#which-editor",
    "href": "slides/03-create.html#which-editor",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nnano is a text editor - it only works with plain character data.\nOther options:\n\nUnix: Emacs, Vim, Gedit, VSCode\nWindows: Notepad++, notepad\n\nImportant: Know where your editor searches for and saves files!"
  },
  {
    "objectID": "slides/03-create.html#using-nano",
    "href": "slides/03-create.html#using-nano",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Type some text,\n\nThen,\n\nPress Ctrl+O to write data to disk\nPress Return to accept filename draft.txt\nPress Ctrl+X to quit and return to shell"
  },
  {
    "objectID": "slides/03-create.html#control-key-notation",
    "href": "slides/03-create.html#control-key-notation",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Tip\n\n\n\nThe Control key can be described in various ways:\n\nControl-X, Control+X\nCtrl-X, Ctrl+X\n^X\nC-x\n\nIn nano, the bottom shows: ^G Get Help ^O WriteOut\nThis means Ctrl+G for help, Ctrl+O to save."
  },
  {
    "objectID": "slides/03-create.html#verify-file-creation",
    "href": "slides/03-create.html#verify-file-creation",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "nano doesn‚Äôt leave output, but ls confirms the file exists:\nls\ndraft.txt"
  },
  {
    "objectID": "slides/03-create.html#challenge",
    "href": "slides/03-create.html#challenge",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Creating Files a Different Way\n\n\n\nTry this command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?"
  },
  {
    "objectID": "slides/03-create.html#solution",
    "href": "slides/03-create.html#solution",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you‚Äôve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt"
  },
  {
    "objectID": "slides/03-create.html#whats-in-a-name",
    "href": "slides/03-create.html#whats-in-a-name",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nMost file names are something.extension:\n\n.txt = plain text file\n.pdf = PDF document\n.cfg = configuration file\n.png = PNG image\n\nImportant: This is just a convention! Files contain bytes. Naming whale.png as whale.mp3 doesn‚Äôt make it a sound file - it might just confuse programs trying to open it."
  },
  {
    "objectID": "slides/03-create.html#moving-files-and-directories",
    "href": "slides/03-create.html#moving-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Return to the writing directory:\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\ndraft.txt isn‚Äôt a very informative name. Let‚Äôs rename it using mv:\nmv thesis/draft.txt thesis/quotes.txt"
  },
  {
    "objectID": "slides/03-create.html#how-mv-works",
    "href": "slides/03-create.html#how-mv-works",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "mv [old] [new] moves or renames files\nCheck the result:\nls thesis\nquotes.txt\nWarning: mv will silently overwrite existing files with the same name!\nUse mv -i or mv --interactive to ask for confirmation before overwriting."
  },
  {
    "objectID": "slides/03-create.html#moving-to-current-directory",
    "href": "slides/03-create.html#moving-to-current-directory",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Move quotes.txt to the current working directory:\nmv thesis/quotes.txt .\nThe . means ‚Äúcurrent directory‚Äù\nVerify thesis is now empty:\nls thesis\n$"
  },
  {
    "objectID": "slides/03-create.html#confirming-file-location",
    "href": "slides/03-create.html#confirming-file-location",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Try to list the file in thesis:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nConfirm it‚Äôs in current directory:\nls quotes.txt\nquotes.txt"
  },
  {
    "objectID": "slides/03-create.html#challenge-1",
    "href": "slides/03-create.html#challenge-1",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Moving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e.¬†the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____"
  },
  {
    "objectID": "slides/03-create.html#solution-2",
    "href": "slides/03-create.html#solution-2",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e.¬†one above the current directory) and that . refers to the current directory."
  },
  {
    "objectID": "slides/03-create.html#copying-files-and-directories",
    "href": "slides/03-create.html#copying-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "The cp command copies instead of moving:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nls can take multiple paths to show multiple files at once."
  },
  {
    "objectID": "slides/03-create.html#copying-directories",
    "href": "slides/03-create.html#copying-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Use the -r (recursive) option to copy directories:\ncp -r thesis thesis_backup\nCheck both directories:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt"
  },
  {
    "objectID": "slides/03-create.html#forgetting--r-when-copying-directories",
    "href": "slides/03-create.html#forgetting--r-when-copying-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "If you omit -r when copying a directory:\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\nThe -r flag is required to copy directories."
  },
  {
    "objectID": "slides/03-create.html#challenge-2",
    "href": "slides/03-create.html#challenge-2",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Renaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt ."
  },
  {
    "objectID": "slides/03-create.html#solution-4",
    "href": "slides/03-create.html#solution-4",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo.¬†While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created."
  },
  {
    "objectID": "slides/03-create.html#challenge-3",
    "href": "slides/03-create.html#challenge-3",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Moving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat"
  },
  {
    "objectID": "slides/03-create.html#solution-6",
    "href": "slides/03-create.html#solution-6",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‚Äògo up a level‚Äô, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie"
  },
  {
    "objectID": "slides/03-create.html#removing-files-and-directories",
    "href": "slides/03-create.html#removing-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Return to the writing directory and remove quotes.txt:\nrm quotes.txt\nConfirm it‚Äôs gone:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory"
  },
  {
    "objectID": "slides/03-create.html#deleting-is-forever",
    "href": "slides/03-create.html#deleting-is-forever",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Caution\n\n\n\nThe Unix shell doesn‚Äôt have a trash bin!\nWhen we delete files, they are unlinked from the file system so their storage space can be recycled.\nTools for finding and recovering deleted files exist, but there‚Äôs no guarantee they‚Äôll work - the computer may recycle the file‚Äôs disk space right away."
  },
  {
    "objectID": "slides/03-create.html#challenge-4",
    "href": "slides/03-create.html#challenge-4",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Using rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?"
  },
  {
    "objectID": "slides/03-create.html#solution-8",
    "href": "slides/03-create.html#solution-8",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn‚Äôt have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove."
  },
  {
    "objectID": "slides/03-create.html#removing-directories",
    "href": "slides/03-create.html#removing-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "If we try to remove a directory with just rm:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nrm by default only works on files, not directories."
  },
  {
    "objectID": "slides/03-create.html#removing-directories-with--r",
    "href": "slides/03-create.html#removing-directories-with--r",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Use -r (recursive) to remove a directory and all contents:\nrm -r thesis\n‚ö†Ô∏è Warning: This works without confirmation prompts!\nGiven that files can‚Äôt be retrieved, use rm -r with great caution.\nConsider using rm -r -i for interactive confirmation."
  },
  {
    "objectID": "slides/03-create.html#operations-with-multiple-files",
    "href": "slides/03-create.html#operations-with-multiple-files",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Oftentimes we need to copy or move several files at once.\nThis can be done by:\n\n\nProviding a list of individual filenames\nSpecifying a naming pattern using wildcards\n\n\nWildcards are special characters that represent unknown characters or sets of characters."
  },
  {
    "objectID": "slides/03-create.html#challenge-5",
    "href": "slides/03-create.html#challenge-5",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Copy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let‚Äôs try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat"
  },
  {
    "objectID": "slides/03-create.html#solution-10",
    "href": "slides/03-create.html#solution-10",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory, cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory"
  },
  {
    "objectID": "slides/03-create.html#using-wildcards",
    "href": "slides/03-create.html#using-wildcards",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\n* is a wildcard - represents zero or more characters.\nIn shell-lesson-data/exercise-data/alkanes:\n\n*.pdb matches ethane.pdb, propane.pdb, and all files ending in .pdb\np*.pdb only matches pentane.pdb and propane.pdb\n\n? is also a wildcard\n\nrepresents exactly one character.\n?ethane.pdb matches methane.pdb\n*ethane.pdb matches ethane.pdb and methane.pdb"
  },
  {
    "objectID": "slides/03-create.html#wildcards-in-combination",
    "href": "slides/03-create.html#wildcards-in-combination",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Wildcards can be used together:\n\n\n???ane.pdb = three characters followed by ane.pdb\n\nMatches: cubane.pdb, ethane.pdb, octane.pdb\n\n\n\nHow wildcards work:\nThe shell expands wildcards to create a list of matching filenames before running the command.\nException: If no files match, Bash passes the expression as-is to the command."
  },
  {
    "objectID": "slides/03-create.html#challenge-6",
    "href": "slides/03-create.html#challenge-6",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "List filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*"
  },
  {
    "objectID": "slides/03-create.html#solution-12",
    "href": "slides/03-create.html#solution-12",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn‚Äôt match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane.."
  },
  {
    "objectID": "slides/03-create.html#challenge-7",
    "href": "slides/03-create.html#challenge-7",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "More on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îî‚îÄ‚îÄ all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/"
  },
  {
    "objectID": "slides/03-create.html#challenge-8",
    "href": "slides/03-create.html#challenge-8",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "More on Wildcards\n\n\n\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n    ‚îî‚îÄ‚îÄ all_november_files\n        ‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n        ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt"
  },
  {
    "objectID": "slides/03-create.html#solution-14",
    "href": "slides/03-create.html#solution-14",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/"
  },
  {
    "objectID": "slides/03-create.html#challenge-9",
    "href": "slides/03-create.html#challenge-9",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Organizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren‚Äôt very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat"
  },
  {
    "objectID": "slides/03-create.html#solution-16",
    "href": "slides/03-create.html#solution-16",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‚Äòanalyzed‚Äô directory."
  },
  {
    "objectID": "slides/03-create.html#challenge-10",
    "href": "slides/03-create.html#challenge-10",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Reproduce a folder structure\n\n\n\nYou‚Äôre starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n‚îî‚îÄ‚îÄ data\n   ‚îú‚îÄ‚îÄ processed\n   ‚îî‚îÄ‚îÄ raw"
  },
  {
    "objectID": "slides/03-create.html#challenge-11",
    "href": "slides/03-create.html#challenge-11",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Reproduce a folder structure\n\n\n\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed"
  },
  {
    "objectID": "slides/03-create.html#solution-18",
    "href": "slides/03-create.html#solution-18",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won‚Äôt create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‚Äòraw‚Äô and ‚Äòprocessed‚Äô directories at the same level as the ‚Äòdata‚Äô directory."
  },
  {
    "objectID": "slides/05-pipefilter.html",
    "href": "slides/05-pipefilter.html",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I combine existing commands to produce a desired output?\nHow can I show only part of the output?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nExplain the advantage of linking commands with pipes and filters\nCombine sequences of commands to get new output\nRedirect a command‚Äôs output to a file\nExplain what happens if a program or pipeline isn‚Äôt given input\n\n\n\n\n\nShell‚Äôs most powerful feature: Combine existing programs in new ways\nWe‚Äôll start with the directory: shell-lesson-data/exercise-data/alkanes with six molecule files:\nls\ncubane.pdb    methane.pdb    pentane.pdb\nethane.pdb    octane.pdb     propane.pdb\n.pdb = Protein Data Bank format (simple text with atom positions)\n\n\n\nwc counts: lines, words, characters (in that order)\nwc cubane.pdb\n20  156 1158 cubane.pdb\n\n\n\n* matches zero or more characters ‚Üí shell converts *.pdb to list of all .pdb files:\nwc *.pdb\n  20  156  1158  cubane.pdb\n  12   84   622  ethane.pdb\n   9   57   422  methane.pdb\n  30  246  1828  octane.pdb\n  21  165  1226  pentane.pdb\n  15  111   825  propane.pdb\n 107  819  6081  total\nNote: wc *.pdb also shows total lines in last line of output.\n\n\n\n\nwc -l ‚Üí lines only\nwc -w ‚Üí words only\nwc -m ‚Üí characters only\n\nwc -l *.pdb\n  20  cubane.pdb\n  12  ethane.pdb\n  ...\n 107  total\n\n\n\n\n\n\n\n\n\nWhy Isn‚Äôt It Doing Anything?\n\n\n\nWhat happens if a command is supposed to process a file, but we don‚Äôt give it a filename? For example, what if we type:\nwc -l\nbut don‚Äôt type *.pdb (or anything else) after the command? Since it doesn‚Äôt have any filenames, wc assumes it is supposed to process input given at the command prompt, so it just sits there and waits for us to give it some data interactively. From the outside, though, all we see is it sitting there, and the command doesn‚Äôt appear to do anything.\nIf you make this kind of mistake, you can escape out of this state by holding down the control key (Ctrl) and pressing the letter C once: Ctrl+C. Then release both keys.\n\n\n\n\n\n\nProblem - Which of these files contains the fewest lines? It‚Äôs an easy question to answer when there are only six files, but what if there were 6000?\n\n\nwc -l *.pdb &gt; lengths.txt\n\n&gt; - tells the shell to redirect the command‚Äôs output to a file instead of printing it to the screen.\nThis command prints no screen output.\nEverything that wc would have printed has gone into the file lengths.txt instead.\nIf the file doesn‚Äôt exist, the shell will create the file.\nIf the file exists already, it will be silently overwritten.\n\n\n\n\n\nls lengths.txt confirms that the file exists:\nls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt:\ncat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\nThe cat command (concatenate) prints file contents. Name comes from joining files together.\n\n\n\n\n\n\n\n\n\nOutput Page by Page\n\n\n\nWe‚Äôll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g.¬†less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit.\n\n\n\n\n\n\nNext we‚Äôll use the sort command to sort the contents of the lengths.txt file.\nBut first we‚Äôll do an exercise to learn a little about the sort command.\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -n option specifies numerical (not alphanumerical) sort.\n\n\n\n\n\n\n-n option specifies numerical (not alphabetical) sort\nsort -n lengths.txt\n   9  methane.pdb\n  12  ethane.pdb\n  15  propane.pdb\n  20  cubane.pdb\n  21  pentane.pdb\n  30  octane.pdb\n 107  total\n\n\n\nRedirect sorted output to file, then view first line:\nsort -n lengths.txt &gt; sorted-lengths.txt\nhead -n 1 sorted-lengths.txt\n   9  methane.pdb\n\n-n 1 with head tells it that we only want the first line of the file.\n-n 20 would get the first 20, and so on.\nSince sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines.\n\n\n\n\n\n\n\n\n\n\nRedirecting to the same file\n\n\n\nIt‚Äôs a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\nsort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt.\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We‚Äôll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\necho The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\necho hello &gt; testfile01.txt\nand:\necho hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn the first example with &gt;, the string ‚Äòhello‚Äô is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‚Äòhello‚Äô to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e.¬†when we run it for the second time).\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\nhead -n 3 animals.csv &gt; animals-subset.csv\ntail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nFirst 3 lines of animals.csv\nLast 2 lines of animals.csv\nFirst 3 lines AND last 2 lines of animals.csv\nSecond and third lines of animals.csv\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv\n\n\n\n\n\n\n\nIn our example of finding the file with the fewest lines, we used two intermediate files lengths.txt and sorted-lengths.txt to store output.\nThose intermediate files make it hard to follow what‚Äôs going on.\n\nWe can make it easier to understand by running sort and head together:\nsort -n lengths.txt | head -n 1\n   9  methane.pdb\n\nThe vertical bar, |, between the two commands is called a pipe.\nTells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis removes the need for intermediate file.\n\n\n\n\nWe can stack pipes. Send wc output ‚Üí sort, then ‚Üí head.\nwc -l *.pdb | sort -n\n   9  methane.pdb\n  12  ethane.pdb\n  15  propane.pdb\n  20  cubane.pdb\n  21  pentane.pdb\n  30  octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so the full pipeline becomes:\nwc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\n\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‚Äòthe log of three times x‚Äô.\nIn our case, the function is ‚Äòhead of sort of line count of *.pdb‚Äô.\n\n\n\n\nThe redirection and pipes used in the last few commands are illustrated below:\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\ncat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\ncut -d , -f 2 animals.csv\nThe cut command is used to select or ‚Äòcut out‚Äô certain sections of each line in the file for further processing while leaving the original file unchanged. By default, cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter.\nIn the example above we use the -d option to specify the comma as our delimiter character instead of Tab. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncut -d , -f 2 animals.csv | sort | uniq\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory).\n\n\n\n\n\n\nNelle has run her samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, Nelle types:\ncd north-pacific-gyre\nwc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\n\n\n\nNow she types this:\nwc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others.\n\n\n\nWhen she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning ‚Äî someone was probably in using the machine on the weekend, and she forgot to reset it.\nBefore re-running that sample, she checks to see if any files have too much data:\nwc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\n\n\n\nThose numbers look good ‚Äî but what‚Äôs that ‚ÄòZ‚Äô doing there in the third-to-last line?\nAll of her samples should be marked ‚ÄòA‚Äô or ‚ÄòB‚Äô; by convention, her lab uses ‚ÄòZ‚Äô to indicate samples with missing information.\nTo find others like it, she does this:\nls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt\n\n\n\nSure enough, when she checks the log on her laptop, there‚Äôs no depth recorded for either of those samples.\nSince it‚Äôs too late to get the information any other way, she must exclude those two files from her analysis.\nShe could delete them using rm, but there are actually some analyses she might do later where depth doesn‚Äôt matter, so instead, she‚Äôll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nSuppose you want to delete your processed data files, and only keep your raw files and processing script to save storage. The raw files end in .dat and the processed files end in .txt. Which of the following would remove all the processed data files, and only the processed data files?\n\nrm ?.txt\nrm *.txt\nrm * .txt\nrm *.*\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThis would remove .txt files with one-character names\nThis is the correct answer\nThe shell would expand * to match everything in the current directory, so the command would try to remove all matched files and an additional file called .txt\nThe shell expands *.* to match all filenames containing at least one ., including the processed files (.txt) and raw files (.dat)"
  },
  {
    "objectID": "slides/05-pipefilter.html#starting-directory",
    "href": "slides/05-pipefilter.html#starting-directory",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Shell‚Äôs most powerful feature: Combine existing programs in new ways\nWe‚Äôll start with the directory: shell-lesson-data/exercise-data/alkanes with six molecule files:\nls\ncubane.pdb    methane.pdb    pentane.pdb\nethane.pdb    octane.pdb     propane.pdb\n.pdb = Protein Data Bank format (simple text with atom positions)"
  },
  {
    "objectID": "slides/05-pipefilter.html#command-wc-word-count",
    "href": "slides/05-pipefilter.html#command-wc-word-count",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "wc counts: lines, words, characters (in that order)\nwc cubane.pdb\n20  156 1158 cubane.pdb"
  },
  {
    "objectID": "slides/05-pipefilter.html#wc-with-wildcards",
    "href": "slides/05-pipefilter.html#wc-with-wildcards",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "* matches zero or more characters ‚Üí shell converts *.pdb to list of all .pdb files:\nwc *.pdb\n  20  156  1158  cubane.pdb\n  12   84   622  ethane.pdb\n   9   57   422  methane.pdb\n  30  246  1828  octane.pdb\n  21  165  1226  pentane.pdb\n  15  111   825  propane.pdb\n 107  819  6081  total\nNote: wc *.pdb also shows total lines in last line of output."
  },
  {
    "objectID": "slides/05-pipefilter.html#wc-options",
    "href": "slides/05-pipefilter.html#wc-options",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "wc -l ‚Üí lines only\nwc -w ‚Üí words only\nwc -m ‚Üí characters only\n\nwc -l *.pdb\n  20  cubane.pdb\n  12  ethane.pdb\n  ...\n 107  total"
  },
  {
    "objectID": "slides/05-pipefilter.html#what-if-no-input",
    "href": "slides/05-pipefilter.html#what-if-no-input",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Why Isn‚Äôt It Doing Anything?\n\n\n\nWhat happens if a command is supposed to process a file, but we don‚Äôt give it a filename? For example, what if we type:\nwc -l\nbut don‚Äôt type *.pdb (or anything else) after the command? Since it doesn‚Äôt have any filenames, wc assumes it is supposed to process input given at the command prompt, so it just sits there and waits for us to give it some data interactively. From the outside, though, all we see is it sitting there, and the command doesn‚Äôt appear to do anything.\nIf you make this kind of mistake, you can escape out of this state by holding down the control key (Ctrl) and pressing the letter C once: Ctrl+C. Then release both keys."
  },
  {
    "objectID": "slides/05-pipefilter.html#capturing-output-from-commands",
    "href": "slides/05-pipefilter.html#capturing-output-from-commands",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Problem - Which of these files contains the fewest lines? It‚Äôs an easy question to answer when there are only six files, but what if there were 6000?\n\n\nwc -l *.pdb &gt; lengths.txt\n\n&gt; - tells the shell to redirect the command‚Äôs output to a file instead of printing it to the screen.\nThis command prints no screen output.\nEverything that wc would have printed has gone into the file lengths.txt instead.\nIf the file doesn‚Äôt exist, the shell will create the file.\nIf the file exists already, it will be silently overwritten."
  },
  {
    "objectID": "slides/05-pipefilter.html#confirm-file-created",
    "href": "slides/05-pipefilter.html#confirm-file-created",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "ls lengths.txt confirms that the file exists:\nls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt:\ncat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\nThe cat command (concatenate) prints file contents. Name comes from joining files together."
  },
  {
    "objectID": "slides/05-pipefilter.html#alternative-less",
    "href": "slides/05-pipefilter.html#alternative-less",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Output Page by Page\n\n\n\nWe‚Äôll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g.¬†less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit."
  },
  {
    "objectID": "slides/05-pipefilter.html#filtering-output",
    "href": "slides/05-pipefilter.html#filtering-output",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Next we‚Äôll use the sort command to sort the contents of the lengths.txt file.\nBut first we‚Äôll do an exercise to learn a little about the sort command."
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-what-does-sort--n-do",
    "href": "slides/05-pipefilter.html#challenge-what-does-sort--n-do",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect."
  },
  {
    "objectID": "slides/05-pipefilter.html#solution",
    "href": "slides/05-pipefilter.html#solution",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe -n option specifies numerical (not alphanumerical) sort."
  },
  {
    "objectID": "slides/05-pipefilter.html#sort-numerically",
    "href": "slides/05-pipefilter.html#sort-numerically",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "-n option specifies numerical (not alphabetical) sort\nsort -n lengths.txt\n   9  methane.pdb\n  12  ethane.pdb\n  15  propane.pdb\n  20  cubane.pdb\n  21  pentane.pdb\n  30  octane.pdb\n 107  total"
  },
  {
    "objectID": "slides/05-pipefilter.html#save-sorted-output",
    "href": "slides/05-pipefilter.html#save-sorted-output",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Redirect sorted output to file, then view first line:\nsort -n lengths.txt &gt; sorted-lengths.txt\nhead -n 1 sorted-lengths.txt\n   9  methane.pdb\n\n-n 1 with head tells it that we only want the first line of the file.\n-n 20 would get the first 20, and so on.\nSince sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines."
  },
  {
    "objectID": "slides/05-pipefilter.html#warning-redirecting-to-same-file",
    "href": "slides/05-pipefilter.html#warning-redirecting-to-same-file",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Redirecting to the same file\n\n\n\nIt‚Äôs a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\nsort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt."
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-what-does-mean",
    "href": "slides/05-pipefilter.html#challenge-what-does-mean",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We‚Äôll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\necho The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\necho hello &gt; testfile01.txt\nand:\necho hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files."
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-2",
    "href": "slides/05-pipefilter.html#solution-2",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\nIn the first example with &gt;, the string ‚Äòhello‚Äô is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‚Äòhello‚Äô to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e.¬†when we run it for the second time)."
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-appending-data",
    "href": "slides/05-pipefilter.html#challenge-appending-data",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\nhead -n 3 animals.csv &gt; animals-subset.csv\ntail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nFirst 3 lines of animals.csv\nLast 2 lines of animals.csv\nFirst 3 lines AND last 2 lines of animals.csv\nSecond and third lines of animals.csv"
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-4",
    "href": "slides/05-pipefilter.html#solution-4",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv"
  },
  {
    "objectID": "slides/05-pipefilter.html#passing-output-to-another-command",
    "href": "slides/05-pipefilter.html#passing-output-to-another-command",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "In our example of finding the file with the fewest lines, we used two intermediate files lengths.txt and sorted-lengths.txt to store output.\nThose intermediate files make it hard to follow what‚Äôs going on.\n\nWe can make it easier to understand by running sort and head together:\nsort -n lengths.txt | head -n 1\n   9  methane.pdb\n\nThe vertical bar, |, between the two commands is called a pipe.\nTells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis removes the need for intermediate file."
  },
  {
    "objectID": "slides/05-pipefilter.html#combining-multiple-commands",
    "href": "slides/05-pipefilter.html#combining-multiple-commands",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "We can stack pipes. Send wc output ‚Üí sort, then ‚Üí head.\nwc -l *.pdb | sort -n\n   9  methane.pdb\n  12  ethane.pdb\n  15  propane.pdb\n  20  cubane.pdb\n  21  pentane.pdb\n  30  octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so the full pipeline becomes:\nwc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\n\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‚Äòthe log of three times x‚Äô.\nIn our case, the function is ‚Äòhead of sort of line count of *.pdb‚Äô."
  },
  {
    "objectID": "slides/05-pipefilter.html#redirects-and-pipes-diagram",
    "href": "slides/05-pipefilter.html#redirects-and-pipes-diagram",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "The redirection and pipes used in the last few commands are illustrated below:"
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-piping-commands-together",
    "href": "slides/05-pipefilter.html#challenge-piping-commands-together",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3"
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-6",
    "href": "slides/05-pipefilter.html#solution-6",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!"
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-pipe-reading-comprehension",
    "href": "slides/05-pipefilter.html#challenge-pipe-reading-comprehension",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\ncat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding"
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-8",
    "href": "slides/05-pipefilter.html#solution-8",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7"
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-pipe-construction",
    "href": "slides/05-pipefilter.html#challenge-pipe-construction",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\ncut -d , -f 2 animals.csv\nThe cut command is used to select or ‚Äòcut out‚Äô certain sections of each line in the file for further processing while leaving the original file unchanged. By default, cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter.\nIn the example above we use the -d option to specify the comma as our delimiter character instead of Tab. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?"
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-10",
    "href": "slides/05-pipefilter.html#solution-10",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\ncut -d , -f 2 animals.csv | sort | uniq"
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-which-pipe",
    "href": "slides/05-pipefilter.html#challenge-which-pipe",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l"
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-12",
    "href": "slides/05-pipefilter.html#solution-12",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 4 is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory)."
  },
  {
    "objectID": "slides/05-pipefilter.html#nelles-pipeline-checking-files",
    "href": "slides/05-pipefilter.html#nelles-pipeline-checking-files",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Nelle has run her samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, Nelle types:\ncd north-pacific-gyre\nwc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ..."
  },
  {
    "objectID": "slides/05-pipefilter.html#nelle-identifies-a-problem",
    "href": "slides/05-pipefilter.html#nelle-identifies-a-problem",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Now she types this:\nwc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others."
  },
  {
    "objectID": "slides/05-pipefilter.html#checking-the-short-file",
    "href": "slides/05-pipefilter.html#checking-the-short-file",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "When she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning ‚Äî someone was probably in using the machine on the weekend, and she forgot to reset it.\nBefore re-running that sample, she checks to see if any files have too much data:\nwc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total"
  },
  {
    "objectID": "slides/05-pipefilter.html#the-mystery-z-files",
    "href": "slides/05-pipefilter.html#the-mystery-z-files",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Those numbers look good ‚Äî but what‚Äôs that ‚ÄòZ‚Äô doing there in the third-to-last line?\nAll of her samples should be marked ‚ÄòA‚Äô or ‚ÄòB‚Äô; by convention, her lab uses ‚ÄòZ‚Äô to indicate samples with missing information.\nTo find others like it, she does this:\nls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt"
  },
  {
    "objectID": "slides/05-pipefilter.html#dealing-with-missing-data",
    "href": "slides/05-pipefilter.html#dealing-with-missing-data",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Sure enough, when she checks the log on her laptop, there‚Äôs no depth recorded for either of those samples.\nSince it‚Äôs too late to get the information any other way, she must exclude those two files from her analysis.\nShe could delete them using rm, but there are actually some analyses she might do later where depth doesn‚Äôt matter, so instead, she‚Äôll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt."
  },
  {
    "objectID": "slides/05-pipefilter.html#challenge-removing-unneeded-files",
    "href": "slides/05-pipefilter.html#challenge-removing-unneeded-files",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Challenge\n\n\n\nSuppose you want to delete your processed data files, and only keep your raw files and processing script to save storage. The raw files end in .dat and the processed files end in .txt. Which of the following would remove all the processed data files, and only the processed data files?\n\nrm ?.txt\nrm *.txt\nrm * .txt\nrm *.*"
  },
  {
    "objectID": "slides/05-pipefilter.html#solution-14",
    "href": "slides/05-pipefilter.html#solution-14",
    "title": "Episode 5: Pipes and Filters",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nThis would remove .txt files with one-character names\nThis is the correct answer\nThe shell would expand * to match everything in the current directory, so the command would try to remove all matched files and an additional file called .txt\nThe shell expands *.* to match all filenames containing at least one ., including the processed files (.txt) and raw files (.dat)"
  },
  {
    "objectID": "slides/04-permissions.html",
    "href": "slides/04-permissions.html",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Questions\n\n\n\n\nHow does Linux know who can access files?\nHow can I see what permissions a file has?\nHow can I set or change the permissions on a file?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nView file permissions\nUnderstand the structure of the permissions string\nChange owners and permissions of files\nUse binary references to change permissions of files\n\n\n\n\n\nEvery file/folder has permissions defining who can access them\nThree permission categories:\n\nowner - applies only to file owner\ngroup - applies only to assigned group\nall users - applies to all other users (watch this closely!)\n\n\n\n\nFor example, if a file had the following set of permissions:\n\n\n\n\n\nuser\n\n\ngroup\n\n\nall\n\n\n\n\nread\n\n\nyes\n\n\nyes\n\n\nno\n\n\n\n\nwrite\n\n\nyes\n\n\nno\n\n\nno\n\n\n\n\nexecute\n\n\nno\n\n\nno\n\n\nno\n\n\n\n\n\n\nView file permissions with ls -l:\ncd alkanes\nls -l methane.pdb\n-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb\n\n\n\n-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb\n\nA set of ten permission flags\nLink count (which is irrelevant to this course)\nThe owner of the file\nThe associated group\nThe size of the file in bytes\nThe date that the file was last modified\nThe name of the file\n\n\n\n\nThree basic permission types:\n\nRead (r) - capability to read file contents\nWrite (w) - capability to write/modify files or directories\nExecute (x) - capability to execute files or view directory contents\n\n\n\n\n_rwxrwxrwx breakdown:\n\nFirst character - special permission flag (e.g., d = directory)\nFirst rwx - owner permissions\nSecond rwx - group permissions\nThird rwx - all users permissions\n\n\n\n\n\n\n\n\n\n\nOn users and groups\n\n\n\nWhen listing the contents of a directory you may come across files that have the same text for both the user and group. An example of this is in the output:\n-rw-r--r--  1 nelle  nelle   422B  1 Sep  2019 test.txt\nIn Linux, users will usually have a group associated with them that shares the same name that the user does. While this can seem strange, make sure that you understand the difference in the output so you know who has access to your files.\n\n\n\n\n\n\n\n\n\n\n\nCan you spot the difference here? What does it mean?\n\n\n\nLet‚Äôs take a look at some files in a different folder.\ncd Desktop/data-shell/north-pacific-gyre/2012-07-03\nls -l\n-rw-r--r-- 1 nelle  bio  4406  8 Aug  2019 NENE01729A.txt\n-rw-r--r-- 1 nelle  bio  4400  8 Aug  2019 NENE01729B.txt\n-rw-r--r-- 1 nelle  bio  4371  8 Aug  2019 NENE01736A.txt\n-rw-r--r-- 1 nelle  bio  4411  8 Aug  2019 NENE01751A.txt\n-rw-r--r-- 1 nelle  bio  4409  8 Aug  2019 NENE01751B.txt\n-rw-r--r-- 1 nelle  bio  4401  8 Aug  2019 NENE01812A.txt\n-rw-r--r-- 1 nelle  bio  4395  8 Aug  2019 NENE01843A.txt\n-rw-r--r-- 1 nelle  bio  4375  8 Aug  2019 NENE01843B.txt\n-rw-r--r-- 1 nelle  bio  4372  8 Aug  2019 NENE01971Z.txt\n-rw-r--r-- 1 nelle  bio  4381  8 Aug  2019 NENE01978A.txt\n-rw-r--r-- 1 nelle  bio  4389  8 Aug  2019 NENE01978B.txt\n-rw-r--r-- 1 nelle  bio  3517  8 Aug  2019 NENE02018B.txt\n-rw-r--r-- 1 nelle  bio  4391  8 Aug  2019 NENE02040A.txt\n-rw-r--r-- 1 nelle  bio  4367  8 Aug  2019 NENE02040B.txt\n-rw-r--r-- 1 nelle  bio  4381  8 Aug  2019 NENE02040Z.txt\n-rw-r--r-- 1 nelle  bio  4386  8 Aug  2019 NENE02043A.txt\n-rw-r--r-- 1 nelle  bio  4393  8 Aug  2019 NENE02043B.txt\n-rwxr-xr-x 1 nelle  bio   345  8 Aug  2019 goodiff\n-rwxr-xr-x 1 nelle  bio   218  8 Aug  2019 goostats\nThe data files in this folder, e.g NENE01978A.txt have a different permission set to goodiff. Can you tell why this is and explain what this might mean for the goodiff file?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe goodiff file has the execution flags set for user, group and all. Which will allow anyone to execute the file. It‚Äôs therefore likely that goodiff is a script that performs some actions. In theory you could run this script using ./goodiff\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nLets take a further look at things by looking at in the folder above this.\ncd ..\nls -l\ndrwxr-xr-x 21 nelle  bio  672  8 Aug  2019 2012-07-03\nCan you guess what the d at the beginning of the output line means?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe d indicates whether the file has any special type associated with it. In this case it‚Äôs indicating that this is a directory.\n\n\n\n\n\n\nLet‚Äôs say we want to modify who can access some of the files in the alkanes/ directory.\nWe‚Äôll assume here that we‚Äôre members of the bio group on our system.\nOn the cluster, all users must be members of cluster group to run jobs on the system. Each lab has a group associated with it, so we can use this method to share files with other members of the same lab.\n\n\n\n\n\n\n\n\n\nGroups\n\n\n\nYou‚Äôll find that if you try to assign a group to a file and the group does not exist you‚Äôll get something similar to the following output.\nchown: bio: illegal group name\nIf you‚Äôre trying to do this locally, you can list the groups you‚Äôre currently a member of using the groups command like so:\ngroups\nJust pick one of these groups to demonstrate the method shown below.\n\n\n\n\n\nChange ownership to allow compbio group to read file:\ncd Desktop/shell-lesson-data/exercise-data/alkanes\nchown nelle:compbio methane.pdb\nchown breakdown:\n\nchown - command\nnelle - user\ncompbio - group\nmethane.pdb - filename\n\n\n\n\nWhen we list the contents of the directory again, we would see the change reflected like so:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r--r-- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\n\n\n\n\nchmod = change mode = change permissions\nAllow members of the group to make changes to methane.pdb, but not others.\nTo explicitly define permissions, reference the Permission Group and Permission Types.\n\n\n\n\nThe Permission Groups used are:\n\nu - Owner\ng - Group\no - Other / All Users\na - All (Owner, Group and All Users)\n\n\n\n\nThe Permission Types that are used are:\n\nr - Read\nw - Write\nx - Execute\n\nThe potential Assignment Operators are + (plus) and - (minus); these are used to tell the system whether to add or remove the specific permissions.\n\n\n\nTo remove the ability for other users to read the methane.pdb file,\nchmod o-r methane.pdb\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r----- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\nThe r flag removed from other users section.\n\n\n\nAllow group members to write/edit:\nchmod g+w methane.pdb\nChecking this has gone through using ls -l:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-rw---- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\n\n\n\n\n\n\n\n\n\nChanging permissions for all files in a directory?\n\n\n\nSay we want to change the permissions for all the files in the alkanes/ directory, how we would do this? Let‚Äôs try and give apply what we‚Äôve just learnt to give all other users write permissions over the files.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThere‚Äôs actually a few ways we can go about this and it really depends on how we target the files to change. First, we could use the wildcards we learnt about previously to target files based on a specific pattern. In this case a simple * would suffice to pick out every file in the current folder, e.g:\nchmod o+w *\nWe could also use the recursive flag available to the chmod command to run through every file in a directory (including sub-directories) and apply a set of permissions to every file. E.g:\ncd ..\nchmod -R o+w alkanes/\nEither method works in this case, however be wary that as the -R flag works through the folder and all sub-folders, you may end up changing the permission on something you didn‚Äôt intend.\n\n\n\n\n\n\n\nAnother way to set the permission using binary references.\nThis replaces the explicitly defined permissions with binary references to these.\nWhile more complex than the previous method, we can use this to define multiple different permissions to all three permissions groups with a single command.\n\n\n\n\nAn example permission string would be chmod 764 methane.pdb, which means:\n\n\n\n\n\n\nthe owner has read, write and execute permissions\nthe group has read and write permissions\nall other users have read permissions to the file\n\n\n\n\n\n\n\n\n\n\nUsing binary references, how can you make a file executable?\n\n\n\nNow we‚Äôve seen how to use binary references to change permissions on a file. Can you change the methane.pdb file to make it executable? In this case, you can‚Äôt actually execute the file as it doesn‚Äôt contain the right data to do this, but it will teach you how to do this for other files in future, most notably scripts.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo ensure that we don‚Äôt make unintended changes to the other permissions currently assigned to the file, we need to first check what permissions it currently has\nls -l methane.pdb\n-rw-r--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nWe can see that both the read permission flags are set for groups and others. This makes creating the binary reference here easy as we only need to take the integer 4 for both these flags.\nNow we have the end of the binary reference, we need to add up the rest to give execute permissions to the file. As we already have read and write permissions as the owner of the file, we only need to add 1 to the binary reference to get 7. Therefore, the full binary reference we need to set is 744.\ncd ..\nchmod 744 methane.pdb\n-rwxr--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nHere, the first 7 assigns read, write, execute to owner, the first 4 adds read to the group, and the last 4 adds read permissions to others.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe fact that something is marked as executable doesn‚Äôt actually mean it contains a runnable program. Marking an HTML file executable won‚Äôt make it run as a program; the OS may instead open it in the associated application.\n\n\n\n\n\nLet‚Äôs run ls -a -l to get a long-form listing that includes directories that are hidden:\nls -a -l\ntotal 48\ndrwxr-xr-x 1 nelle  bio        0  8 Aug  2019 .\ndrwxr-xr-x 1 nelle  bio     8192  8 Aug  2019 ..\n-rw-r--rw- 1 nelle  bio     1158  8 Aug  2019 cubane.pdb\n-rw-r--rw- 1 nelle  bio      622  8 Aug  2019 ethane.pdb\n-rwxr--r-- 1 nelle  compbio  422  8 Aug  2019 methane.pdb\n-rw-r--rw- 1 nelle  bio     1828  8 Aug  2019 octane.pdb\n-rw-r--rw- 1 nelle  bio     1226  8 Aug  2019 pentane.pdb\n-rw-r--rw- 1 nelle  bio      825  8 Aug  2019 propane.pdb\n\nThe permissions for . and .. (this directory and its parent) start with a d.\n‚Äòx‚Äô means that ‚Äúexecute‚Äù is turned on.\nA directory isn‚Äôt a program‚Äîhow can we ‚Äúrun‚Äù it?\nIt gives someone the right to traverse the directory, but not to look at its contents.\n\n\n\n\nNelle‚Äôs home directory has three subdirectories called venus, mars, and pluto:\n\n\n\n\n\nEach of these has a subdirectory in turn called notes, and those sub-subdirectories contain various files.\n\n\n\n\n\n\n\n\nIf a user‚Äôs permissions on venus are ‚Äòr-x‚Äô, then if she tries to see the contents of venus and venus/notes using ls, the computer lets her see both.\n\n\n\n\n\n\n\n\nIf her permissions on mars are just ‚Äòr‚Äì‚Äô, then she is allowed to read the contents of both mars and mars/notes.\n\n\n\n\n\n\n\n\nBut if her permissions on pluto are only ‚Äò‚Äìx‚Äô, she cannot see what‚Äôs in the pluto directory: ls pluto will tell her she doesn‚Äôt have permission to view its contents.\nIf she tries to look in pluto/notes, though, the computer will let her do that. She‚Äôs allowed to go through pluto, but not to look at what‚Äôs there."
  },
  {
    "objectID": "slides/04-permissions.html#file-permissions",
    "href": "slides/04-permissions.html#file-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Every file/folder has permissions defining who can access them\nThree permission categories:\n\nowner - applies only to file owner\ngroup - applies only to assigned group\nall users - applies to all other users (watch this closely!)"
  },
  {
    "objectID": "slides/04-permissions.html#permission-example",
    "href": "slides/04-permissions.html#permission-example",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "For example, if a file had the following set of permissions:\n\n\n\n\n\nuser\n\n\ngroup\n\n\nall\n\n\n\n\nread\n\n\nyes\n\n\nyes\n\n\nno\n\n\n\n\nwrite\n\n\nyes\n\n\nno\n\n\nno\n\n\n\n\nexecute\n\n\nno\n\n\nno\n\n\nno"
  },
  {
    "objectID": "slides/04-permissions.html#viewing-permissions",
    "href": "slides/04-permissions.html#viewing-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "View file permissions with ls -l:\ncd alkanes\nls -l methane.pdb\n-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb"
  },
  {
    "objectID": "slides/04-permissions.html#understanding-ls--l-output",
    "href": "slides/04-permissions.html#understanding-ls--l-output",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb\n\nA set of ten permission flags\nLink count (which is irrelevant to this course)\nThe owner of the file\nThe associated group\nThe size of the file in bytes\nThe date that the file was last modified\nThe name of the file"
  },
  {
    "objectID": "slides/04-permissions.html#permission-flags",
    "href": "slides/04-permissions.html#permission-flags",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Three basic permission types:\n\nRead (r) - capability to read file contents\nWrite (w) - capability to write/modify files or directories\nExecute (x) - capability to execute files or view directory contents"
  },
  {
    "objectID": "slides/04-permissions.html#permission-string-structure",
    "href": "slides/04-permissions.html#permission-string-structure",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "_rwxrwxrwx breakdown:\n\nFirst character - special permission flag (e.g., d = directory)\nFirst rwx - owner permissions\nSecond rwx - group permissions\nThird rwx - all users permissions"
  },
  {
    "objectID": "slides/04-permissions.html#users-and-groups",
    "href": "slides/04-permissions.html#users-and-groups",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "On users and groups\n\n\n\nWhen listing the contents of a directory you may come across files that have the same text for both the user and group. An example of this is in the output:\n-rw-r--r--  1 nelle  nelle   422B  1 Sep  2019 test.txt\nIn Linux, users will usually have a group associated with them that shares the same name that the user does. While this can seem strange, make sure that you understand the difference in the output so you know who has access to your files."
  },
  {
    "objectID": "slides/04-permissions.html#challenge",
    "href": "slides/04-permissions.html#challenge",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Can you spot the difference here? What does it mean?\n\n\n\nLet‚Äôs take a look at some files in a different folder.\ncd Desktop/data-shell/north-pacific-gyre/2012-07-03\nls -l\n-rw-r--r-- 1 nelle  bio  4406  8 Aug  2019 NENE01729A.txt\n-rw-r--r-- 1 nelle  bio  4400  8 Aug  2019 NENE01729B.txt\n-rw-r--r-- 1 nelle  bio  4371  8 Aug  2019 NENE01736A.txt\n-rw-r--r-- 1 nelle  bio  4411  8 Aug  2019 NENE01751A.txt\n-rw-r--r-- 1 nelle  bio  4409  8 Aug  2019 NENE01751B.txt\n-rw-r--r-- 1 nelle  bio  4401  8 Aug  2019 NENE01812A.txt\n-rw-r--r-- 1 nelle  bio  4395  8 Aug  2019 NENE01843A.txt\n-rw-r--r-- 1 nelle  bio  4375  8 Aug  2019 NENE01843B.txt\n-rw-r--r-- 1 nelle  bio  4372  8 Aug  2019 NENE01971Z.txt\n-rw-r--r-- 1 nelle  bio  4381  8 Aug  2019 NENE01978A.txt\n-rw-r--r-- 1 nelle  bio  4389  8 Aug  2019 NENE01978B.txt\n-rw-r--r-- 1 nelle  bio  3517  8 Aug  2019 NENE02018B.txt\n-rw-r--r-- 1 nelle  bio  4391  8 Aug  2019 NENE02040A.txt\n-rw-r--r-- 1 nelle  bio  4367  8 Aug  2019 NENE02040B.txt\n-rw-r--r-- 1 nelle  bio  4381  8 Aug  2019 NENE02040Z.txt\n-rw-r--r-- 1 nelle  bio  4386  8 Aug  2019 NENE02043A.txt\n-rw-r--r-- 1 nelle  bio  4393  8 Aug  2019 NENE02043B.txt\n-rwxr-xr-x 1 nelle  bio   345  8 Aug  2019 goodiff\n-rwxr-xr-x 1 nelle  bio   218  8 Aug  2019 goostats\nThe data files in this folder, e.g NENE01978A.txt have a different permission set to goodiff. Can you tell why this is and explain what this might mean for the goodiff file?"
  },
  {
    "objectID": "slides/04-permissions.html#solution",
    "href": "slides/04-permissions.html#solution",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe goodiff file has the execution flags set for user, group and all. Which will allow anyone to execute the file. It‚Äôs therefore likely that goodiff is a script that performs some actions. In theory you could run this script using ./goodiff"
  },
  {
    "objectID": "slides/04-permissions.html#challenge-1",
    "href": "slides/04-permissions.html#challenge-1",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Challenge\n\n\n\nLets take a further look at things by looking at in the folder above this.\ncd ..\nls -l\ndrwxr-xr-x 21 nelle  bio  672  8 Aug  2019 2012-07-03\nCan you guess what the d at the beginning of the output line means?"
  },
  {
    "objectID": "slides/04-permissions.html#solution-2",
    "href": "slides/04-permissions.html#solution-2",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe d indicates whether the file has any special type associated with it. In this case it‚Äôs indicating that this is a directory."
  },
  {
    "objectID": "slides/04-permissions.html#modifying-permissions",
    "href": "slides/04-permissions.html#modifying-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Let‚Äôs say we want to modify who can access some of the files in the alkanes/ directory.\nWe‚Äôll assume here that we‚Äôre members of the bio group on our system.\nOn the cluster, all users must be members of cluster group to run jobs on the system. Each lab has a group associated with it, so we can use this method to share files with other members of the same lab."
  },
  {
    "objectID": "slides/04-permissions.html#groups-note",
    "href": "slides/04-permissions.html#groups-note",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Groups\n\n\n\nYou‚Äôll find that if you try to assign a group to a file and the group does not exist you‚Äôll get something similar to the following output.\nchown: bio: illegal group name\nIf you‚Äôre trying to do this locally, you can list the groups you‚Äôre currently a member of using the groups command like so:\ngroups\nJust pick one of these groups to demonstrate the method shown below."
  },
  {
    "objectID": "slides/04-permissions.html#using-chown",
    "href": "slides/04-permissions.html#using-chown",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Change ownership to allow compbio group to read file:\ncd Desktop/shell-lesson-data/exercise-data/alkanes\nchown nelle:compbio methane.pdb\nchown breakdown:\n\nchown - command\nnelle - user\ncompbio - group\nmethane.pdb - filename"
  },
  {
    "objectID": "slides/04-permissions.html#after-chown",
    "href": "slides/04-permissions.html#after-chown",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "When we list the contents of the directory again, we would see the change reflected like so:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r--r-- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb"
  },
  {
    "objectID": "slides/04-permissions.html#changing-permissions-with-chmod",
    "href": "slides/04-permissions.html#changing-permissions-with-chmod",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "chmod = change mode = change permissions\nAllow members of the group to make changes to methane.pdb, but not others.\nTo explicitly define permissions, reference the Permission Group and Permission Types."
  },
  {
    "objectID": "slides/04-permissions.html#permission-groups",
    "href": "slides/04-permissions.html#permission-groups",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "The Permission Groups used are:\n\nu - Owner\ng - Group\no - Other / All Users\na - All (Owner, Group and All Users)"
  },
  {
    "objectID": "slides/04-permissions.html#permission-types",
    "href": "slides/04-permissions.html#permission-types",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "The Permission Types that are used are:\n\nr - Read\nw - Write\nx - Execute\n\nThe potential Assignment Operators are + (plus) and - (minus); these are used to tell the system whether to add or remove the specific permissions."
  },
  {
    "objectID": "slides/04-permissions.html#chmod---remove---other-read",
    "href": "slides/04-permissions.html#chmod---remove---other-read",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "To remove the ability for other users to read the methane.pdb file,\nchmod o-r methane.pdb\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r----- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\nThe r flag removed from other users section."
  },
  {
    "objectID": "slides/04-permissions.html#chmod---add-group-write",
    "href": "slides/04-permissions.html#chmod---add-group-write",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Allow group members to write/edit:\nchmod g+w methane.pdb\nChecking this has gone through using ls -l:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-rw---- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb"
  },
  {
    "objectID": "slides/04-permissions.html#challenge-3",
    "href": "slides/04-permissions.html#challenge-3",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Changing permissions for all files in a directory?\n\n\n\nSay we want to change the permissions for all the files in the alkanes/ directory, how we would do this? Let‚Äôs try and give apply what we‚Äôve just learnt to give all other users write permissions over the files."
  },
  {
    "objectID": "slides/04-permissions.html#solution-4",
    "href": "slides/04-permissions.html#solution-4",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThere‚Äôs actually a few ways we can go about this and it really depends on how we target the files to change. First, we could use the wildcards we learnt about previously to target files based on a specific pattern. In this case a simple * would suffice to pick out every file in the current folder, e.g:\nchmod o+w *\nWe could also use the recursive flag available to the chmod command to run through every file in a directory (including sub-directories) and apply a set of permissions to every file. E.g:\ncd ..\nchmod -R o+w alkanes/\nEither method works in this case, however be wary that as the -R flag works through the folder and all sub-folders, you may end up changing the permission on something you didn‚Äôt intend."
  },
  {
    "objectID": "slides/04-permissions.html#using-binary-references-to-set-permissions",
    "href": "slides/04-permissions.html#using-binary-references-to-set-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Another way to set the permission using binary references.\nThis replaces the explicitly defined permissions with binary references to these.\nWhile more complex than the previous method, we can use this to define multiple different permissions to all three permissions groups with a single command."
  },
  {
    "objectID": "slides/04-permissions.html#binary-references-example",
    "href": "slides/04-permissions.html#binary-references-example",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "An example permission string would be chmod 764 methane.pdb, which means:\n\n\n\n\n\n\nthe owner has read, write and execute permissions\nthe group has read and write permissions\nall other users have read permissions to the file"
  },
  {
    "objectID": "slides/04-permissions.html#challenge-4",
    "href": "slides/04-permissions.html#challenge-4",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Using binary references, how can you make a file executable?\n\n\n\nNow we‚Äôve seen how to use binary references to change permissions on a file. Can you change the methane.pdb file to make it executable? In this case, you can‚Äôt actually execute the file as it doesn‚Äôt contain the right data to do this, but it will teach you how to do this for other files in future, most notably scripts."
  },
  {
    "objectID": "slides/04-permissions.html#solution-6",
    "href": "slides/04-permissions.html#solution-6",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Solution\n\n\n\n\n\nTo ensure that we don‚Äôt make unintended changes to the other permissions currently assigned to the file, we need to first check what permissions it currently has\nls -l methane.pdb\n-rw-r--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nWe can see that both the read permission flags are set for groups and others. This makes creating the binary reference here easy as we only need to take the integer 4 for both these flags.\nNow we have the end of the binary reference, we need to add up the rest to give execute permissions to the file. As we already have read and write permissions as the owner of the file, we only need to add 1 to the binary reference to get 7. Therefore, the full binary reference we need to set is 744.\ncd ..\nchmod 744 methane.pdb\n-rwxr--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nHere, the first 7 assigns read, write, execute to owner, the first 4 adds read to the group, and the last 4 adds read permissions to others."
  },
  {
    "objectID": "slides/04-permissions.html#necessary-but-not-sufficient",
    "href": "slides/04-permissions.html#necessary-but-not-sufficient",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Note\n\n\n\nThe fact that something is marked as executable doesn‚Äôt actually mean it contains a runnable program. Marking an HTML file executable won‚Äôt make it run as a program; the OS may instead open it in the associated application."
  },
  {
    "objectID": "slides/04-permissions.html#directory-permissions",
    "href": "slides/04-permissions.html#directory-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Let‚Äôs run ls -a -l to get a long-form listing that includes directories that are hidden:\nls -a -l\ntotal 48\ndrwxr-xr-x 1 nelle  bio        0  8 Aug  2019 .\ndrwxr-xr-x 1 nelle  bio     8192  8 Aug  2019 ..\n-rw-r--rw- 1 nelle  bio     1158  8 Aug  2019 cubane.pdb\n-rw-r--rw- 1 nelle  bio      622  8 Aug  2019 ethane.pdb\n-rwxr--r-- 1 nelle  compbio  422  8 Aug  2019 methane.pdb\n-rw-r--rw- 1 nelle  bio     1828  8 Aug  2019 octane.pdb\n-rw-r--rw- 1 nelle  bio     1226  8 Aug  2019 pentane.pdb\n-rw-r--rw- 1 nelle  bio      825  8 Aug  2019 propane.pdb\n\nThe permissions for . and .. (this directory and its parent) start with a d.\n‚Äòx‚Äô means that ‚Äúexecute‚Äù is turned on.\nA directory isn‚Äôt a program‚Äîhow can we ‚Äúrun‚Äù it?\nIt gives someone the right to traverse the directory, but not to look at its contents."
  },
  {
    "objectID": "slides/04-permissions.html#nelles-directory-example",
    "href": "slides/04-permissions.html#nelles-directory-example",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Nelle‚Äôs home directory has three subdirectories called venus, mars, and pluto:\n\n\n\n\n\nEach of these has a subdirectory in turn called notes, and those sub-subdirectories contain various files."
  },
  {
    "objectID": "slides/04-permissions.html#scenario-1-r-x-on-venus",
    "href": "slides/04-permissions.html#scenario-1-r-x-on-venus",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "If a user‚Äôs permissions on venus are ‚Äòr-x‚Äô, then if she tries to see the contents of venus and venus/notes using ls, the computer lets her see both."
  },
  {
    "objectID": "slides/04-permissions.html#scenario-2-r-on-mars",
    "href": "slides/04-permissions.html#scenario-2-r-on-mars",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "If her permissions on mars are just ‚Äòr‚Äì‚Äô, then she is allowed to read the contents of both mars and mars/notes."
  },
  {
    "objectID": "slides/04-permissions.html#scenario-3-x-on-pluto",
    "href": "slides/04-permissions.html#scenario-3-x-on-pluto",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "But if her permissions on pluto are only ‚Äò‚Äìx‚Äô, she cannot see what‚Äôs in the pluto directory: ls pluto will tell her she doesn‚Äôt have permission to view its contents.\nIf she tries to look in pluto/notes, though, the computer will let her do that. She‚Äôs allowed to go through pluto, but not to look at what‚Äôs there."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Unix Shell",
    "section": "",
    "text": "This workshop introduces the Unix shell (Bash) as a practical tool for working with files, automating repetitive tasks, and building reproducible workflows. You will learn how the shell relates to your operating system and applications, and how to efficiently navigate directories, inspect and manipulate files, chain commands with pipes and filters, iterate with loops, and write simple shell scripts. By the end, you‚Äôll be comfortable using core command-line patterns to explore data, transform text, and compose small, simple pipelines."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "The Unix Shell",
    "section": "",
    "text": "This workshop introduces the Unix shell (Bash) as a practical tool for working with files, automating repetitive tasks, and building reproducible workflows. You will learn how the shell relates to your operating system and applications, and how to efficiently navigate directories, inspect and manipulate files, chain commands with pipes and filters, iterate with loops, and write simple shell scripts. By the end, you‚Äôll be comfortable using core command-line patterns to explore data, transform text, and compose small, simple pipelines."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "The Unix Shell",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this workshop, you will know how to:\n\nUnderstand what the shell is and when to use it.\nMove around folders and find your way to files.\nMake, copy, rename, and delete files and folders.\nJoin simple commands together to get the result you want.\nRepeat actions on many files without retyping.\nSave steps in small scripts so you can reuse them.\nSearch for files and for text inside files quickly."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "The Unix Shell",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis lesson guides you through the basics of file systems and the shell. If you have stored files on a computer at all and recognize the word ‚Äúfile‚Äù and either ‚Äúdirectory‚Äù or ‚Äúfolder‚Äù (two common words for the same thing), you‚Äôre ready for this lesson.\nIf you‚Äôre already comfortable manipulating files and directories, searching for files with grep and find, and writing simple loops and scripts, you probably want to skip this workshop.\n\nDownload files\nYou need to download some files to follow this lesson.\n\nDownload shell-lesson-data.zip and move the file to your Desktop.\nUnzip/extract the file. You should end up with a new folder called shell-lesson-data on your Desktop.\n\n\n\nInstall software\nIf you do not already have the shell software installed, you will need to download and install it.\n\nFor macOSFor LinuxFor Windows\n\n\nFor a Mac computer running macOS Mojave or earlier releases, the default Unix Shell is Bash. For a Mac computer running macOS Catalina or later releases, the default Unix Shell is Zsh. Your default shell is available via the Terminal program within your Utilities folder.\n\nTo open Terminal, try one or both of the following:\n\nIn Finder, select the Go menu, then select Utilities. Locate Terminal in the Utilities folder and open it.\nUse the Mac ‚ÄòSpotlight‚Äô computer search function. Search for: Terminal and press Return.\n\nTo check if your machine is set up to use something other than Bash, type echo $SHELL in your terminal window.\nIf your machine is set up to use something other than Bash, you can run it by opening a terminal and typing bash.\n\n\n\n\nThe default Unix Shell for Linux operating systems is usually Bash. On most versions of Linux, it is accessible by running the Gnome Terminal or KDE Konsole or xterm, which can be found via the applications menu or the search bar.\nIf your machine is set up to use something other than Bash, you can run it by opening a terminal and typing bash.\n\n\n\nComputers with Windows operating systems do not automatically have a Unix Shell program installed. In this lesson, we encourage you to use an emulator included in Git for Windows which gives you access to both Bash shell commands and Git or Visual Studio Code which gives you access to Bash shell commands.\n\nOption 1: Git for Windows\n\nDownload and install Git for Windows from gitforwindows.org.\nDuring installation, ensure that the option to use Git from the Windows Command Prompt is selected.\nAfter installation, open Git Bash from the Start menu.\n\n\n\nOption 2: Visual Studio Code\n\nDownload and install Visual Studio Code from code.visualstudio.com.\nInstall the ‚ÄúRemote - WSL‚Äù extension from the Extensions Marketplace.\nOpen a new terminal in VS Code, and select the Bash shell.\n\nNote for Peter Mac Windows Users:  If you need to install new software on Peter Mac Windows computers, you will need to Create a Snow Ticket for installation."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "The Unix Shell",
    "section": "Course Outline",
    "text": "Course Outline\n\n\n\n\nTime\n\n\nLesson\n\n\nQuestions\n\n\n\n\n5\n\n\nIntroducing the Shell\n\n\nWhat is a command shell and why would I use one?\n\n\n\n\n30\n\n\nNavigating Files and Directories\n\n\nHow can I move around on my computer?How can I see what files and directories I have?How can I specify the location of a file or directory on my computer?\n\n\n\n\n30\n\n\nWorking With Files and Directories\n\n\nHow can I create, copy, and delete files and directories?How can I edit files?\n\n\n\n\n10\n\n\nFile Permissions\n\n\nHow do file and directory permissions work?\n\n\n\n\n25\n\n\nPipes and Filters\n\n\nHow can I combine existing commands to produce a desired output?How can I show only part of the output?\n\n\n\n\n40\n\n\nLoops\n\n\nHow can I perform the same actions on many different files?\n\n\n\n\n30\n\n\nShell Scripts\n\n\nHow can I save and re-use commands?\n\n\n\n\n25\n\n\nFinding Things\n\n\nHow can I find files?How can I find things in files?\n\n\n\n\n20\n\n\nAWK for Text Processing\n\n\nHow do I print specific columns from a text table?How can I use patterns to select only certain lines in a file?How do I count lines or matched lines in a file?"
  },
  {
    "objectID": "index.html#credits-and-acknowledgement",
    "href": "index.html#credits-and-acknowledgement",
    "title": "The Unix Shell",
    "section": "Credits and Acknowledgement",
    "text": "Credits and Acknowledgement\nThese content were adapted from the following course materials:\n\nThe Carpentries Incubator - The Unix Shell"
  },
  {
    "objectID": "episodes/02-filedir.html",
    "href": "episodes/02-filedir.html",
    "title": "Navigating Files and Directories",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 10\nQuestions:\n\nHow can I move around on my computer?\nHow can I see what files and directories I have?\nHow can I specify the location of a file or directory on my computer?\n\nObjectives:\n\nExplain the similarities and differences between a file and a directory.\nTranslate an absolute path into a relative path and vice versa.\nConstruct absolute and relative paths that identify specific files and directories.\nUse options and arguments to change the behaviour of a shell command.\nDemonstrate the use of tab completion and explain its advantages.\nThe part of the operating system responsible for managing files and directories is called the file system. It organizes our data into files, which hold information, and directories (also called ‚Äòfolders‚Äô), which hold files or other directories.\nSeveral commands are frequently used to create, inspect, rename, and delete files and directories. To start exploring them, we‚Äôll go to our open shell window.\nFirst, let‚Äôs find out where we are by running a command called pwd (which stands for ‚Äòprint working directory‚Äô). Directories are like places ‚Äî at any time while we are using the shell, we are in exactly one place called our current working directory. Commands mostly read and write files in the current working directory, i.e.¬†‚Äòhere‚Äô, so knowing where you are before running a command is important. pwd shows you where you are:\nHere, the computer‚Äôs response is /Users/nelle, which is Nelle‚Äôs home directory:\nTo understand what a ‚Äòhome directory‚Äô is, let‚Äôs have a look at how the file system as a whole is organized. For the sake of this example, we‚Äôll be illustrating the filesystem on our scientist Nelle‚Äôs computer. After this illustration, you‚Äôll be learning commands to explore your own filesystem, which will be constructed in a similar way, but not be exactly identical.\nOn Nelle‚Äôs computer, the filesystem looks like this:\nThe filesystem looks like an upside down tree. The topmost directory is the root directory that holds everything else. We refer to it using a slash character, /, on its own; this character is the leading slash in /Users/nelle.\nInside that directory are several other directories: bin (which is where some built-in programs are stored), data (for miscellaneous data files), Users (where users‚Äô personal directories are located), tmp (for temporary files that don‚Äôt need to be stored long-term), and so on.\nWe know that our current working directory /Users/nelle is stored inside /Users because /Users is the first part of its name. Similarly, we know that /Users is stored inside the root directory / because its name begins with /.\nUnderneath /Users, we find one directory for each user with an account on Nelle‚Äôs machine, her colleagues imhotep and larry.\nThe user imhotep‚Äôs files are stored in /Users/imhotep, user larry‚Äôs in /Users/larry, and Nelle‚Äôs in /Users/nelle. Nelle is the user in our examples here; therefore, we get /Users/nelle as our home directory. Typically, when you open a new command prompt, you will be in your home directory to start.\nNow let‚Äôs learn the command that will let us see the contents of our own filesystem. We can see what‚Äôs in our home directory by running ls:\n(Again, your results may be slightly different depending on your operating system and how you have customized your filesystem.)\nls prints the names of the files and directories in the current directory. We can make its output more comprehensible by using the -F option which tells ls to classify the output by adding a marker to file and directory names to indicate what they are:\nDepending on your shell‚Äôs default settings, the shell might also use colors to indicate whether each entry is a file or directory.\nHere, we can see that the home directory contains only sub-directories. Any names in the output that don‚Äôt have a classification symbol are files in the current working directory."
  },
  {
    "objectID": "episodes/02-filedir.html#general-syntax-of-a-shell-command",
    "href": "episodes/02-filedir.html#general-syntax-of-a-shell-command",
    "title": "Navigating Files and Directories",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments, but it is perhaps useful to formalise some terminology.\nConsider the command below as a general example of a command, which we will dissect into its component parts:\nls -F /\n\n\n\n\n\nls is the command, with an option -F and an argument /. We‚Äôve already encountered options which either start with a single dash (-), known as short options, or two dashes (--), known as long options. Options change the behavior of a command and Arguments tell the command what to operate on (e.g.¬†files and directories). Sometimes options and arguments are referred to as parameters. A command can be called with more than one option and more than one argument, but a command doesn‚Äôt always require an argument or an option.\nYou might sometimes see options being referred to as switches or flags, especially for options that take no argument. In this lesson we will stick with using the term option.\nEach part is separated by spaces. If you omit the space between ls and -F the shell will look for a command called ls-F, which doesn‚Äôt exist. Also, capitalization can be important. For example, ls -s will display the size of files and directories alongside the names, while ls -S will sort the files and directories by size, as shown below:\ncd ~/Desktop/shell-lesson-data\nls -s exercise-data\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 alkanes   4 writing\nNote that the sizes returned by ls -s are in blocks. As these are defined differently for different operating systems, you may not obtain the same figures as in the example.\nls -S exercise-data\nanimal-counts  creatures  alkanes  writing  numbers.txt\nPutting all that together, our command ls -F / above gives us a listing of files and directories in the root directory /. An example of the output you might get from the above command is given below:\nls -F /\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\n\nNelle‚Äôs Pipeline: Organizing Files\nKnowing this much about files and directories, Nelle is ready to organize the files that the protein assay machine will create.\nShe creates a directory called north-pacific-gyre (to remind herself where the data came from), which will contain the data files from the assay machine and her data processing scripts.\nEach of her physical samples is labelled according to her lab‚Äôs convention with a unique ten-character ID, such as ‚ÄòNENE01729A‚Äô. This ID is what she used in her collection log to record the location, time, depth, and other characteristics of the sample, so she decides to use it within the filename of each data file. Since the output of the assay machine is plain text, she will call her files NENE01729A.txt, NENE01812A.txt, and so on. All 1520 files will go into the same directory.\nNow in her current directory shell-lesson-data, Nelle can see what files she has using the command:\nls north-pacific-gyre/\nThis command is a lot to type, but she can let the shell do most of the work through what is called tab completion. If she types:\nls nor\nand then presses Tab (the tab key on her keyboard), the shell automatically completes the directory name for her:\nls north-pacific-gyre/\nPressing Tab again does nothing, since there are multiple possibilities; pressing Tab twice brings up a list of all the files.\nIf Nelle then presses G and then presses Tab again, the shell will append ‚Äògoo‚Äô since all files that start with ‚Äòg‚Äô share the first three characters ‚Äògoo‚Äô.\nls north-pacific-gyre/goo\nTo see all of those files, she can press Tab twice more.\nls north-pacific-gyre/goo\ngoodiff.sh   goostats.sh\nThis is called tab completion, and we will see it in many other tools as we go on.\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which then form a directory tree.\npwd prints the user‚Äôs current working directory.\nls [path] prints a listing of a specific file or directory; ls on its own lists the current working directory.\ncd [path] changes the current working directory.\nMost commands take options that begin with a single -.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\nAn absolute path specifies a location from the root of the file system.\nA relative path specifies a location starting from the current location.\n. on its own means ‚Äòthe current directory‚Äô; .. means ‚Äòthe directory above the current one‚Äô.\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/03-create.html",
    "href": "episodes/03-create.html",
    "title": "Working With Files and Directories",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 20\nQuestions:\n\nHow can I create, copy, and delete files and directories?\nHow can I edit files?\n\nObjectives:\n\nDelete, copy and move specified files and/or directories.\nCreate files in that hierarchy using an editor or by copying and renaming existing files.\nCreate a directory hierarchy that matches a given diagram."
  },
  {
    "objectID": "episodes/03-create.html#creating-directories",
    "href": "episodes/03-create.html#creating-directories",
    "title": "Working With Files and Directories",
    "section": "Creating directories",
    "text": "Creating directories\nWe now know how to explore files and directories, but how do we create them in the first place?\nIn this episode we will learn about creating and moving files and directories, using the exercise-data/writing directory as an example.\n\nStep one: see where we are and what we already have\nWe should still be in the shell-lesson-data directory on the Desktop, which we can check using:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nNext we‚Äôll move to the exercise-data/writing directory and see what it contains:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt\n\n\nCreate a directory\nLet‚Äôs create a new directory called thesis using the command mkdir thesis (which has no output):\nmkdir thesis\nAs you might guess from its name, mkdir means ‚Äòmake directory‚Äô. Since thesis is a relative path (i.e., does not have a leading slash, like /what/ever/thesis), the new directory is created in the current working directory:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/\nSince we‚Äôve just created the thesis directory, there‚Äôs nothing in it yet:\nls -F thesis\nNote that mkdir is not limited to creating single directories one at a time. The -p option allows mkdir to create a directory with nested subdirectories in a single operation:\nmkdir -p ../project/data ../project/results\nThe -R option to the ls command will list all nested subdirectories within a directory. Let‚Äôs use ls -FR to recursively list the new directory hierarchy we just created in the project directory:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\nTwo ways of doing the same thing\n\n\n\nUsing the shell to create a directory is no different than using a file explorer. If you open the current directory using your operating system‚Äôs graphical file explorer, the thesis directory will appear there too. While the shell and the file explorer are two different ways of interacting with the files, the files and directories themselves are the same.\n\n\n\n\n\n\n\n\nGood names for files and directories\n\n\n\nComplicated names of files and directories can make your life painful when working on the command line. Here we provide a few useful tips for the names of your files and directories.\n\nDon‚Äôt use spaces.\n\nSpaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g.¬†north-pacific-gyre/ rather than north pacific gyre/). To test this out, try typing mkdir north pacific gyre and see what directory (or directories!) are made when you check with ls -F.\n\nDon‚Äôt begin the name with - (dash).\n\nCommands treat names starting with - as options.\n\nStick with lowercase letters, numbers, . (period or ‚Äòfull stop‚Äô), - (dash) and _ (underscore).\n\nMany other characters have special meanings on the command line. We will learn about some of these during this lesson. There are special characters that can cause your command to not work as expected and can even result in data loss.\nIf you need to refer to names of files or directories that have spaces or other special characters, you should surround the name in single quotes ('').\nIt is often good practice to use all lowercase letters in names of files and directories; Windows and macOS file systems are typically case insensitive and therefore unable to distinguish between thesis and Thesis in the same directory.\n\n\n\n\nCreate a text file\nLet‚Äôs change our working directory to thesis using cd, then run a text editor called Nano to create a file called draft.txt:\ncd thesis\nnano draft.txt\n\n\n\n\n\n\nWhich Editor?\n\n\n\nWhen we say, ‚Äònano is a text editor‚Äô we really do mean ‚Äòtext‚Äô. It can only work with plain character data, not tables, images, or any other human-friendly media. We use it in examples because it is one of the least complex text editors. However, because of this trait, it may not be powerful enough or flexible enough for the work you need to do after this workshop. On Unix systems (such as Linux and macOS), many programmers use Emacs or Vim (both of which require more time to learn), or a graphical editor such as Gedit or VScode. On Windows, you may wish to use Notepad++. Windows also has a built-in editor called notepad that can be run from the command line in the same way as nano for the purposes of this lesson.\nNo matter what editor you use, you will need to know where it searches for and saves files. If you start it from the shell, it will (probably) use your current working directory as its default location. If you use your computer‚Äôs start menu, it may want to save files in your Desktop or Documents directory instead. You can change this by navigating to another directory the first time you ‚ÄòSave As‚Ä¶‚Äô\n\n\nLet‚Äôs type in a few lines of text.\n\nOnce we‚Äôre happy with our text, we can press Ctrl+O (press the Ctrl or Control key and, while holding it down, press the O key) to write our data to disk. We will be asked to provide a name for the file that will contain our text. Press Return to accept the suggested default of draft.txt.\nOnce our file is saved, we can use Ctrl+X to quit the editor and return to the shell.\n\n\n\n\n\n\nControl, Ctrl, or ^ Key\n\n\n\nThe Control key is also called the ‚ÄòCtrl‚Äô key. There are various ways in which using the Control key may be described. For example, you may see an instruction to press the Control key and, while holding it down, press the X key, described as any of:\n\nControl-X\nControl+X\nCtrl-X\nCtrl+X\n^X\nC-x\n\nIn nano, along the bottom of the screen you‚Äôll see ^G Get Help ^O WriteOut. This means that you can use Control-G to get help and Control-O to save your file.\n\n\nnano doesn‚Äôt leave any output on the screen after it exits, but ls now shows that we have created a file called draft.txt:\nls\ndraft.txt\n\n\n\n\n\n\nCreating Files a Different Way\n\n\n\nWe have seen how to create text files using the nano editor. Now, try the following command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you‚Äôve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt\n\n\n\n\n\n\n\n\n\nWhat‚Äôs In A Name?\n\n\n\nYou may have noticed that all of Nelle‚Äôs files are named ‚Äòsomething dot something‚Äô, and in this part of the lesson, we always used the extension .txt. This is just a convention; we can call a file mythesis or almost anything else we want. However, most people use two-part names most of the time to help them (and their programs) tell different kinds of files apart. The second part of such a name is called the filename extension and indicates what type of data the file holds: .txt signals a plain text file, .pdf indicates a PDF document, .cfg is a configuration file full of parameters for some program or other, .png is a PNG image, and so on.\nThis is just a convention, albeit an important one. Files merely contain bytes; it‚Äôs up to us and our programs to interpret those bytes according to the rules for plain text files, PDF documents, configuration files, images, and so on.\nNaming a PNG image of a whale as whale.mp3 doesn‚Äôt somehow magically turn it into a recording of whale song, though it might cause the operating system to associate the file with a music player program. In this case, if someone double-clicked whale.mp3 in a file explorer program, the music player will automatically (and erroneously) attempt to open the whale.mp3 file."
  },
  {
    "objectID": "episodes/03-create.html#moving-files-and-directories",
    "href": "episodes/03-create.html#moving-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Moving files and directories",
    "text": "Moving files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory,\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\nIn our thesis directory we have a file draft.txt which isn‚Äôt a particularly informative name, so let‚Äôs change the file‚Äôs name using mv, which is short for ‚Äòmove‚Äô:\nmv thesis/draft.txt thesis/quotes.txt\nThe first argument tells mv what we‚Äôre ‚Äòmoving‚Äô, while the second is where it‚Äôs to go. In this case, we‚Äôre moving thesis/draft.txt to thesis/quotes.txt, which has the same effect as renaming the file. Sure enough, ls shows us that thesis now contains one file called quotes.txt:\nls thesis\nquotes.txt\nOne must be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name, which could lead to data loss. By default, mv will not ask for confirmation before overwriting files. However, an additional option, mv -i (or mv --interactive), will cause mv to request such confirmation.\nNote that mv also works on directories.\nLet‚Äôs move quotes.txt into the current working directory. We use mv once again, but this time we‚Äôll use just the name of a directory as the second argument to tell mv that we want to keep the filename but put the file somewhere new. (This is why the command is called ‚Äòmove‚Äô.) In this case, the directory name we use is the special directory name . that we mentioned earlier.\nmv thesis/quotes.txt .\nThe effect is to move the file from the directory it was in to the current working directory. ls now shows us that thesis is empty:\nls thesis\n$\nAlternatively, we can confirm the file quotes.txt is no longer present in the thesis directory by explicitly trying to list it:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nls with a filename or directory as an argument only lists the requested file or directory. If the file given as the argument doesn‚Äôt exist, the shell returns an error as we saw above. We can use this to see that quotes.txt is now present in our current directory:\nls quotes.txt\nquotes.txt\n\n\n\n\n\n\nMoving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e.¬†the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e.¬†one above the current directory) and that . refers to the current directory."
  },
  {
    "objectID": "episodes/03-create.html#copying-files-and-directories",
    "href": "episodes/03-create.html#copying-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Copying files and directories",
    "text": "Copying files and directories\nThe cp command works very much like mv, except it copies a file instead of moving it. We can check that it did the right thing using ls with two paths as arguments ‚Äî like most Unix commands, ls can be given multiple paths at once:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nWe can also copy a directory and all its contents by using the recursive option -r, e.g.¬†to back up a directory:\ncp -r thesis thesis_backup\nWe can check the result by listing the contents of both the thesis and thesis_backup directory:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\nIt is important to include the -r flag. If you want to copy a directory and you omit this option you will see a message that the directory has been omitted because -r not specified.\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\n\n\n\n\n\n\nRenaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo.¬†While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\nMoving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‚Äògo up a level‚Äô, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie"
  },
  {
    "objectID": "episodes/03-create.html#removing-files-and-directories",
    "href": "episodes/03-create.html#removing-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Removing files and directories",
    "text": "Removing files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory, let‚Äôs tidy up this directory by removing the quotes.txt file we created. The Unix command we‚Äôll use for this is rm (short for ‚Äòremove‚Äô):\nrm quotes.txt\nWe can confirm the file has gone using ls:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\nDeleting Is Forever\n\n\n\nThe Unix shell doesn‚Äôt have a trash bin that we can recover deleted files from (though most graphical interfaces to Unix do). Instead, when we delete files, they are unlinked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there‚Äôs no guarantee they‚Äôll work in any particular situation, since the computer may recycle the file‚Äôs disk space right away.\n\n\n\n\n\n\n\n\nUsing rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn‚Äôt have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\nIf we try to remove the thesis directory using rm thesis, we get an error message:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nThis happens because rm by default only works on files, not directories.\nrm can remove a directory and all its contents if we use the recursive option -r, and it will do so without any confirmation prompts:\nrm -r thesis\nGiven that there is no way to retrieve files deleted using the shell, rm -r should be used with great caution (you might consider adding the interactive option rm -r -i)."
  },
  {
    "objectID": "episodes/03-create.html#operations-with-multiple-files-and-directories",
    "href": "episodes/03-create.html#operations-with-multiple-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Operations with multiple files and directories",
    "text": "Operations with multiple files and directories\nOftentimes one needs to copy or move several files at once. This can be done by providing a list of individual filenames, or specifying a naming pattern using wildcards. Wildcards are special characters that can be used to represent unknown characters or sets of characters when navigating the Unix file system.\n\n\n\n\n\n\nCopy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let‚Äôs try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory\n\n\n\n\nUsing wildcards for accessing multiple files at once\n\n\n\n\n\n\nWildcards\n\n\n\n* is a wildcard, which represents zero or more other characters. Let‚Äôs consider the shell-lesson-data/exercise-data/alkanes directory: *.pdb represents ethane.pdb, propane.pdb, and every file that ends with ‚Äò.pdb‚Äô. On the other hand, p*.pdb only represents pentane.pdb and propane.pdb, because the ‚Äòp‚Äô at the front can only represent filenames that begin with the letter ‚Äòp‚Äô.\n? is also a wildcard, but it represents exactly one character. So ?ethane.pdb could represent methane.pdb whereas *ethane.pdb represents both ethane.pdb and methane.pdb.\nWildcards can be used in combination with each other. For example, ???ane.pdb indicates three characters followed by ane.pdb, giving cubane.pdb  ethane.pdb  octane.pdb.\nWhen the shell sees a wildcard, it expands the wildcard to create a list of matching filenames before running the preceding command. As an exception, if a wildcard expression does not match any file, Bash will pass the expression as an argument to the command as it is. For example, typing ls *.pdf in the alkanes directory (which contains only files with names ending with .pdb) results in an error message that there is no file called *.pdf. However, generally commands like wc and ls see the lists of file names matching these expressions, but not the wildcards themselves. It is the shell, not the other programs, that expands the wildcards.\n\n\n\n\n\n\n\n\nList filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn‚Äôt match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îî‚îÄ‚îÄ all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îú‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îú‚îÄ‚îÄ backup\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ calibration\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-26-calibration.txt\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-calibration.txt\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datasets\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset2.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-10-26-dataset_overview.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n‚îî‚îÄ‚îÄ send_to_bob\n    ‚îú‚îÄ‚îÄ all_datasets_created_on_a_23rd\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-10-23-dataset_overview.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n    ‚îî‚îÄ‚îÄ all_november_files\n        ‚îú‚îÄ‚îÄ 2015-11-23-calibration.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset1.txt\n        ‚îú‚îÄ‚îÄ 2015-11-23-dataset2.txt\n        ‚îî‚îÄ‚îÄ 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\nOrganizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren‚Äôt very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‚Äòanalyzed‚Äô directory.\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nYou‚Äôre starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n‚îî‚îÄ‚îÄ data\n   ‚îú‚îÄ‚îÄ processed\n   ‚îî‚îÄ‚îÄ raw\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won‚Äôt create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‚Äòraw‚Äô and ‚Äòprocessed‚Äô directories at the same level as the ‚Äòdata‚Äô directory.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\ncp [old] [new] copies a file.\nmkdir [path] creates a new directory.\nmv [old] [new] moves (renames) a file or directory.\nrm [path] removes (deletes) a file.\n* matches zero or more characters in a filename, so *.txt matches all files ending in .txt.\n? matches any single character in a filename, so ?.txt matches a.txt but not any.txt.\nUse of the Control key may be described in many ways, including Ctrl-X, Control-X, and ^X.\nThe shell does not have a trash bin: once something is deleted, it‚Äôs really gone.\nMost files‚Äô names are something.extension. The extension isn‚Äôt required, and doesn‚Äôt guarantee anything, but is normally used to indicate the type of data in the file.\nDepending on the type of work you do, you may need a more powerful text editor than Nano.\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/05-pipefilter.html",
    "href": "episodes/05-pipefilter.html",
    "title": "Pipes and Filters",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 25\nExercises: 10\nQuestions:\n\nHow can I combine existing commands to produce a desired output?\nHow can I show only part of the output?\n\nObjectives:\n\nExplain the advantage of linking commands with pipes and filters.\nCombine sequences of commands to get new output\nRedirect a command‚Äôs output to a file.\nExplain what usually happens if a program or pipeline isn‚Äôt given any input to process.\nNow that we know a few basic commands, we can finally look at the shell‚Äôs most powerful feature: the ease with which it lets us combine existing programs in new ways. We‚Äôll start with the directory shell-lesson-data/exercise-data/alkanes that contains six files describing some simple organic molecules. The .pdb extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.\nLet‚Äôs run an example command:\nwc is the ‚Äòword count‚Äô command: it counts the number of lines, words, and characters in files (returning the values in that order from left to right).\nIf we run the command wc *.pdb, the * in *.pdb matches zero or more characters, so the shell turns *.pdb into a list of all .pdb files in the current directory:\nNote that wc *.pdb also shows the total number of all lines in the last line of the output.\nIf we run wc -l instead of just wc, the output shows only the number of lines per file:\nThe -m and -w options can also be used with the wc command to show only the number of characters or the number of words, respectively."
  },
  {
    "objectID": "episodes/05-pipefilter.html#capturing-output-from-commands",
    "href": "episodes/05-pipefilter.html#capturing-output-from-commands",
    "title": "Pipes and Filters",
    "section": "Capturing output from commands",
    "text": "Capturing output from commands\nWhich of these files contains the fewest lines? It‚Äôs an easy question to answer when there are only six files, but what if there were 6000? Our first step toward a solution is to run the command:\nwc -l *.pdb &gt; lengths.txt\nThe greater than symbol, &gt;, tells the shell to redirect the command‚Äôs output to a file instead of printing it to the screen. This command prints no screen output, because everything that wc would have printed has gone into the file lengths.txt instead. If the file doesn‚Äôt exist prior to issuing the command, the shell will create the file. If the file exists already, it will be silently overwritten, which may lead to data loss. Thus, redirect commands require caution.\nls lengths.txt confirms that the file exists:\nls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt. The cat command gets its name from ‚Äòconcatenate‚Äô i.e.¬†join together, and it prints the contents of files one after another. There‚Äôs only one file in this case, so cat just shows us what it contains:\ncat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\n\n\n\n\n\n\nOutput Page by Page\n\n\n\nWe‚Äôll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g.¬†less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit."
  },
  {
    "objectID": "episodes/05-pipefilter.html#filtering-output",
    "href": "episodes/05-pipefilter.html#filtering-output",
    "title": "Pipes and Filters",
    "section": "Filtering output",
    "text": "Filtering output\nNext we‚Äôll use the sort command to sort the contents of the lengths.txt file. But first we‚Äôll do an exercise to learn a little about the sort command:\n\n\n\n\n\n\nWhat Does sort -n Do?\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -n option specifies a numerical rather than an alphanumerical sort.\n\n\n\nWe will also use the -n option to specify that the sort is numerical instead of alphanumerical. This does not change the file; instead, it sends the sorted result to the screen:\nsort -n lengths.txt\n  9  methane.pdb\n 12  ethane.pdb\n 15  propane.pdb\n 20  cubane.pdb\n 21  pentane.pdb\n 30  octane.pdb\n107  total\nWe can put the sorted list of lines in another temporary file called sorted-lengths.txt by putting &gt; sorted-lengths.txt after the command, just as we used &gt; lengths.txt to put the output of wc into lengths.txt. Once we‚Äôve done that, we can run another command called head to get the first few lines in sorted-lengths.txt:\nsort -n lengths.txt &gt; sorted-lengths.txt\nhead -n 1 sorted-lengths.txt\n  9  methane.pdb\nUsing -n 1 with head tells it that we only want the first line of the file; -n 20 would get the first 20, and so on. Since sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines.\n\n\n\n\n\n\nRedirecting to the same file\n\n\n\nIt‚Äôs a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\nsort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt.\n\n\n\n\n\n\n\n\nWhat Does &gt;&gt; Mean?\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We‚Äôll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\necho The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\necho hello &gt; testfile01.txt\nand:\necho hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn the first example with &gt;, the string ‚Äòhello‚Äô is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‚Äòhello‚Äô to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e.¬†when we run it for the second time).\n\n\n\n\n\n\n\n\n\nAppending Data\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\nhead -n 3 animals.csv &gt; animals-subset.csv\ntail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nThe first three lines of animals.csv\nThe last two lines of animals.csv\nThe first three lines and the last two lines of animals.csv\nThe second and third lines of animals.csv\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv"
  },
  {
    "objectID": "episodes/05-pipefilter.html#passing-output-to-another-command",
    "href": "episodes/05-pipefilter.html#passing-output-to-another-command",
    "title": "Pipes and Filters",
    "section": "Passing output to another command",
    "text": "Passing output to another command\nIn our example of finding the file with the fewest lines, we are using two intermediate files lengths.txt and sorted-lengths.txt to store output. This is a confusing way to work because even once you understand what wc, sort, and head do, those intermediate files make it hard to follow what‚Äôs going on. We can make it easier to understand by running sort and head together:\nsort -n lengths.txt | head -n 1\n  9  methane.pdb\nThe vertical bar, |, between the two commands is called a pipe. It tells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis has removed the need for the sorted-lengths.txt file."
  },
  {
    "objectID": "episodes/05-pipefilter.html#combining-multiple-commands",
    "href": "episodes/05-pipefilter.html#combining-multiple-commands",
    "title": "Pipes and Filters",
    "section": "Combining multiple commands",
    "text": "Combining multiple commands\nNothing prevents us from chaining pipes consecutively. We can for example send the output of wc directly to sort, and then send the resulting output to head. This removes the need for any intermediate files.\nWe‚Äôll start by using a pipe to send the output of wc to sort:\nwc -l *.pdb | sort -n\n   9 methane.pdb\n  12 ethane.pdb\n  15 propane.pdb\n  20 cubane.pdb\n  21 pentane.pdb\n  30 octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so that the full pipeline becomes:\nwc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‚Äòthe log of three times x‚Äô. In our case, the algorithm is ‚Äòhead of sort of line count of *.pdb‚Äô.\nThe redirection and pipes used in the last few commands are illustrated below:\n\n\n\n\n\n\n\nPiping Commands Together\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!"
  },
  {
    "objectID": "episodes/05-pipefilter.html#tools-designed-to-work-together",
    "href": "episodes/05-pipefilter.html#tools-designed-to-work-together",
    "title": "Pipes and Filters",
    "section": "Tools designed to work together",
    "text": "Tools designed to work together\nThis idea of linking programs together is why Unix has been so successful. Instead of creating enormous programs that try to do many different things, Unix programmers focus on creating lots of simple tools that each do one job well, and that work well with each other. This programming model is called ‚Äòpipes and filters‚Äô. We‚Äôve already seen pipes; a filter is a program like wc or sort that transforms a stream of input into a stream of output. Almost all of the standard Unix tools can work this way. Unless told to do otherwise, they read from standard input, do something with what they‚Äôve read, and write to standard output.\nThe key is that any program that reads lines of text from standard input and writes lines of text to standard output can be combined with every other program that behaves this way as well. You can and should write your programs this way so that you and other people can put those programs into pipes to multiply their power.\n\n\n\n\n\n\nPipe Reading Comprehension\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\ncat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7\n\n\n\n\n\n\n\n\n\nPipe Construction\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\ncut -d , -f 2 animals.csv\nThe cut command is used to select or ‚Äòcut out‚Äô certain sections of each line in the file for further processing while leaving the original file unchanged. By default, cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter.\nIn the example above we use the -d option to specify the comma as our delimiter character instead of Tab. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncut -d , -f 2 animals.csv | sort | uniq\n\n\n\n\n\n\n\n\n\nWhich Pipe?\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory)."
  },
  {
    "objectID": "episodes/05-pipefilter.html#nelles-pipeline-checking-files",
    "href": "episodes/05-pipefilter.html#nelles-pipeline-checking-files",
    "title": "Pipes and Filters",
    "section": "Nelle‚Äôs Pipeline: Checking Files",
    "text": "Nelle‚Äôs Pipeline: Checking Files\nNelle has run her samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, Nelle types:\ncd north-pacific-gyre\nwc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\nNow she types this:\nwc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others. When she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning ‚Äî someone was probably in using the machine on the weekend, and she forgot to reset it. Before re-running that sample, she checks to see if any files have too much data:\nwc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\nThose numbers look good ‚Äî but what‚Äôs that ‚ÄòZ‚Äô doing there in the third-to-last line? All of her samples should be marked ‚ÄòA‚Äô or ‚ÄòB‚Äô; by convention, her lab uses ‚ÄòZ‚Äô to indicate samples with missing information. To find others like it, she does this:\nls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt\nSure enough, when she checks the log on her laptop, there‚Äôs no depth recorded for either of those samples. Since it‚Äôs too late to get the information any other way, she must exclude those two files from her analysis. She could delete them using rm, but there are actually some analyses she might do later where depth doesn‚Äôt matter, so instead, she‚Äôll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.\n\n\n\n\n\n\nRemoving Unneeded Files\n\n\n\nSuppose you want to delete your processed data files, and only keep your raw files and processing script to save storage. The raw files end in .dat and the processed files end in .txt. Which of the following would remove all the processed data files, and only the processed data files?\n\nrm ?.txt\nrm *.txt\nrm * .txt\nrm *.*\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThis would remove .txt files with one-character names\nThis is the correct answer\nThe shell would expand * to match everything in the current directory, so the command would try to remove all matched files and an additional file called .txt\nThe shell expands *.* to match all filenames containing at least one ., including the processed files (.txt) and raw files (.dat)\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nwc counts lines, words, and characters in its inputs.\ncat displays the contents of its inputs.\nsort sorts its inputs.\nhead displays the first 10 lines of its input by default without additional arguments.\ntail displays the last 10 lines of its input by default without additional arguments.\ncommand &gt; [file] redirects a command‚Äôs output to a file (overwriting any existing content).\ncommand &gt;&gt; [file] appends a command‚Äôs output to a file.\n[first] | [second] is a pipeline: the output of the first command is used as the input to the second.\nThe best way to use the shell is to use pipes to combine simple single-purpose programs (filters).\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/04-permissions.html",
    "href": "episodes/04-permissions.html",
    "title": "File Permissions",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 20\nExercises: 15\nQuestions:\n\nHow does Linux know who can access files?\nHow can I see what permissions a file has?\nHow can I set or change the permissions on a file?\n\nObjectives:\n\nView file permissions\nUnderstand the structure of the permissions string\nChange owners and permissions of files\nUse binary references to change permissions of files\nEvery file or folder in Linux has a set of permissions associated with it. These define who can access the file or folder and see or interact with them. Each file or folder has three types of entities that can have permissions assigned to them. These are, User, Group and all others. They have the following definitions:\nFor example, if a file had the following set of permissions:\nit would mean that:\nLet‚Äôs start by going back to the alkanes/ directory and quickly viewing the permissions of the methane.pbd file.\nThe command ls -l lists the files in the current folder and displays them in the long listing format. While this may initially look complex, we can break this down in the following left to right order:\nThe permission flags are the important thing we want to look at here. We can further break these down into the following three basic permission types:\nEach of these permission types is listed in the _rwxrwxrwx section of the output. The first character marked by an underscore is the special permission flag that can vary. It shows things like whether the item is a directory."
  },
  {
    "objectID": "episodes/04-permissions.html#modifying-permissions",
    "href": "episodes/04-permissions.html#modifying-permissions",
    "title": "File Permissions",
    "section": "Modifying Permissions",
    "text": "Modifying Permissions\nLet‚Äôs say we want to modify who can access some of the files in the alkanes/ directory. We‚Äôll assume here that we‚Äôre members of the bio on our system. On the cluster, all users must be members of cluster group to run jobs on the system. Each lab has a group associated with it, so we can use this method to share files with other members of the same lab.\nWe‚Äôll start by changing the ownership of the methane.pdb file so everyone who is a member of the bio group is able to read this file.\n\n\n\n\n\n\nGroups\n\n\n\nYou‚Äôll find that if you try to assign a group to a file and the group does not exist you‚Äôll get something similar to the following output.\nchown: bio: illegal group name\nIf you‚Äôre trying to do this locally, you can list the groups you‚Äôre currently a member of using the groups command like so:\ngroups\nJust pick one of these groups to demonstrate the method shown below.\n\n\ncd Desktop/shell-lesson-data/exercise-data/alkanes\nchown nelle:compbio methane.pdb\nWe can break the chown command down into the following parts. The command itself, chown. The user we want to set nelle. The group we want to set, compbio and the filename methane.pdb. When we list the contents of the directory again, we would see the change reflected like so:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r--r-- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\nNow lets say we want to allow members of the group to be able to make changes to this methane.pdb file but don‚Äôt want anyone else to see or edit this file. To do this, we‚Äôll need to change the permissions of the file. To explicitly define permissions you will need to reference the Permission Group and Permission Types.\nThe Permission Groups used are:\n\nu - Owner\ng - Group\no - Other / All Users\na - All (Owner, Group and All Users)\n\nThe Permission Types that are used are:\n\nr - Read\nw - Write\nx - Execute\n\nThe potential Assignment Operators are + (plus) and - (minus); these are used to tell the system whether to add or remove the specific permissions.\nFirst, let‚Äôs remove the ability for other users to read the methane.pdb file. We can do this by specifying the a permission group, the r permission type and the - (minus) operator. The command that we use to modify permissions is chmod (whose name stands for ‚Äúchange mode‚Äù).\nchmod o-r methane.pdb\nChecking this has gone through using ls -l:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-r----- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\nGood, we can see that the r flag has been removed from the other users section of the ten permission sets.\nNow lets continue by allowing all members of the bio group to write or edit the file.\nchmod g+w methane.pdb\nAnd again, checking this has gone through using ls -l:\ntotal 48\n-rw-r--r-- 1 nelle  bio    1158  8 Aug  2019 cubane.pdb\n-rw-r--r-- 1 nelle  bio     622  8 Aug  2019 ethane.pdb\n-rw-rw---- 1 nelle  compbio 422  8 Aug  2019 methane.pdb\n-rw-r--r-- 1 nelle  bio    1828  8 Aug  2019 octane.pdb\n-rw-r--r-- 1 nelle  bio    1226  8 Aug  2019 pentane.pdb\n-rw-r--r-- 1 nelle  bio     825  8 Aug  2019 propane.pdb\nExcellent, now all members of the group can both read and write to the methane.pdb file. You can apply this same method to any files that you have write permissions over.\n\n\n\n\n\n\nChanging permissions for all files in a directory?\n\n\n\nSay we want to change the permissions for all the files in the alkanes/ directory, how we would do this? Let‚Äôs try and give apply what we‚Äôve just learnt to give all other users write permissions over the files.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThere‚Äôs actually a few ways we can go about this and it really depends on how we target the files to change. First, we could use the wildcards we learnt about previously to target files based on a specific pattern. In this case a simple * would suffice to pick out every file in the current folder, e.g:\nchmod o+w *\nWe could also use the recursive flag avaliable to the chmod command to run through every file in a directory (including sub-directories) and apply a set of permissions to every file. E.g:\ncd ..\nchmod -R o+w alkanes/\nEither method works in this case, however be wary that as the -R flag works through the folder and all sub-folders, you may end up changing the permission on something you didn‚Äôt intend."
  },
  {
    "objectID": "episodes/04-permissions.html#using-binary-references-to-set-permissions",
    "href": "episodes/04-permissions.html#using-binary-references-to-set-permissions",
    "title": "File Permissions",
    "section": "Using Binary References to Set permissions",
    "text": "Using Binary References to Set permissions\nNow that you understand the permissions groups and types this one should feel natural. However, there is another way to set the permission using binary references. This replaces the explicitly defined permissions with binary references to these. While more complex than the previous method, we can use this to define multiple different permissions to all three permissions groups with a single command.\nA sample permission string would be chmod 640 methane.pdb, which means that the owner has read and write permissions, the group has read permissions, and all other user have no rights to the file.\nThe first number represents the Owner permission; the second represents the Group permissions; and the last number represents the permissions for all other users. The numbers are a binary representation of the rwx string where;\n\nr = 4\nw = 2\nx = 1\n\nYou add the numbers to get the integer/number representing the permissions you wish to set. You will need to include the binary permissions for each of the three permission groups.\n\n\n\n\n\nFor example, issuing the follow command changes the permissions assigned to methane.pdb to allow the owner both read and write to the file, group members read the file and everyone else read the file. Or, the original permissions this file had.\nchmod 644 methane.pdb\nls -l methane.pdb\n-rw-r--r--  1 nelle  bio   422B  8 Aug  2019 methane.pdb\n\n\n\n\n\n\nUsing binary references, how can you make a file executable?\n\n\n\nNow we‚Äôve seen how to use binary references to change permissions on a file. Can you change the methane.pdb file to make it executable? In this case, you can‚Äôt actually execute the file as it doesn‚Äôt contain the right data to do this, but it will teach you how to do this for other files in future, most notably scripts.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo ensure that we don‚Äôt make unintended changes to the other permissions currently assigned to the file, we need to first check what permissions it currently has\nls -l methane.pdb\n-rw-r--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nWe can see that both the read permission flags are set for groups and others. This makes creating the binary reference here easy as we only need to take the integer 4 for both these flags. Now we have the end of the binary reference, we need to add up the rest to give execute permissions to the file. As we already have read and write permissions as the owner of the file, we only need to add 1 to the binary reference to get 7. Therefore, the full binary reference we need to set is 744.\ncd ..\nchmod 744 methane.pdb\n-rwxr--r--  1 nelle  compbio   422B  8 Aug  2019 methane.pdb\nHere, the first 7 assigns read, write, execute to owner, the first 4 adds read to the group, and the last 4 adds read permissions to others.\n\n\n\n\n\n\n\n\n\nNecessary But Not Sufficient\n\n\n\nThe fact that something is marked as executable doesn‚Äôt actually mean it contains a runnable program. Marking an HTML file executable won‚Äôt make it run as a program; the OS may instead open it in the associated application."
  },
  {
    "objectID": "episodes/04-permissions.html#vs-..",
    "href": "episodes/04-permissions.html#vs-..",
    "title": "File Permissions",
    "section": ". vs ..",
    "text": ". vs ..\nBefore we go any further, let‚Äôs run ls -a -l to get a long-form listing that includes directory entries that are normally hidden:\nls -a -l\ntotal 48\ndrwxr-xr-x 1 nelle  bio        0  8 Aug  2019 .\ndrwxr-xr-x 1 nelle  bio     8192  8 Aug  2019 ..\n-rw-r--rw- 1 nelle  bio     1158  8 Aug  2019 cubane.pdb\n-rw-r--rw- 1 nelle  bio      622  8 Aug  2019 ethane.pdb\n-rwxr--r-- 1 nelle  compbio  422  8 Aug  2019 methane.pdb\n-rw-r--rw- 1 nelle  bio     1828  8 Aug  2019 octane.pdb\n-rw-r--rw- 1 nelle  bio     1226  8 Aug  2019 pentane.pdb\n-rw-r--rw- 1 nelle  bio      825  8 Aug  2019 propane.pdb\nThe permissions for . and .. (this directory and its parent) start with a ‚Äòd‚Äô. But look at the rest of their permissions: the ‚Äòx‚Äô means that ‚Äúexecute‚Äù is turned on. What does that mean? A directory isn‚Äôt a program‚Äîhow can we ‚Äúrun‚Äù it?\nIn fact, ‚Äòx‚Äô means something different for directories. It gives someone the right to traverse the directory, but not to look at its contents. The distinction is subtle, so let‚Äôs have a look at an example.\nNelle‚Äôs home directory has three subdirectories called venus, mars, and pluto:\n\n\n\n\n\nEach of these has a subdirectory in turn called notes, and those sub-subdirectories contain various files.\n\nIf a user‚Äôs permissions on venus are ‚Äòr-x‚Äô, then if she tries to see the contents of venus and venus/notes using ls, the computer lets her see both.\nIf her permissions on mars are just ‚Äòr‚Äì‚Äô, then she is allowed to read the contents of both mars and mars/notes.\nBut if her permissions on pluto are only ‚Äò‚Äìx‚Äô, she cannot see what‚Äôs in the pluto directory: ls pluto will tell her she doesn‚Äôt have permission to view its contents. If she tries to look in pluto/notes, though, the computer will let her do that. She‚Äôs allowed to go through pluto, but not to look at what‚Äôs there. This trick gives people a way to make some of their directories visible to the world as a whole without opening up everything else.\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nWe can list permissions for a file or folder using the -l flag with ls\nThe order of permissions groups is owner, group and others\nThe types of permissions are read, write and others\nUse the chown command to change both owner and group associated with a file/folder\nUse chmod to change permissions.\nBinary reference is made up of r=4, w=2 and x=1\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/08-find.html",
    "href": "episodes/08-find.html",
    "title": "Finding Things",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 25\nExercises: 20\nQuestions:\n\nHow can I find files?\nHow can I find things in files?\n\nObjectives:\n\nUse grep to select lines from text files that match simple patterns.\nUse find to find files and directories whose names match simple patterns.\nUse the output of one command as the command-line argument(s) to another command.\nExplain what is meant by ‚Äòtext‚Äô and ‚Äòbinary‚Äô files, and why many common tools don‚Äôt handle the latter well.\n\n\n\n\nIn the same way that many of us now use ‚ÄòGoogle‚Äô as a verb meaning ‚Äòto find‚Äô, Unix programmers often use the word ‚Äògrep‚Äô. ‚Äògrep‚Äô is a contraction of ‚Äòglobal/regular expression/print‚Äô, a common sequence of operations in early Unix text editors. It is also the name of a very useful command-line program.\ngrep finds and prints lines in files that match a pattern. For our examples, we will use a file that contains three haiku taken from a 1998 competition in Salon magazine (Credit to authors Bill Torcaso, Howard Korder, and Margaret Segall, respectively. See Haiku Error Messages archived Page 1 and Page 2 .). For this set of examples, we‚Äôre going to be working in the writing subdirectory:\ncd\ncd Desktop/shell-lesson-data/exercise-data/writing\ncat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that.\nLet‚Äôs find lines that contain the word ‚Äònot‚Äô:\ngrep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nHere, not is the pattern we‚Äôre searching for. The grep command searches through the file, looking for matches to the pattern specified. To use it type grep, then the pattern we‚Äôre searching for and finally the name of the file (or files) we‚Äôre searching in.\nThe output is the three lines in the file that contain the letters ‚Äònot‚Äô.\nBy default, grep searches for a pattern in a case-sensitive way. In addition, the search pattern we have selected does not have to form a complete word, as we will see in the next example.\nLet‚Äôs search for the pattern: ‚ÄòThe‚Äô.\ngrep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\nThis time, two lines that include the letters ‚ÄòThe‚Äô are outputted, one of which contained our search pattern within a larger word, ‚ÄòThesis‚Äô.\nTo restrict matches to lines containing the word ‚ÄòThe‚Äô on its own, we can give grep the -w option. This will limit matches to word boundaries.\nLater in this lesson, we will also see how we can change the search behavior of grep with respect to its case sensitivity.\ngrep -w The haiku.txt\nThe Tao that is seen\nNote that a ‚Äòword boundary‚Äô includes the start and end of a line, so not just letters surrounded by spaces. Sometimes we don‚Äôt want to search for a single word, but a phrase. We can also do this with grep by putting the phrase in quotes.\ngrep -w \"is not\" haiku.txt\nToday it is not working\nWe‚Äôve now seen that you don‚Äôt have to have quotes around single words, but it is useful to use quotes when searching for multiple words. It also helps to make it easier to distinguish between the search term or phrase and the file being searched. We will use quotes in the remaining examples.\nAnother useful option is -n, which numbers the lines that match:\ngrep -n \"it\" haiku.txt\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\nHere, we can see that lines 5, 9, and 10 contain the letters ‚Äòit‚Äô.\nWe can combine options (i.e.¬†flags) as we do with other Unix commands. For example, let‚Äôs find the lines that contain the word ‚Äòthe‚Äô. We can combine the option -w to find the lines that contain the word ‚Äòthe‚Äô and -n to number the lines that match:\ngrep -n -w \"the\" haiku.txt\n2:Is not the true Tao, until\n6:and the presence of absence:\nNow we want to use the option -i to make our search case-insensitive:\ngrep -n -w -i \"the\" haiku.txt\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:\nNow, we want to use the option -v to invert our search, i.e., we want to output the lines that do not contain the word ‚Äòthe‚Äô.\ngrep -n -w -v \"the\" haiku.txt\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\nIf we use the -r (recursive) option, grep can search for a pattern recursively through a set of files in subdirectories.\nLet‚Äôs search recursively for Yesterday in the shell-lesson-data/exercise-data/writing directory:\ngrep -r Yesterday .\n./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n./haiku.txt:Yesterday it worked\ngrep has lots of other options. To find out what they are, we can type:\ngrep --help\nUsage: grep [OPTION]... PATTERN [FILE]...\nSearch for PATTERN in each FILE or standard input.\nPATTERN is, by default, a basic regular expression (BRE).\nExample: grep -i 'hello world' menu.h main.c\n\nRegexp selection and interpretation:\n  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n\nMiscellaneous:\n...        ...        ...\n\n\n\n\n\n\nUsing grep\n\n\n\nWhich command would result in the following output:\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 3, because the -w option looks only for whole-word matches. The other options will also match ‚Äòof‚Äô when part of another word.\n\n\n\n\n\n\n\n\n\nWildcards\n\n\n\ngrep‚Äòs real power doesn‚Äôt come from its options, though; it comes from the fact that patterns can include wildcards. (The technical name for these is regular expressions, which is what the ‚Äôre‚Äô in ‚Äògrep‚Äô stands for.) Regular expressions are both complex and powerful; if you want to do complex searches, please look at the lesson on our website. As a taster, we can find lines that have an ‚Äòo‚Äô in the second position like this:\ngrep -E \"^.o\" haiku.txt\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\nWe use the -E option and put the pattern in quotes to prevent the shell from trying to interpret it. (If the pattern contained a *, for example, the shell would try to expand it before running grep.) The ^ in the pattern anchors the match to the start of the line. The . matches a single character (just like ? in the shell), while the o matches an actual ‚Äòo‚Äô.\n\n\n\nFinding by Permissions\nfind can filter by file permissions using -perm. This is handy for locating executables or overly open files.\nFind regular files the owner can execute:\nfind . -type f -perm -u=x\nFind files writable by the group or readable by others:\nfind . -type f -perm -g=w      # group has write\nfind . -type f -perm -o=r      # others have read\nThe leading - before each mode (e.g., -u=x) means ‚Äúmatch if these bits are set‚Äù, not exactly equal to the mode.\n\n\n\n\n\n\nTracking a Species\n\n\n\nLeah has several hundred data files saved in one directory, each of which is formatted like this:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nShe wants to write a shell script that takes a species as the first command-line argument and a directory as the second argument. The script should return one file called &lt;species&gt;.txt containing a list of dates and the number of that species seen on each date. For example using the data shown above, rabbit.txt would contain:\n2012-11-05,22\n2012-11-06,19\n2012-11-07,16\nBelow, each line contains an individual command, or pipe. Arrange their sequence in one command in order to achieve Leah‚Äôs goal:\ncut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\nHint: use man grep to look for how to grep text recursively in a directory and man cut to select more than one field in a line.\nAn example of such a file is provided in shell-lesson-data/exercise-data/animal-counts/animals.csv\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ngrep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\nActually, you can swap the order of the two cut commands and it still works. At the command line, try changing the order of the cut commands, and have a look at the output from each step to see why this is the case.\nYou would call the script above like this:\nbash count-species.sh bear .\n\n\n\n\n\n\n\n\n\nLittle Women\n\n\n\nYou and your friend, having just finished reading Little Women by Louisa May Alcott, are in an argument. Of the four sisters in the book, Jo, Meg, Beth, and Amy, your friend thinks that Jo was the most mentioned. You, however, are certain it was Amy. Luckily, you have a file LittleWomen.txt containing the full text of the novel (shell-lesson-data/exercise-data/writing/LittleWomen.txt). Using a for loop, how would you tabulate the number of times each of the four sisters is mentioned?\nHint: one solution might employ the commands grep and wc and a |, while another might utilize grep options. There is often more than one way to solve a programming task, so a particular solution is usually chosen based on a combination of yielding the correct result, elegance, readability, and speed.\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nfor sis in Jo Meg Beth Amy\ndo\n    echo $sis:\n    grep -ow $sis LittleWomen.txt | wc -l\ndone\nAlternative, slightly inferior solution:\nfor sis in Jo Meg Beth Amy\ndo\n    echo $sis:\n    grep -ocw $sis LittleWomen.txt\ndone\nThis solution is inferior because grep -c only reports the number of lines matched. The total number of matches reported by this method will be lower if there is more than one match per line.\nPerceptive observers may have noticed that character names sometimes appear in all-uppercase in chapter titles (e.g.¬†‚ÄòMEG GOES TO VANITY FAIR‚Äô). If you wanted to count these as well, you could add the -i option for case-insensitivity (though in this case, it doesn‚Äôt affect the answer to which sister is mentioned most frequently).\n\n\n\nWhile grep finds lines in files, the find command finds files themselves. Again, it has a lot of options; to show how the simplest ones work, we‚Äôll use the shell-lesson-data/exercise-data directory tree shown below.\n.\n‚îú‚îÄ‚îÄ animal-counts/\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ animals.csv\n‚îú‚îÄ‚îÄ creatures/\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ basilisk.dat\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ minotaur.dat\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ unicorn.dat\n‚îú‚îÄ‚îÄ numbers.txt\n‚îú‚îÄ‚îÄ alkanes/\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cubane.pdb\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ethane.pdb\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ methane.pdb\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ octane.pdb\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pentane.pdb\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ propane.pdb\n‚îî‚îÄ‚îÄ writing/\n    ‚îú‚îÄ‚îÄ haiku.txt\n    ‚îî‚îÄ‚îÄ LittleWomen.txt\nThe exercise-data directory contains one file, numbers.txt and four directories: animal-counts, creatures, alkanes and writing containing various files.\nFor our first command, let‚Äôs run find . (remember to run this command from the shell-lesson-data/exercise-data folder).\nfind .\n.\n./writing\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./creatures\n./creatures/basilisk.dat\n./creatures/unicorn.dat\n./creatures/minotaur.dat\n./animal-counts\n./animal-counts/animals.csv\n./numbers.txt\n./alkanes\n./alkanes/ethane.pdb\n./alkanes/propane.pdb\n./alkanes/octane.pdb\n./alkanes/pentane.pdb\n./alkanes/methane.pdb\n./alkanes/cubane.pdb\nAs always, the . on its own means the current working directory, which is where we want our search to start. find‚Äôs output is the names of every file and directory under the current working directory. This can seem useless at first but find has many options to filter the output and in this lesson we will discover some of them.\nThe first option in our list is -type d that means ‚Äòthings that are directories‚Äô. Sure enough, find‚Äôs output is the names of the five directories (including .):\nfind . -type d\n.\n./writing\n./creatures\n./animal-counts\n./alkanes\nNotice that the objects find finds are not listed in any particular order. If we change -type d to -type f, we get a listing of all the files instead:\nfind . -type f\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./creatures/basilisk.dat\n./creatures/unicorn.dat\n./creatures/minotaur.dat\n./animal-counts/animals.csv\n./numbers.txt\n./alkanes/ethane.pdb\n./alkanes/propane.pdb\n./alkanes/octane.pdb\n./alkanes/pentane.pdb\n./alkanes/methane.pdb\n./alkanes/cubane.pdb\nNow let‚Äôs try matching by name:\nfind . -name *.txt\n./numbers.txt\nWe expected it to find all the text files, but it only prints out ./numbers.txt. The problem is that the shell expands wildcard characters like * before commands run. Since *.txt in the current directory expands to ./numbers.txt, the command we actually ran was:\nfind . -name numbers.txt\nfind did what we asked; we just asked for the wrong thing.\nTo get what we want, let‚Äôs do what we did with grep: put *.txt in quotes to prevent the shell from expanding the * wildcard. This way, find actually gets the pattern *.txt, not the expanded filename numbers.txt:\nfind . -name \"*.txt\"\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./numbers.txt\n\n\n\n\n\n\nListing vs.¬†Finding\n\n\n\nls and find can be made to do similar things given the right options, but under normal circumstances, ls lists everything it can, while find searches for things with certain properties and shows them.\n\n\nAs we said earlier, the command line‚Äôs power lies in combining tools. We‚Äôve seen how to do that with pipes; let‚Äôs look at another technique. As we just saw, find . -name \"*.txt\" gives us a list of all text files in or below the current directory. How can we combine that with wc -l to count the lines in all those files?\nThe simplest way is to put the find command inside $():\nwc -l $(find . -name \"*.txt\")\n  21022 ./writing/LittleWomen.txt\n     11 ./writing/haiku.txt\n      5 ./numbers.txt\n  21038 total\nWhen the shell executes this command, the first thing it does is run whatever is inside the $(). It then replaces the $() expression with that command‚Äôs output. Since the output of find is the three filenames ./writing/LittleWomen.txt, ./writing/haiku.txt, and ./numbers.txt, the shell constructs the command:\nwc -l ./writing/LittleWomen.txt ./writing/haiku.txt ./numbers.txt\nwhich is what we wanted. This expansion is exactly what the shell does when it expands wildcards like * and ?, but lets us use any command we want as our own ‚Äòwildcard‚Äô.\nIt‚Äôs very common to use find and grep together. The first finds files that match a pattern; the second looks for lines inside those files that match another pattern. Here, for example, we can find txt files that contain the word ‚Äúsearching‚Äù by looking for the string ‚Äòsearching‚Äô in all the .txt files in the current directory:\ngrep \"searching\" $(find . -name \"*.txt\")\n./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was\n./writing/haiku.txt:With searching comes loss\n\n\n\n\n\n\nMatching and Subtracting\n\n\n\nThe -v option to grep inverts pattern matching, so that only lines which do not match the pattern are printed. Given that, which of the following commands will find all .dat files in creatures except unicorn.dat? Once you have thought about your answer, you can test the commands in the shell-lesson-data/exercise-data directory.\n\nfind creatures -name \"*.dat\" | grep -v unicorn\nfind creatures -name *.dat | grep -v unicorn\ngrep -v \"unicorn\" $(find creatures -name \"*.dat\")\nNone of the above.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct. Putting the match expression in quotes prevents the shell expanding it, so it gets passed to the find command.\nOption 2 also works in this instance because the shell tries to expand *.dat but there are no *.dat files in the current directory, so the wildcard expression gets passed to find. We first encountered this in episode 3.\nOption 3 is incorrect because it searches the contents of the files for lines which do not match ‚Äòunicorn‚Äô, rather than searching the file names.\n\n\n\n\n\n\n\n\n\nBinary Files\n\n\n\nWe have focused exclusively on finding patterns in text files. What if your data is stored as images, in databases, or in some other format?\nA handful of tools extend grep to handle a few non text formats. But a more generalizable approach is to convert the data to text, or extract the text-like elements from the data. On the one hand, it makes simple things easy to do. On the other hand, complex things are usually impossible. For example, it‚Äôs easy enough to write a program that will extract X and Y dimensions from image files for grep to play with, but how would you write something to find values in a spreadsheet whose cells contained formulas?\nA last option is to recognize that the shell and text processing have their limits, and to use another programming language. When the time comes to do this, don‚Äôt be too hard on the shell. Many modern programming languages have borrowed a lot of ideas from it, and imitation is also the sincerest form of praise.\n\n\nThe Unix shell is older than most of the people who use it. It has survived so long because it is one of the most productive programming environments ever created ‚Äî maybe even the most productive. Its syntax may be cryptic, but people who have mastered it can experiment with different commands interactively, then use what they have learned to automate their work. Graphical user interfaces may be easier to use at first, but once learned, the productivity in the shell is unbeatable. And as Alfred North Whitehead wrote in 1911, ‚ÄòCivilization advances by extending the number of important operations which we can perform without thinking about them.‚Äô\n\n\n\n\n\n\nfind Pipeline Reading Comprehension\n\n\n\nWrite a short explanatory comment for the following shell script:\nwc -l $(find . -name \"*.dat\") | sort -n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nFind all files with a .dat extension recursively from the current directory\nCount the number of lines each of these files contains\nSort the output from step 2. numerically\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nfind finds files with specific properties that match patterns.\ngrep selects lines in files that match patterns.\n--help is an option supported by many bash commands, and programs that can be run from within Bash, to display more information on how to use these commands or programs.\nman [command] displays the manual page for a given command.\n$([command]) inserts a command‚Äôs output in place.\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/01-intro.html",
    "href": "episodes/01-intro.html",
    "title": "Introducing the Shell",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 5\nExercises: 0\nQuestions:\n\nWhat is a command shell and why would I use one?\n\nObjectives:\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users‚Äô programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces."
  },
  {
    "objectID": "episodes/01-intro.html#nelles-pipeline-a-typical-problem",
    "href": "episodes/01-intro.html#nelles-pipeline-a-typical-problem",
    "title": "Introducing the Shell",
    "section": "Nelle‚Äôs Pipeline: A Typical Problem",
    "text": "Nelle‚Äôs Pipeline: A Typical Problem\nNelle Nemo, a marine biologist, has just returned from a six-month survey of the North Pacific Gyre, where she has been sampling gelatinous marine life in the Great Pacific Garbage Patch. She has 1520 samples that she‚Äôs run through an assay machine to measure the relative abundance of 300 proteins. She needs to run these 1520 files through an imaginary program called goostats.sh. In addition to this huge task, she has to write up results by the end of the month, so her paper can appear in a special issue of Aquatic Goo Letters.\nIf Nelle chooses to run goostats.sh by hand using a GUI, she‚Äôll have to select and open a file 1520 times. If goostats.sh takes 30 seconds to run each file, the whole process will take more than 12 hours of Nelle‚Äôs attention. With the shell, Nelle can instead assign her computer this mundane task while she focuses her attention on writing her paper.\nThe next few lessons will explore the ways Nelle can achieve this. More specifically, the lessons explain how she can use a command shell to run the goostats.sh program, using loops to automate the repetitive steps of entering file names, so that her computer can work while she writes her paper.\nAs a bonus, once she has put a processing pipeline together, she will be able to use it again whenever she collects more data.\nIn order to achieve her task, Nelle needs to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing her pipeline\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell‚Äôs main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.\n\n\n\n\n\n\n¬†\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/06-loop.html",
    "href": "episodes/06-loop.html",
    "title": "Loops",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 40\nExercises: 10\nQuestions:\n\nHow can I perform the same actions on many different files?\n\nObjectives:\n\nWrite a loop that applies one or more commands separately to each file in a set of files.\nTrace the values taken on by a loop variable during execution of the loop.\nExplain the difference between a variable‚Äôs name and its value.\nExplain why spaces and some punctuation characters shouldn‚Äôt be used in file names.\nDemonstrate how to see what commands have recently been executed.\nRe-run recently executed commands without retyping them.\nLoops are a programming construct which allow us to repeat a command or set of commands for each item in a list. As such they are key to productivity improvements through automation. Similar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes).\nSuppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat. For this example, we‚Äôll use the exercise-data/creatures directory which only has three example files, but the principles can be applied to many many more files at once.\nThe structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines. Let‚Äôs look at the files:\nWe would like to print out the classification for each species, which is given on the second line of each file. For each file, we would need to execute the command head -n 2 and pipe this to tail -n 1. We‚Äôll use a loop to solve this problem, but first let‚Äôs look at the general form of a loop, using the pseudo-code below:\nand we can apply this to our example like this:\nWhen the shell sees the keyword for, it knows to repeat a command (or group of commands) once for each item in a list. Each time the loop runs (called an iteration), an item in the list is assigned in sequence to the variable, and the commands inside the loop are executed, before moving on to the next item in the list. Inside the loop, we call for the variable‚Äôs value by putting $ in front of it. The $ tells the shell interpreter to treat the variable as a variable name and substitute its value in its place, rather than treat it as text or an external command.\nIn this example, the list is three filenames: basilisk.dat, minotaur.dat, and unicorn.dat. Each time the loop iterates, we first use echo to print the value that the variable $filename currently holds. This is not necessary for the result, but beneficial for us here to have an easier time to follow along. Next, we will run the head command on the file currently referred to by $filename. The first time through the loop, $filename is basilisk.dat. The interpreter runs the command head on basilisk.dat and pipes the first two lines to the tail command, which then prints the second line of basilisk.dat. For the second iteration, $filename becomes minotaur.dat. This time, the shell runs head on minotaur.dat and pipes the first two lines to the tail command, which then prints the second line of minotaur.dat. For the third iteration, $filename becomes unicorn.dat, so the shell runs the head command on that file, and tail on the output of that. Since the list was only three items, the shell exits the for loop.\nWhen using variables it is also possible to put the names into curly braces to clearly delimit the variable name: $filename is equivalent to ${filename}, but is different from ${file}name. You may find this notation in other people‚Äôs programs.\nWe have called the variable in this loop filename in order to make its purpose clearer to human readers. The shell itself doesn‚Äôt care what the variable is called; if we wrote this loop as:\nor:\nit would work exactly the same way. Don‚Äôt do this. Programs are only useful if people can understand them, so meaningless names (like x) or misleading names (like temperature) increase the odds that the program won‚Äôt do what its readers think it does.\nIn the above examples, the variables (thing, filename, x and temperature) could have been given any other name, as long as it is meaningful to both the person writing the code and the person reading it.\nNote also that loops can be used for other things than filenames, like a list of numbers or a subset of data.\nLet‚Äôs continue with our example in the shell-lesson-data/exercise-data/creatures directory. Here‚Äôs another example:\nThe shell starts by expanding *.dat to create the list of files it will process. The loop body then executes two commands for each of those files. In the first command, $filename is expanded to the name of the file, so echo $filename prints the name of the file. Then, the head and tail combination selects lines 81-100 from whatever file is being processed (assuming the file has at least 100 lines).\nWe would like to modify each of the files in shell-lesson-data/exercise-data/creatures, but also save a version of the original files. We want to copy the original files to new files named original-basilisk.dat and original-unicorn.dat, for example. We can‚Äôt use:\nbecause that would expand to:\nThis wouldn‚Äôt back up our files, instead we get an error:\nThis problem arises when cp receives more than two inputs. When this happens, it expects the last input to be a directory where it can copy all the files it was passed. Since there is no directory named original-*.dat in the creatures directory, we get an error.\nInstead, we can use a loop:\nThis loop runs the cp command once for each filename. The first time, when $filename expands to basilisk.dat, the shell executes:\nThe second time, the command is:\nThe third and last time, the command is:\nSince the cp command does not normally produce any output, it‚Äôs hard to check that the loop is working correctly. However, we learned earlier how to print strings using echo, and we can modify the loop to use echo to print our commands without actually executing them. As such we can check what commands would be run in the unmodified loop.\nThe following diagram shows what happens when the modified loop is executed and demonstrates how the judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "episodes/06-loop.html#nelles-pipeline-processing-files",
    "href": "episodes/06-loop.html#nelles-pipeline-processing-files",
    "title": "Loops",
    "section": "Nelle‚Äôs Pipeline: Processing Files",
    "text": "Nelle‚Äôs Pipeline: Processing Files\nNelle is now ready to process her data files using goostats.sh ‚Äî a shell script written by her supervisor. This calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince she‚Äôs still learning how to use the shell, she decides to build up the required commands in stages. Her first step is to make sure that she can select the right input files ‚Äî remember, these are ones whose names end in ‚ÄòA‚Äô or ‚ÄòB‚Äô, rather than ‚ÄòZ‚Äô. Moving to the north-pacific-gyre directory, Nelle types:\ncd\ncd Desktop/shell-lesson-data/north-pacific-gyre\nfor datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile\n&gt; done\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n\n...\nNENE02040B.txt\nNENE02043B.txt\nHer next step is to decide what to call the files that the goostats.sh analysis program will create. Prefixing each input file‚Äôs name with ‚Äòstats‚Äô seems simple, so she modifies her loop to do that:\nfor datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile stats-$datafile\n&gt; done\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01729A.txt\nNENE01751A.txt stats-NENE01729A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nShe hasn‚Äôt actually run goostats.sh yet, but now she‚Äôs sure she can select the right files and generate the right output filenames.\nTyping in commands over and over again is becoming tedious, though, and Nelle is worried about making mistakes, so instead of re-entering her loop, she presses ‚Üë. In response, the shell redisplays the whole loop on one line (using semi-colons to separate the pieces):\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nUsing the ‚Üê, Nelle navigates to the echo command and changes it to bash goostats.sh:\nfor datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\nWhen she presses Enter, the shell runs the modified command. However, nothing appears to happen ‚Äî there is no output. After a moment, Nelle realizes that since her script doesn‚Äôt print anything to the screen any longer, she has no idea whether it is running, much less how quickly. She kills the running command by typing Ctrl+C, uses ‚Üë to repeat the command, and edits it to read:\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\nbash goostats.sh $datafile stats-$datafile; done\n\n\n\n\n\n\nBeginning and End\n\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E.\n\n\nWhen she runs her program now, it produces one line of output every five seconds or so:\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\n1518 times 5 seconds, divided by 60, tells her that her script will take about two hours to run. As a final check, she opens another terminal window, goes into north-pacific-gyre, and uses cat stats-NENE01729B.txt to examine one of the output files. It looks good, so she decides to get some coffee and catch up on her reading.\n\n\n\n\n\n\nThose Who Know History Can Choose to Repeat It\n\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where ‚Äò123‚Äô is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:\nhistory | tail -n 5\n456  for datafile in NENE*A.txt NENE*B.txt; do   echo $datafile stats-$datafile; done\n457  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n458  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n459  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; bash goostats.sh $datafile\nstats-$datafile; done\n460  history | tail -n 5\nthen she can re-run goostats.sh on the files simply by typing !459.\n\n\n\n\n\n\n\n\nOther History Commands\n\n\n\nThere are a number of other shortcut commands for getting at the history.\n\nCtrl+R enters a history search mode ‚Äòreverse-i-search‚Äô and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ‚Üë)\n!$ retrieves the last word of the last command. That‚Äôs useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ‚Üë and editing the command-line.\n\n\n\n\n\n\n\n\n\nDoing a Dry Run\n\n\n\nA loop is a way to do many things at once ‚Äî or to make many mistakes at once if it does the wrong thing. One way to check what a loop would do is to echo the commands it would run instead of actually running them.\nSuppose we want to preview the commands the following loop will execute without actually running those commands:\nfor datafile in *.pdb\n&gt; do\n&gt;     cat $datafile &gt;&gt; all.pdb\n&gt; done\nWhat is the difference between the two loops below, and which one would we want to run?\n# Version 1\nfor datafile in *.pdb\n&gt; do\n&gt;     echo cat $datafile &gt;&gt; all.pdb\n&gt; done\n# Version 2\nfor datafile in *.pdb\n&gt; do\n&gt;     echo \"cat $datafile &gt;&gt; all.pdb\"\n&gt; done\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also does not modify nor create the file all.pdb, as the &gt;&gt; is treated literally as part of a string rather than as a redirection instruction.\nThe first version appends the output from the command echo cat $datafile to the file, all.pdb. This file will just contain the list; cat cubane.pdb, cat ethane.pdb, cat methane.pdb etc.\nTry both versions for yourself to see the output! Be sure to open the all.pdb file to view its contents.\n\n\n\n\n\n\n\n\n\nNested Loops\n\n\n\nSuppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds and different temperatures. What would be the result of the following code:\nfor species in cubane ethane methane\n&gt; do\n&gt;     for temperature in 25 30 37 40\n&gt;     do\n&gt;         mkdir $species-$temperature\n&gt;     done\n&gt; done\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe have a nested loop, i.e.¬†contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.\nTry running the code for yourself to see which directories are created!\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA for loop repeats commands once for every thing in a list.\nEvery for loop needs a variable to refer to the thing it is currently operating on.\nUse $name to expand a variable (i.e., get its value). ${name} can also be used.\nDo not use spaces, quotes, or wildcard characters such as ‚Äô*‚Äô or ‚Äò?‚Äô in filenames, as it complicates variable expansion.\nGive files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.\nUse the up-arrow key to scroll up through previous commands to edit and repeat them.\nUse Ctrl+R to search through the previously entered commands.\nUse history to display recent commands, and ![number] to repeat a command by number.\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/07-script.html",
    "href": "episodes/07-script.html",
    "title": "Shell Scripts",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 15\nQuestions:\n\nHow can I save and re-use commands?\n\nObjectives:\n\nWrite a shell script that runs a command or series of commands for a fixed set of files.\nRun a shell script from the command line.\nWrite a shell script that operates on a set of files defined by the user on the command line.\nCreate pipelines that include shell scripts you, and others, have written.\nWe are finally ready to see what makes the shell such a powerful programming environment. We are going to take the commands we repeat frequently and save them in files so that we can re-run all those operations again later by typing a single command. For historical reasons, a bunch of commands saved in a file is usually called a shell script, but make no mistake ‚Äî these are actually small programs.\nNot only will writing shell scripts make your work faster, but also you won‚Äôt have to retype the same commands over and over again. It will also make it more accurate (fewer chances for typos) and more reproducible. If you come back to your work later (or if someone else finds your work and wants to build on it), you will be able to reproduce the same results simply by running your script, rather than having to remember or retype a long list of commands.\nLet‚Äôs start by going back to alkanes/ and creating a new file, middle.sh which will become our shell script:\nThe command nano middle.sh opens the file middle.sh within the text editor ‚Äònano‚Äô (which runs within the shell). If the file does not exist, it will be created. We can use the text editor to directly edit the file by inserting the following line:\nThis is a variation on the pipe we constructed earlier, which selects lines 11-15 of the file octane.pdb. Remember, we are not running it as a command just yet; we are only incorporating the commands in a file.\nThen we save the file (Ctrl-O in nano) and exit the text editor (Ctrl-X in nano). Check that the directory alkanes now contains a file called middle.sh.\nOnce we have saved the file, we can ask the shell to execute the commands it contains. Our shell is called bash, so we run the following command:\nSure enough, our script‚Äôs output is exactly what we would get if we ran that pipeline directly.\nWhat if we want to select lines from an arbitrary file? We could edit middle.sh each time to change the filename, but that would probably take longer than typing the command out again in the shell and executing it with a new file name. Instead, let‚Äôs edit middle.sh and make it more versatile:\nNow, within ‚Äúnano‚Äù, replace the text octane.pdb with the special variable called $1:\nInside a shell script, $1 means ‚Äòthe first filename (or other argument) on the command line‚Äô. We can now run our script like this:\nor on a different file like this:\nCurrently, we need to edit middle.sh each time we want to adjust the range of lines that is returned. Let‚Äôs fix that by configuring our script to instead use three command-line arguments. After the first command-line argument ($1), each additional argument that we provide will be accessible via the special variables $1, $2, $3, which refer to the first, second, third command-line arguments, respectively.\nKnowing this, we can use additional arguments to define the range of lines to be passed to head and tail respectively:\nWe can now run:\nBy changing the arguments to our command, we can change our script‚Äôs behaviour:\nThis works, but it may take the next person who reads middle.sh a moment to figure out what it does. We can improve our script by adding some comments at the top:\nA comment starts with a # character and runs to the end of the line. The computer ignores comments, but they‚Äôre invaluable for helping people (including your future self) understand and use scripts. The only caveat is that each time you modify the script, you should check that the comment is still accurate. An explanation that sends the reader in the wrong direction is worse than none at all.\nWhat if we want to process many files in a single pipeline? For example, if we want to sort our .pdb files by length, we would type:\nbecause wc -l lists the number of lines in the files (recall that wc stands for ‚Äòword count‚Äô, adding the -l option means ‚Äòcount lines‚Äô instead) and sort -n sorts things numerically. We could put this in a file, but then it would only ever sort a list of .pdb files in the current directory. If we want to be able to get a sorted list of other kinds of files, we need a way to get all those names into the script. We can‚Äôt use $1, $2, and so on because we don‚Äôt know how many files there are. Instead, we use the special variable $@, which means, ‚ÄòAll of the command-line arguments to the shell script‚Äô. We also should put $@ inside double-quotes to handle the case of arguments containing spaces (\"$@\" is special syntax and is equivalent to \"$1\" \"$2\" ‚Ä¶).\nHere‚Äôs an example:\nSuppose we have just run a series of commands that did something useful ‚Äî for example, creating a graph we‚Äôd like to use in a paper. We‚Äôd like to be able to re-create the graph later if we need to, so we want to save the commands in a file. Instead of typing them in again (and potentially getting them wrong) we can do this:\nThe file redo-figure-3.sh now contains:\nAfter a moment‚Äôs work in an editor to remove the serial numbers on the commands, and to remove the final line where we called the history command, we have a completely accurate record of how we created that figure.\nIn practice, most people develop shell scripts by running commands at the shell prompt a few times to make sure they‚Äôre doing the right thing, then saving them in a file for re-use. This style of work allows people to recycle what they discover about their data and their workflow with one call to history and a bit of editing to clean up the output and save it as a shell script."
  },
  {
    "objectID": "episodes/07-script.html#nelles-pipeline-creating-a-script",
    "href": "episodes/07-script.html#nelles-pipeline-creating-a-script",
    "title": "Shell Scripts",
    "section": "Nelle‚Äôs Pipeline: Creating a Script",
    "text": "Nelle‚Äôs Pipeline: Creating a Script\nNelle‚Äôs supervisor insisted that all her analytics must be reproducible. The easiest way to capture all the steps is in a script.\nFirst we return to Nelle‚Äôs project directory:\ncd ../../north-pacific-gyre/\nShe creates a file using nano ‚Ä¶\nnano do-stats.sh\n‚Ä¶which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nShe saves this in a file called do-stats.sh so that she can now re-do the first stage of her analysis by typing:\nbash do-stats.sh NENE*A.txt NENE*B.txt\nShe can also do this:\nbash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed.\nOne thing to note about Nelle‚Äôs script is that it lets the person running it decide what files to process. She could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nThe advantage is that this always selects the right files: she doesn‚Äôt have to remember to exclude the ‚ÄòZ‚Äô files. The disadvantage is that it always selects just those files ‚Äî she can‚Äôt run it on all files (including the ‚ÄòZ‚Äô files), or on the ‚ÄòG‚Äô or ‚ÄòH‚Äô files her colleagues in Antarctica are producing, without editing the script. If she wanted to be more adventurous, she could modify her script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided. Of course, this introduces another tradeoff between flexibility and complexity.\n\n\n\n\n\n\nVariables in Shell Scripts\n\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\nbash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\nhead -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\ntail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks. As such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail.\n\n\n\n\n\n\n\n\n\nFind the Longest File With a Given Extension\n\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension. For example:\nbash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\nbash longest.sh shell-lesson-data/exercise-data/writing txt\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last). When there‚Äôs more than one file, wc also outputs a final summary line, giving the total number of lines across all files. We use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we‚Äôll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output.\n\n\n\n\n\n\n\n\n\nScript Reading Comprehension\n\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created. Explain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\n# Script 1\necho *.*\n# Script 2\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\n# Script 3\necho $@.pdb\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e.¬†all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n\n\n\n\n\n\n\n\n\nDebugging Scripts\n\n\n\nSuppose you have saved the following script in a file called do-errors.sh in Nelle‚Äôs north-pacific-gyre directory:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats.sh $datafile stats-$datafile\ndone\nWhen you run it from the north-pacific-gyre directory:\nbash do-errors.sh NENE*A.txt NENE*B.txt\nthe output is blank. To figure out why, re-run the script using the -x option:\nbash -x do-errors.sh NENE*A.txt NENE*B.txt\nWhat is the output showing you? Which line is responsible for the error?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -x option causes bash to run in debug mode. This prints out each command as it is run, which will help you to locate errors. In this example, we can see that echo isn‚Äôt printing anything. We have made a typo in the loop variable name, and the variable datfile doesn‚Äôt exist, hence returning an empty string.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nSave commands in files (usually called shell scripts) for re-use.\nbash [filename] runs the commands saved in a file.\n$@ refers to all of a shell script‚Äôs command-line arguments.\n$1, $2, etc., refer to the first command-line argument, the second command-line argument, etc.\nPlace variables in quotes if the values might have spaces in them.\nLetting users decide what files to process is more flexible and more consistent with built-in Unix commands.\n\n\n\n\n\n\n‚Üê Previous\n\n\nNext ‚Üí"
  },
  {
    "objectID": "episodes/09-awk.html",
    "href": "episodes/09-awk.html",
    "title": "AWK for Text Processing",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 20\nExercises: 5\nQuestions:\n\nHow do I print specific columns from a text table?\nHow can I use patterns to select only certain lines in a file?\nHow do I count lines or matched lines in a file?\n\nObjectives:\n\nSelect and print fields with $0, $1, $2, $NF, and NF.\nUse a field separator with -F to handle CSV input.\nMatch lines using simple regex like /^ATOM/.\nCount total or matching lines with a counter and the END block.\nExplain the difference between wc -l and awk 'END {print NR}' for line counting.\nIf we need to count the number of lines in a file, we can use the previously showed command for word counting wc\nAs you probably remember, -l is an option that asks for the number of lines only.\nHowever, wc counts the number of newlines in the file, if the last line does not contain a carriage return (i.e.¬†there is no emptyline at the end of the file), the result is going be the actual number of lines minus one.\nA workaround is to use awk. awk is command line program that takes as input a set of instructions and one or more files. The instructions are executed on each line of the input file(s).\nThe instructions are enclosed in single quotes or they can be read from a file.\nExample:\nThis command has the same output of cat: it prints each line from the example.txt file.\nThe structure of the instruction is the following: - curly braces surround the set of instructions - print is the instruction that sends its arguments to the terminal - $0 is a variable, it means ‚Äúthe content of the current line‚Äù\nAs you can see, the file contains a table.\nAwk automatically splits the processed line by looking at spaces: in our case it has knowledge of the different columns in the table.\nEach column value for the current line is stored into a variable: $1 for the first column, $2 for the second and so on.\nSo, if we like to print only the second column from the table, we execute\nWe can also print more than one value, or add text to the printed line:\nThe comma puts a space between the printed values. Strings of text should be enclosed in double quotes. In this case we are printing the text ‚Äúchr‚Äù, the second and the fourth column for each row in the table.\nSo, $0 is the whole line, $1 the first field, $2 the second and so on. What if we want to print the last column, but we don‚Äôt know its number? Maybe it is a huge table, or maybe different lines have a different number of columns.\nAwk helps us thanks to the variable NF. NF stores the number of fields (our columns) in the row. Let‚Äôs see for our table:\nWe can see that some lines contain 6 fields while others contain 7 of them. Since NF is the number of the last field, $NF contains its value.\nTo specify the field separator, we should provide it at command line like:\nIn this case, we are printing the second field in each line, using comma as separator. Please notice that the character space is now part of the field value, since it is no longer the separator."
  },
  {
    "objectID": "episodes/09-awk.html#pattern-action-model",
    "href": "episodes/09-awk.html#pattern-action-model",
    "title": "AWK for Text Processing",
    "section": "Pattern-Action Model",
    "text": "Pattern-Action Model\nAWK reads a file line by line, splits each line into fields, and then applies pattern { action } rules.\nMaybe we would like to perform different instruction on different lines. Awk allows you to specify a matching pattern, like the command grep does.\nLet‚Äôs look at the file content\nawk '{print $0}' example.pdb\nIt seems an abriged PDB file. If we would like to print only lines starting with the word ‚ÄúATOM‚Äù, we type:\nawk '/^ATOM/ {print $0}' example.pdb\nIn this case, we specify the pattern before the instructions: only lines starting with the text ‚ÄúATOM‚Äù. As you remember, ^ means ‚Äúat the beginning of the line‚Äù.\nWe can specify more that one pattern:\nawk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb\nIn this case, we are printing the spatial coordinates of each atom.\nThe special block END { ... } runs after all lines are processed. It‚Äôs ideal for printing totals collected while scanning.\nNR is the current line number. After the last line, NR equals the number of lines read:\nawk 'END { print NR }' example.txt\nThis avoids the missing final newline issue that can affect wc -l (if the last line lacks a trailing newline, wc -l may under‚Äëcount by 1).\nTo Count only matching lines, increment a counter inside the pattern, then report it in END:\nawk '/^ATOM/ { count++ } END { print \"ATOM lines:\", count+0 }' example.pdb\n\n/^ATOM/ matches lines that begin with ATOM.\ncount++ adds 1 for each match.\nIn END, we print the total. count+0 safely prints 0 if there were no matches.\n\n\n\n\n\n\n\nChallenge: Counting and Selecting (Simple)\n\n\n\nUsing only the ideas covered above (field selection, patterns, NF, and END):\n\nWrite an awk command that prints the number of lines in example.txt.\nWrite an awk command that prints the number of lines in example.pdb that start with ATOM.\nWrite an awk command that prints the last field of each ATOM line in example.pdb (just the values, one per line).\n\nBonus (optional): Print both the count of ATOM lines and, at the end, the total number of characters across all those last fields.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nTotal lines (robust):\n\nawk 'END { print NR }' example.txt\n\nCount lines starting with ATOM:\n\nawk '/^ATOM/ { c++ } END { print c+0 }' example.pdb\n\nLast field of each ATOM line:\n\nawk '/^ATOM/ { print $NF }' example.pdb\nBonus (count and accumulate character lengths of last field):\nawk '/^ATOM/ { c++; total += length($NF) } END { print \"ATOM lines:\", c+0; print \"Total chars in last field:\", total+0 }' example.pdb\nExplanation: - NR gives total lines after reading the file. - /^ATOM/ pattern restricts actions to lines starting with ATOM. - $NF is the last field; length($NF) measures its size. - Counters (c, total) are printed in END.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\n$0 is the whole line; $1..$NF are its fields; NF is the count of fields.\n-F sets the field separator (comma, tab, etc.).\nUse /pattern/ { action } to run code only on matching lines.\nIncrement a variable inside the action and print totals in END {}.\nNR gives total lines read; wc -l can undercount if last newline is missing.\n\n\n\n\n\n\n‚Üê Previous"
  },
  {
    "objectID": "slides/08-find.html",
    "href": "slides/08-find.html",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I find things in files?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse grep to select lines from text files matching patterns\nExplain ‚Äòglobal/regular expression/print‚Äô (grep origin)\nUse find to find files and directories with pattern matching\nExplain text vs binary files and why many tools don‚Äôt handle binary well\n\n\n\n\n\n‚Äúgrep‚Äù is a contraction of global/regular expression/print.\nCommon sequence in early Unix text editors.\nNow a very useful command-line program.\n\n\n\ngrep finds and prints lines in files that match a pattern.\nWorks on any text file you can think of.\n\n\n\nThree haikus from 1998 Salon magazine poetry competition:\ncat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that.\n\n\n\ngrep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nPattern: not\nResult: All lines containing the word ‚Äúnot‚Äù\n\n\n\ngrep pattern filename\n\ngrep: the command\npattern: what to search for\nfilename: which file to search in\n\nSearches line by line, outputs matching lines.\n\n\n\nSearch for ‚ÄúThe‚Äù:\ngrep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\nMatched ‚ÄúThe‚Äù at start AND ‚ÄúThe‚Äù inside ‚ÄúThesis‚Äù.\nDidn‚Äôt match lowercase ‚Äúthe‚Äù.\n\n\n\nBy default: case-sensitive\n\n‚ÄúThe‚Äù ‚â† ‚Äúthe‚Äù ‚â† ‚ÄúTHE‚Äù\nSearch pattern must match exactly\n\n\n\n\nSearching for multiple words? Use quotes:\ngrep -w \"is not\" haiku.txt\nToday it is not working\nQuotes distinguish search term from filename.\nImportant when phrase contains spaces.\n\n\n\nMatch whole words only\nWithout -w:\ngrep The haiku.txt\nMatches ‚ÄúThe‚Äù in ‚ÄúThe Tao‚Äù AND ‚Äúthe‚Äù in ‚ÄúThesis‚Äù.\nWith -w:\ngrep -w The haiku.txt\nThe Tao that is seen\nOnly ‚ÄúThe‚Äù as complete word (not part of ‚ÄúThesis‚Äù).\n\n\n\nCase-insensitive search:\ngrep -i the haiku.txt\nMatches ‚ÄúThe‚Äù, ‚Äúthe‚Äù, ‚ÄúTHE‚Äù, etc.\nThe Tao that is seen\nIs not the true Tao, until\nand the presence of absence:\n\n\n\nShow line numbers with matches:\ngrep -n \"it\" haiku.txt\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\nLines 5, 9, 10 contain ‚Äúit‚Äù.\n\n\n\nUse multiple flags together:\ngrep -n -w \"the\" haiku.txt\n2:Is not the true Tao, until\n6:and the presence of absence:\nOr shorter form: grep -nw \"the\" haiku.txt\n\n\n\nFind whole word ‚Äúthe‚Äù case-insensitive:\ngrep -n -w -i \"the\" haiku.txt\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:\n\n\n\nShow lines that DON‚ÄôT match:\ngrep -n -w -v \"the\" haiku.txt\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\nAll lines without the word ‚Äúthe‚Äù.\n\n\n\nSearch through subdirectories:\ngrep -r Yesterday .\n./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n./haiku.txt:Yesterday it worked\nSearches all files under current directory.\n\n\n\nSee all options:\ngrep --help\nShows usage, all flags, and examples.\nAlso: man grep for full documentation.\n\n\n\nSimple patterns vs complex patterns\nSearch pattern can include wildcards: - ^ = start of line - $ = end of line - . = any single character - * = previous character zero or more times\nTechnical name: regular expressions (regex)\n\n\n\nFind lines starting with specific text:\ngrep -E \"^.o\" haiku.txt\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\n\n^ = start of line\n. = any one character\no = literal letter o\n\nSo: any line with ‚Äòo‚Äô in second position.\n\n\n\nUse more powerful pattern syntax:\ngrep -E \"^The\" haiku.txt\nLines starting with ‚ÄúThe‚Äù.\ngrep -E \".aw|.ew\" haiku.txt\nLines containing ‚Äúaw‚Äù or ‚Äúew‚Äù.\n\n\n\nText files: human-readable - .txt, .csv, .py, .json, .sh\nBinary files: encoded/compiled - .pdf, .jpg, .png, .exe, .so\ngrep works on text, not binary!\n\n\n\nBinary files cause issues:\ngrep pattern document.pdf\nMay show garbage or ‚Äúbinary file matches‚Äù.\nUse -a flag to search anyway:\ngrep -a pattern document.pdf\nResults usually useless (binary format gibberish).\n\n\n\nCount matching lines instead of showing them:\ngrep -c \"not\" haiku.txt\n3\nThree lines contain ‚Äúnot‚Äù.\n\n\n\nTwo types of searching: 1. Find text in files ‚Üí use grep 2. Find files themselves ‚Üí use find\nfind searches by: name, type, size, date, permissions.\n\n\n\nfind . -type f -name \"*.txt\"\n\n. = start from current directory\n-type f = search for regular files\n-name \"*.txt\" = matching this pattern\n\nShows all .txt files under current directory.\n\n\n\nSearch by file type:\nfind . -type f        # Regular files\nfind . -type d        # Directories\nMost common types: f (file) and d (directory).\n\n\n\nSearch by filename pattern:\nfind . -name \"*.pdb\"\nAll .pdb files anywhere under current directory.\nfind . -name \"haiku*\"\nAll files starting with ‚Äúhaiku‚Äù.\n\n\n\nSearch by file size:\nfind . -type f -size +1M\nFiles larger than 1 megabyte.\nfind . -type f -size -100k\nFiles smaller than 100 kilobytes.\nUnits: k (kilobyte), M (megabyte), G (gigabyte).\n+ means ‚Äúlarger than‚Äù, - means ‚Äúsmaller than‚Äù.\n\n\n\nSearch by modification date:\nfind . -type f -mtime -7\nModified in last 7 days.\nfind . -type f -mtime -1\nModified last 24 hours.\n- means ‚Äúless than‚Äù (more recent).\n\n\n\nFind by file permissions:\nfind . -type f -perm -u=x\nRegular files owner can execute.\nfind . -type f -perm -g=w\nFiles where group has write permission.\nfind . -type f -perm -o=r\nFiles where others can read.\n- before permission means ‚Äúbits are set‚Äù.\n\n\n\nFilter by multiple criteria:\nfind . -type f -name \"*.log\" -mtime -3\nAll .log files modified in last 3 days.\nOptions work together (AND logic).\n\n\n\nProblem: Found files, now what?\nSolution: -exec to run command on each\nfind . -name \"*.pdb\" -exec grep -l \"ATOM\" {} \\;\n\n{} = the found file (placeholder)\n\\; = end of exec command\ngrep -l = show filename only if match found\n\n\n\n\nUse output of one command as input to another:\necho \"Files found: $(find . -name \"*.txt\")\"\nOutput:\nFiles found: haiku.txt notes.txt\nReplace $() with command‚Äôs output.\n\n\n\nCount all ‚ÄúATOM‚Äù lines in all PDB files:\ngrep -c \"^ATOM\" $(find . -name \"*.pdb\")\nLists count for each file:\nfile1.pdb:1523\nfile2.pdb:2104\nfile3.pdb:1876\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhich command results in this output?\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAnswer: 3 (grep -w \"of\" haiku.txt)\n-w flag searches for whole words only.\nOptions 1, 2, 4 match ‚Äúof‚Äù inside other words (like ‚Äúof‚Äù in ‚Äúpresence of absence‚Äù, ‚Äúperfect‚Äù, etc.).\nOnly -w ensures ‚Äúof‚Äù stands alone.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nLeah has hundreds of data files on species sightings:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nShe wants a script taking: - Species name (argument 1) - Directory (argument 2)\nOutput: File &lt;species&gt;.txt with dates and counts:\n2012-11-05,22\n2012-11-06,19\n2012-11-07,16\nArrange these in correct order:\ncut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\nHint: Use man grep for recursive search, man cut for multiple fields.\nExample: shell-lesson-data/exercise-data/animal-counts/animals.csv\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ngrep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\nHow it works:\n\ngrep -w $1 -r $2 = find species name in all files under directory\ncut -d : -f 2 = extract filename and data (remove grep‚Äôs first field)\ncut -d , -f 1,3 = extract date (field 1) and count (field 3)\n&gt; $1.txt = save to output file\n\nTwo cut commands can be swapped - same result!\nUsage example:\nbash count-species.sh bear .\nThis creates file bear.txt with all bear sightings.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nYou‚Äôve finished reading Little Women by Louisa May Alcott.\nArgument with friend: Which sister mentioned most? - Jo, Meg, Beth, or Amy?\nFile available: shell-lesson-data/exercise-data/writing/LittleWomen.txt\nUsing a for loop, tabulate mentions of each sister.\nHint: Combine grep and wc with |, or use grep options.\nMultiple solutions exist - choose for correctness, elegance, readability, and speed.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nSolution 1: Using pipe with wc\nfor sis in Jo Meg Beth Amy\ndo\n    grep -ow $sis LittleWomen.txt | wc -l\ndone\nOutput shows count for each sister.\nSolution 2: Using grep -c option\nfor sis in Jo Meg Beth Amy\ndo\n    grep -ocw $sis LittleWomen.txt\ndone\nFlags explained: - -o = show matches only - -c = count them - -w = whole words only\nBoth count sister mentions correctly!\n\n\n\n\n\n\nls and find can be made to do similar things given the right options, but under normal circumstances:\n\nls lists everything it can\nfind searches for things with certain properties and shows them\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nThe -v option to grep inverts pattern matching, so that only lines which do not match the pattern are printed.\nGiven that, which of the following commands will find all .dat files in creatures except unicorn.dat?\n\nfind creatures -name \"*.dat\" | grep -v unicorn\nfind creatures -name *.dat | grep -v unicorn\ngrep -v \"unicorn\" $(find creatures -name \"*.dat\")\nNone of the above\n\nOnce you have thought about your answer, you can test the commands in the shell-lesson-data/exercise-data directory.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct: find creatures -name \"*.dat\" | grep -v unicorn\nPutting the match expression in quotes prevents the shell expanding it, so it gets passed to the find command.\nOption 2 also works in this instance because the shell tries to expand *.dat but there are no *.dat files in the current directory, so the wildcard expression gets passed to find.\nOption 3 is incorrect because it searches the contents of the files for lines which do not match ‚Äòunicorn‚Äô, rather than searching the file names.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWrite a short explanatory comment for the following shell script:\nwc -l $(find . -name \"*.dat\") | sort -n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nFind all files with a .dat extension recursively from the current directory\nCount the number of lines each of these files contains\nSort the output from step 2. numerically\n\n\n\n\n\n\n\nWe have focused exclusively on finding patterns in text files. What if your data is stored as images, in databases, or in some other format?\nA handful of tools extend grep to handle a few non-text formats. But a more generalizable approach is to convert the data to text or extract the text-like elements from the data.\nOn one hand, it makes simple things easy to do. On the other hand, complex things are usually impossible. For example: - Easy: Write a program that extracts X and Y dimensions from image files for grep to use - Hard: Find values in a spreadsheet whose cells contained formulas\nA last option: recognize that the shell and text processing have their limits, and use another programming language.\nMany modern programming languages have borrowed ideas from the shell, and imitation is the sincerest form of praise."
  },
  {
    "objectID": "slides/08-find.html#why-grep",
    "href": "slides/08-find.html#why-grep",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "‚Äúgrep‚Äù is a contraction of global/regular expression/print.\nCommon sequence in early Unix text editors.\nNow a very useful command-line program."
  },
  {
    "objectID": "slides/08-find.html#what-grep-does",
    "href": "slides/08-find.html#what-grep-does",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "grep finds and prints lines in files that match a pattern.\nWorks on any text file you can think of."
  },
  {
    "objectID": "slides/08-find.html#sample-haiku-file",
    "href": "slides/08-find.html#sample-haiku-file",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Three haikus from 1998 Salon magazine poetry competition:\ncat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that."
  },
  {
    "objectID": "slides/08-find.html#finding-lines-with-not",
    "href": "slides/08-find.html#finding-lines-with-not",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "grep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nPattern: not\nResult: All lines containing the word ‚Äúnot‚Äù"
  },
  {
    "objectID": "slides/08-find.html#understanding-grep-syntax",
    "href": "slides/08-find.html#understanding-grep-syntax",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "grep pattern filename\n\ngrep: the command\npattern: what to search for\nfilename: which file to search in\n\nSearches line by line, outputs matching lines."
  },
  {
    "objectID": "slides/08-find.html#grep-is-case-sensitive",
    "href": "slides/08-find.html#grep-is-case-sensitive",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Search for ‚ÄúThe‚Äù:\ngrep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\nMatched ‚ÄúThe‚Äù at start AND ‚ÄúThe‚Äù inside ‚ÄúThesis‚Äù.\nDidn‚Äôt match lowercase ‚Äúthe‚Äù."
  },
  {
    "objectID": "slides/08-find.html#case-matters",
    "href": "slides/08-find.html#case-matters",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "By default: case-sensitive\n\n‚ÄúThe‚Äù ‚â† ‚Äúthe‚Äù ‚â† ‚ÄúTHE‚Äù\nSearch pattern must match exactly"
  },
  {
    "objectID": "slides/08-find.html#searching-phrases",
    "href": "slides/08-find.html#searching-phrases",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Searching for multiple words? Use quotes:\ngrep -w \"is not\" haiku.txt\nToday it is not working\nQuotes distinguish search term from filename.\nImportant when phrase contains spaces."
  },
  {
    "objectID": "slides/08-find.html#option--w-word-boundaries",
    "href": "slides/08-find.html#option--w-word-boundaries",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Match whole words only\nWithout -w:\ngrep The haiku.txt\nMatches ‚ÄúThe‚Äù in ‚ÄúThe Tao‚Äù AND ‚Äúthe‚Äù in ‚ÄúThesis‚Äù.\nWith -w:\ngrep -w The haiku.txt\nThe Tao that is seen\nOnly ‚ÄúThe‚Äù as complete word (not part of ‚ÄúThesis‚Äù)."
  },
  {
    "objectID": "slides/08-find.html#option--i-ignore-case",
    "href": "slides/08-find.html#option--i-ignore-case",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Case-insensitive search:\ngrep -i the haiku.txt\nMatches ‚ÄúThe‚Äù, ‚Äúthe‚Äù, ‚ÄúTHE‚Äù, etc.\nThe Tao that is seen\nIs not the true Tao, until\nand the presence of absence:"
  },
  {
    "objectID": "slides/08-find.html#option--n-line-numbers",
    "href": "slides/08-find.html#option--n-line-numbers",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Show line numbers with matches:\ngrep -n \"it\" haiku.txt\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\nLines 5, 9, 10 contain ‚Äúit‚Äù."
  },
  {
    "objectID": "slides/08-find.html#combining-options",
    "href": "slides/08-find.html#combining-options",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Use multiple flags together:\ngrep -n -w \"the\" haiku.txt\n2:Is not the true Tao, until\n6:and the presence of absence:\nOr shorter form: grep -nw \"the\" haiku.txt"
  },
  {
    "objectID": "slides/08-find.html#more-option-combinations",
    "href": "slides/08-find.html#more-option-combinations",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Find whole word ‚Äúthe‚Äù case-insensitive:\ngrep -n -w -i \"the\" haiku.txt\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:"
  },
  {
    "objectID": "slides/08-find.html#option--v-invert-match",
    "href": "slides/08-find.html#option--v-invert-match",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Show lines that DON‚ÄôT match:\ngrep -n -w -v \"the\" haiku.txt\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\nAll lines without the word ‚Äúthe‚Äù."
  },
  {
    "objectID": "slides/08-find.html#option--r-recursive",
    "href": "slides/08-find.html#option--r-recursive",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Search through subdirectories:\ngrep -r Yesterday .\n./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n./haiku.txt:Yesterday it worked\nSearches all files under current directory."
  },
  {
    "objectID": "slides/08-find.html#getting-help-with-grep",
    "href": "slides/08-find.html#getting-help-with-grep",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "See all options:\ngrep --help\nShows usage, all flags, and examples.\nAlso: man grep for full documentation."
  },
  {
    "objectID": "slides/08-find.html#wildcards-and-regular-expressions",
    "href": "slides/08-find.html#wildcards-and-regular-expressions",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Simple patterns vs complex patterns\nSearch pattern can include wildcards: - ^ = start of line - $ = end of line - . = any single character - * = previous character zero or more times\nTechnical name: regular expressions (regex)"
  },
  {
    "objectID": "slides/08-find.html#regex-start-of-line",
    "href": "slides/08-find.html#regex-start-of-line",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Find lines starting with specific text:\ngrep -E \"^.o\" haiku.txt\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\n\n^ = start of line\n. = any one character\no = literal letter o\n\nSo: any line with ‚Äòo‚Äô in second position."
  },
  {
    "objectID": "slides/08-find.html#option--e-extended-regex",
    "href": "slides/08-find.html#option--e-extended-regex",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Use more powerful pattern syntax:\ngrep -E \"^The\" haiku.txt\nLines starting with ‚ÄúThe‚Äù.\ngrep -E \".aw|.ew\" haiku.txt\nLines containing ‚Äúaw‚Äù or ‚Äúew‚Äù."
  },
  {
    "objectID": "slides/08-find.html#text-vs-binary-files",
    "href": "slides/08-find.html#text-vs-binary-files",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Text files: human-readable - .txt, .csv, .py, .json, .sh\nBinary files: encoded/compiled - .pdf, .jpg, .png, .exe, .so\ngrep works on text, not binary!"
  },
  {
    "objectID": "slides/08-find.html#using-grep-on-binary",
    "href": "slides/08-find.html#using-grep-on-binary",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Binary files cause issues:\ngrep pattern document.pdf\nMay show garbage or ‚Äúbinary file matches‚Äù.\nUse -a flag to search anyway:\ngrep -a pattern document.pdf\nResults usually useless (binary format gibberish)."
  },
  {
    "objectID": "slides/08-find.html#option--c-count-matches",
    "href": "slides/08-find.html#option--c-count-matches",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Count matching lines instead of showing them:\ngrep -c \"not\" haiku.txt\n3\nThree lines contain ‚Äúnot‚Äù."
  },
  {
    "objectID": "slides/08-find.html#finding-files-with-find",
    "href": "slides/08-find.html#finding-files-with-find",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Two types of searching: 1. Find text in files ‚Üí use grep 2. Find files themselves ‚Üí use find\nfind searches by: name, type, size, date, permissions."
  },
  {
    "objectID": "slides/08-find.html#find-basic-syntax",
    "href": "slides/08-find.html#find-basic-syntax",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "find . -type f -name \"*.txt\"\n\n. = start from current directory\n-type f = search for regular files\n-name \"*.txt\" = matching this pattern\n\nShows all .txt files under current directory."
  },
  {
    "objectID": "slides/08-find.html#option--type",
    "href": "slides/08-find.html#option--type",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Search by file type:\nfind . -type f        # Regular files\nfind . -type d        # Directories\nMost common types: f (file) and d (directory)."
  },
  {
    "objectID": "slides/08-find.html#option--name",
    "href": "slides/08-find.html#option--name",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Search by filename pattern:\nfind . -name \"*.pdb\"\nAll .pdb files anywhere under current directory.\nfind . -name \"haiku*\"\nAll files starting with ‚Äúhaiku‚Äù."
  },
  {
    "objectID": "slides/08-find.html#option--size",
    "href": "slides/08-find.html#option--size",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Search by file size:\nfind . -type f -size +1M\nFiles larger than 1 megabyte.\nfind . -type f -size -100k\nFiles smaller than 100 kilobytes.\nUnits: k (kilobyte), M (megabyte), G (gigabyte).\n+ means ‚Äúlarger than‚Äù, - means ‚Äúsmaller than‚Äù."
  },
  {
    "objectID": "slides/08-find.html#option--mtime",
    "href": "slides/08-find.html#option--mtime",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Search by modification date:\nfind . -type f -mtime -7\nModified in last 7 days.\nfind . -type f -mtime -1\nModified last 24 hours.\n- means ‚Äúless than‚Äù (more recent)."
  },
  {
    "objectID": "slides/08-find.html#option--perm-permissions",
    "href": "slides/08-find.html#option--perm-permissions",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Find by file permissions:\nfind . -type f -perm -u=x\nRegular files owner can execute.\nfind . -type f -perm -g=w\nFiles where group has write permission.\nfind . -type f -perm -o=r\nFiles where others can read.\n- before permission means ‚Äúbits are set‚Äù."
  },
  {
    "objectID": "slides/08-find.html#combining-find-options",
    "href": "slides/08-find.html#combining-find-options",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Filter by multiple criteria:\nfind . -type f -name \"*.log\" -mtime -3\nAll .log files modified in last 3 days.\nOptions work together (AND logic)."
  },
  {
    "objectID": "slides/08-find.html#using-find-output-with-other-commands",
    "href": "slides/08-find.html#using-find-output-with-other-commands",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Problem: Found files, now what?\nSolution: -exec to run command on each\nfind . -name \"*.pdb\" -exec grep -l \"ATOM\" {} \\;\n\n{} = the found file (placeholder)\n\\; = end of exec command\ngrep -l = show filename only if match found"
  },
  {
    "objectID": "slides/08-find.html#command-substitution",
    "href": "slides/08-find.html#command-substitution",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Use output of one command as input to another:\necho \"Files found: $(find . -name \"*.txt\")\"\nOutput:\nFiles found: haiku.txt notes.txt\nReplace $() with command‚Äôs output."
  },
  {
    "objectID": "slides/08-find.html#practical-example",
    "href": "slides/08-find.html#practical-example",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Count all ‚ÄúATOM‚Äù lines in all PDB files:\ngrep -c \"^ATOM\" $(find . -name \"*.pdb\")\nLists count for each file:\nfile1.pdb:1523\nfile2.pdb:2104\nfile3.pdb:1876"
  },
  {
    "objectID": "slides/08-find.html#challenge-using-grep",
    "href": "slides/08-find.html#challenge-using-grep",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Challenge\n\n\n\nWhich command results in this output?\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt"
  },
  {
    "objectID": "slides/08-find.html#solution-using-grep",
    "href": "slides/08-find.html#solution-using-grep",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Solution\n\n\n\n\n\nAnswer: 3 (grep -w \"of\" haiku.txt)\n-w flag searches for whole words only.\nOptions 1, 2, 4 match ‚Äúof‚Äù inside other words (like ‚Äúof‚Äù in ‚Äúpresence of absence‚Äù, ‚Äúperfect‚Äù, etc.).\nOnly -w ensures ‚Äúof‚Äù stands alone."
  },
  {
    "objectID": "slides/08-find.html#challenge-tracking-a-species",
    "href": "slides/08-find.html#challenge-tracking-a-species",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Challenge\n\n\n\nLeah has hundreds of data files on species sightings:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nShe wants a script taking: - Species name (argument 1) - Directory (argument 2)\nOutput: File &lt;species&gt;.txt with dates and counts:\n2012-11-05,22\n2012-11-06,19\n2012-11-07,16\nArrange these in correct order:\ncut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\nHint: Use man grep for recursive search, man cut for multiple fields.\nExample: shell-lesson-data/exercise-data/animal-counts/animals.csv"
  },
  {
    "objectID": "slides/08-find.html#solution-tracking-a-species",
    "href": "slides/08-find.html#solution-tracking-a-species",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Solution\n\n\n\n\n\ngrep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\nHow it works:\n\ngrep -w $1 -r $2 = find species name in all files under directory\ncut -d : -f 2 = extract filename and data (remove grep‚Äôs first field)\ncut -d , -f 1,3 = extract date (field 1) and count (field 3)\n&gt; $1.txt = save to output file\n\nTwo cut commands can be swapped - same result!\nUsage example:\nbash count-species.sh bear .\nThis creates file bear.txt with all bear sightings."
  },
  {
    "objectID": "slides/08-find.html#challenge-little-women",
    "href": "slides/08-find.html#challenge-little-women",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Challenge\n\n\n\nYou‚Äôve finished reading Little Women by Louisa May Alcott.\nArgument with friend: Which sister mentioned most? - Jo, Meg, Beth, or Amy?\nFile available: shell-lesson-data/exercise-data/writing/LittleWomen.txt\nUsing a for loop, tabulate mentions of each sister.\nHint: Combine grep and wc with |, or use grep options.\nMultiple solutions exist - choose for correctness, elegance, readability, and speed."
  },
  {
    "objectID": "slides/08-find.html#solution-little-women",
    "href": "slides/08-find.html#solution-little-women",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Solution\n\n\n\n\n\nSolution 1: Using pipe with wc\nfor sis in Jo Meg Beth Amy\ndo\n    grep -ow $sis LittleWomen.txt | wc -l\ndone\nOutput shows count for each sister.\nSolution 2: Using grep -c option\nfor sis in Jo Meg Beth Amy\ndo\n    grep -ocw $sis LittleWomen.txt\ndone\nFlags explained: - -o = show matches only - -c = count them - -w = whole words only\nBoth count sister mentions correctly!"
  },
  {
    "objectID": "slides/08-find.html#listing-vs.-finding",
    "href": "slides/08-find.html#listing-vs.-finding",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "ls and find can be made to do similar things given the right options, but under normal circumstances:\n\nls lists everything it can\nfind searches for things with certain properties and shows them"
  },
  {
    "objectID": "slides/08-find.html#challenge-matching-and-subtracting",
    "href": "slides/08-find.html#challenge-matching-and-subtracting",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Challenge\n\n\n\nThe -v option to grep inverts pattern matching, so that only lines which do not match the pattern are printed.\nGiven that, which of the following commands will find all .dat files in creatures except unicorn.dat?\n\nfind creatures -name \"*.dat\" | grep -v unicorn\nfind creatures -name *.dat | grep -v unicorn\ngrep -v \"unicorn\" $(find creatures -name \"*.dat\")\nNone of the above\n\nOnce you have thought about your answer, you can test the commands in the shell-lesson-data/exercise-data directory."
  },
  {
    "objectID": "slides/08-find.html#solution-matching-and-subtracting",
    "href": "slides/08-find.html#solution-matching-and-subtracting",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 1 is correct: find creatures -name \"*.dat\" | grep -v unicorn\nPutting the match expression in quotes prevents the shell expanding it, so it gets passed to the find command.\nOption 2 also works in this instance because the shell tries to expand *.dat but there are no *.dat files in the current directory, so the wildcard expression gets passed to find.\nOption 3 is incorrect because it searches the contents of the files for lines which do not match ‚Äòunicorn‚Äô, rather than searching the file names."
  },
  {
    "objectID": "slides/08-find.html#challenge-find-pipeline-reading-comprehension",
    "href": "slides/08-find.html#challenge-find-pipeline-reading-comprehension",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Challenge\n\n\n\nWrite a short explanatory comment for the following shell script:\nwc -l $(find . -name \"*.dat\") | sort -n"
  },
  {
    "objectID": "slides/08-find.html#solution-find-pipeline-reading-comprehension",
    "href": "slides/08-find.html#solution-find-pipeline-reading-comprehension",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nFind all files with a .dat extension recursively from the current directory\nCount the number of lines each of these files contains\nSort the output from step 2. numerically"
  },
  {
    "objectID": "slides/08-find.html#binary-files",
    "href": "slides/08-find.html#binary-files",
    "title": "Episode 8: Finding Things",
    "section": "",
    "text": "We have focused exclusively on finding patterns in text files. What if your data is stored as images, in databases, or in some other format?\nA handful of tools extend grep to handle a few non-text formats. But a more generalizable approach is to convert the data to text or extract the text-like elements from the data.\nOn one hand, it makes simple things easy to do. On the other hand, complex things are usually impossible. For example: - Easy: Write a program that extracts X and Y dimensions from image files for grep to use - Hard: Find values in a spreadsheet whose cells contained formulas\nA last option: recognize that the shell and text processing have their limits, and use another programming language.\nMany modern programming languages have borrowed ideas from the shell, and imitation is the sincerest form of praise."
  },
  {
    "objectID": "slides/01-intro.html",
    "href": "slides/01-intro.html",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Questions\n\n\n\n\nWhat is a command shell and why would I use one?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users‚Äô programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces.\n\n\n\n\n\n\n\nImagine: Copy the 3rd line from 1,000 text files across 1,000 folders into one file.\n\nUsing a GUI:\n\nHours of clicking\nHigh chance of error\nRepetitive and tedious\n\n\n\nUsing the Shell:\n\nA few commands\nRepeatable\nFast and accurate (seconds!)\n\n\n\n\n\n\n\n\nA program that reads commands you type\nA command-line interface (CLI) - text-based\nAlso a scripting language for automation\nAllows combining simple programs into powerful workflows\nThe default way to interact with servers and supercomputers\n\n\n\n\n\nBash = Bourne Again SHell\n\n\nMost popular Unix shell\nDefault on macOS, Linux, and Windows (via Git Bash)\nThe standard for shell scripting\nSmall number of ‚Äúwords‚Äù (commands) gets you far!\n\n\n\n\n\nWhen you open the shell, you see:\n$\nor\n%\nThe prompt indicates the shell is waiting for input.\n\n\n\n\n\n\nNote\n\n\n\nYour prompt might look different:\nnelle@localhost $\nor even:\nuser@computer:~$\nThis shows your username and computer name.\n\n\n\n\n\n\n\nType a command after the $/%\nPress Enter to execute\nResults appear below\nNever type the $/% - it‚Äôs just the prompt!\n\n\n\n\n\n\n\nls is short for listing.\nThis command will list the contents of the current directory:\n\n\nls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can‚Äôt find a program whose name is the command you typed, it will print an error message such as:\nks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n\n\n\n\n\n\n\nNelle Nemo, a marine biologist, has:\n\nüåä Returned from a 6-month North Pacific Gyre survey\nüß´ Collected 1520 samples\nüß¨ Measured 300 proteins per sample\nüíª Needs to process all files using goostats.sh\nüìù Must submit her paper by the end of the month\n\n\n\n\n\n\n\nIf Nelle runs goostats.sh manually (GUI):\n\nOpen & process 1520 files\n‚è± 30 seconds per file\nüïí 12+ hours of manual work\n‚ùå Time lost that could be spent writing her paper\n\n\n\n\n\n\n\nWith a command shell, Nelle can:\n\nAutomate repetitive processing\nUse loops to iterate over files\nRun the pipeline once and reuse it\nLet the computer work while she writes\n\n\n\n\n\n\n\nTo build her pipeline, she must know how to:\n\nNavigate to a file/directory\nCreate a file/directory\nCheck the length of a file\nChain commands together\nRetrieve a set of files\nIterate over files\nRun a shell script containing her pipeline"
  },
  {
    "objectID": "slides/01-intro.html#why-use-the-shell",
    "href": "slides/01-intro.html#why-use-the-shell",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Imagine: Copy the 3rd line from 1,000 text files across 1,000 folders into one file.\n\nUsing a GUI:\n\nHours of clicking\nHigh chance of error\nRepetitive and tedious\n\n\n\nUsing the Shell:\n\nA few commands\nRepeatable\nFast and accurate (seconds!)"
  },
  {
    "objectID": "slides/01-intro.html#what-is-the-shell",
    "href": "slides/01-intro.html#what-is-the-shell",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "A program that reads commands you type\nA command-line interface (CLI) - text-based\nAlso a scripting language for automation\nAllows combining simple programs into powerful workflows\nThe default way to interact with servers and supercomputers"
  },
  {
    "objectID": "slides/01-intro.html#bash-the-shell-were-using",
    "href": "slides/01-intro.html#bash-the-shell-were-using",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Bash = Bourne Again SHell\n\n\nMost popular Unix shell\nDefault on macOS, Linux, and Windows (via Git Bash)\nThe standard for shell scripting\nSmall number of ‚Äúwords‚Äù (commands) gets you far!"
  },
  {
    "objectID": "slides/01-intro.html#the-prompt",
    "href": "slides/01-intro.html#the-prompt",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "When you open the shell, you see:\n$\nor\n%\nThe prompt indicates the shell is waiting for input.\n\n\n\n\n\n\nNote\n\n\n\nYour prompt might look different:\nnelle@localhost $\nor even:\nuser@computer:~$\nThis shows your username and computer name."
  },
  {
    "objectID": "slides/01-intro.html#typing-commands",
    "href": "slides/01-intro.html#typing-commands",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Type a command after the $/%\nPress Enter to execute\nResults appear below\nNever type the $/% - it‚Äôs just the prompt!"
  },
  {
    "objectID": "slides/01-intro.html#example-your-first-command",
    "href": "slides/01-intro.html#example-your-first-command",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "ls is short for listing.\nThis command will list the contents of the current directory:\n\n\nls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can‚Äôt find a program whose name is the command you typed, it will print an error message such as:\nks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed."
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Nelle Nemo, a marine biologist, has:\n\nüåä Returned from a 6-month North Pacific Gyre survey\nüß´ Collected 1520 samples\nüß¨ Measured 300 proteins per sample\nüíª Needs to process all files using goostats.sh\nüìù Must submit her paper by the end of the month"
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem-1",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem-1",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "If Nelle runs goostats.sh manually (GUI):\n\nOpen & process 1520 files\n‚è± 30 seconds per file\nüïí 12+ hours of manual work\n‚ùå Time lost that could be spent writing her paper"
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem-2",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem-2",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "With a command shell, Nelle can:\n\nAutomate repetitive processing\nUse loops to iterate over files\nRun the pipeline once and reuse it\nLet the computer work while she writes"
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem-3",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem-3",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "To build her pipeline, she must know how to:\n\nNavigate to a file/directory\nCreate a file/directory\nCheck the length of a file\nChain commands together\nRetrieve a set of files\nIterate over files\nRun a shell script containing her pipeline"
  },
  {
    "objectID": "slides/06-loop.html",
    "href": "slides/06-loop.html",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I perform the same actions on many different files?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nWrite a loop that applies one or more commands to each file in a set\nTrace loop variable values during execution\nExplain difference between variable name and value\nExplain why spaces and special characters shouldn‚Äôt be in filenames\nDemonstrate how to view recently executed commands\nRe-run recently executed commands without retyping\n\n\n\n\n\nLoops are a programming construct which allow us to repeat a command or set of commands for each item in a list.\nAs such they are key to productivity improvements through automation.\nSimilar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes).\n\n\n\n# The word \"for\" indicates the start of a \"For-loop\" command\nfor thing in list_of_things\n# The word \"do\" indicates the start of job execution list\ndo\n    # Execute command(s) using the variable\n    operation_using/command $thing\n# The word \"done\" indicates the end of a loop\ndone\nThree keywords: for, do, done\n\n\n\nSuppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat.\nFor this example, we‚Äôll use the exercise-data/creatures directory which only has three example files, but the principles can be applied to many many more files at once.\nThe structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines.\n\n\n\nLet‚Äôs look at the files:\nhead -n 5 basilisk.dat minotaur.dat unicorn.dat\nWe would like to print out the classification for each species, which is given on the second line of each file.\nFor each file, we would need to execute the command head -n 2 and pipe this to tail -n 1.\n\n\n\nWe‚Äôll use a loop to solve this problem, but first let‚Äôs look at the general form of a loop:\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    echo $filename\ndone\nbasilisk.dat\nminotaur.dat\nunicorn.dat\n\n\n\nWhen typing a loop, shell prompt changes:\n$ for filename in basilisk.dat minotaur.dat unicorn.dat\n&gt; do\n&gt;     echo $filename\n&gt; done\nThe &gt; prompt reminds you the command isn‚Äôt complete yet.\nA semicolon ; can separate commands on one line.\n\n\n\n\nShell prints &gt; or $: it‚Äôs a prompt (expects input)\nYou type &gt; or $: it‚Äôs an instruction (redirect or variable)\n\nContext matters!\n\n\n\nEach time loop runs, variable holds next value:\n\nFirst: $filename = basilisk.dat\nSecond: $filename = minotaur.dat\nThird: $filename = unicorn.dat\n\nThen shell exits loop (no more items).\n\n\n\nUse $varname to access the value.\nThe $ tells shell: treat this as a variable, not literal text.\nReplace with actual value before executing command.\n\n\n\nGet classification line from creature files:\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    echo $filename\n    head -n 2 $filename | tail -n 1\ndone\nbasilisk.dat\nCLASSIFICATION: basiliscus vulgaris\nminotaur.dat\nCLASSIFICATION: bos hominus\nunicorn.dat\nCLASSIFICATION: equus monoceros\n\n\n\nVariable name: filename (the name)\nVariable value: basilisk.dat (the data)\nUse $filename to get the value, not the name.\n\n\n\nTwo syntaxes:\necho $filename      # Simple\necho ${filename}    # With braces (clearer)\nBraces useful when variable next to text:\necho ${filename}.bak    # Shows: basilisk.dat.bak\necho $filename.bak      # Looks for variable \"filename.bak\"!\n\n\n\n\nUse meaningful names: filename, not x\nHelps others (and future you) understand code\nIncreases odds people interpret it correctly\n\nThe shell doesn‚Äôt care‚Äîonly we do!\n\n\n\nLoops work with any list, not just filenames:\nfor number in 0 1 2 3 4 5\ndo\n    echo $number\ndone\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow would you write a loop that echoes all 10 numbers from 0 to 9?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nfor loop_variable in 0 1 2 3 4 5 6 7 8 9\ndo\n    echo $loop_variable\ndone\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nAlternatively, try replacing the enumeration of integers 0 1 2 3 4 5 6 7 8 9 by {0..9} to obtain an identical output.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, ls *.pdb gives:\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\nFirst code:\nfor datafile in *.pdb\ndo\n    ls *.pdb\ndone\nSecond code:\nfor datafile in *.pdb\ndo\n    ls $datafile\ndone\nWhat‚Äôs the difference?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirst code: lists ALL .pdb files each iteration (6 times total).\nShell expands *.pdb in loop body for each iteration.\nSecond code: lists ONE file per iteration (6 different files).\nVariable $datafile evaluates to current file each time.\nSecond code is cleaner and what we usually want!\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop output?\nfor filename in c*\ndo\n    ls $filename\ndone\n\nNo files listed\nAll files are listed\nOnly cubane.pdb, octane.pdb, pentane.pdb\nOnly cubane.pdb\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is correct.\n* matches zero or more characters.\nc* matches any filename starting with ‚Äòc‚Äô (only cubane.pdb).\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow different is this loop?\nfor filename in *c*\ndo\n    ls $filename\ndone\n\nSame files listed\nAll files are listed now\nNo files listed now\ncubane.pdb and octane.pdb\nOnly octane.pdb\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is correct.\n*c* matches filename with ‚Äòc‚Äô anywhere in name (before or after).\nMatches: cubane.pdb (c at start) and octane.pdb (c in middle).\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop do?\nfor alkanes in *.pdb\ndo\n    echo $alkanes\n    cat $alkanes &gt; alkanes.pdb\ndone\n\nPrints all 6 files; only propane.pdb saved to alkanes.pdb\nPrints 3 files; all concatenated and saved to alkanes.pdb\nPrints 5 files; only propane.pdb saved to alkanes.pdb\nNone of the above\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct.\nEach iteration: &gt; overwrites (not appends).\nLast file processed (propane.pdb) is final content.\nUse &gt;&gt; to append instead!\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop do?\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\n\nAll files up to pentane.pdb concatenated\nOnly ethane.pdb saved\nAll 6 files concatenated to all.pdb\nAll 5 files concatenated\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct.\n&gt;&gt; appends each file (doesn‚Äôt overwrite).\nAll 6 files concatenated to all.pdb.\nNothing printed (output redirected to file).\n\n\n\n\n\n\nIn shell-lesson-data/exercise-data/creatures:\nfor filename in *.dat\ndo\n    echo $filename\n    head -n 100 $filename | tail -n 20\ndone\nLoop body: two commands - Echo filename - Select lines 81-100 (or all if fewer than 100)\n\n\n\nShell uses spaces to separate items!\nFilenames with spaces: red dragon.dat, purple unicorn.dat\nMust quote them:\nfor filename in \"red dragon.dat\" \"purple unicorn.dat\"\ndo\n    head -n 100 \"$filename\" | tail -n 20\ndone\nAlways quote variables to be safe: \"$filename\"\nIt is simpler to avoid using spaces (or other special characters) in filenames.\n\n\n\nThe files red dragon.dat and purple unicorn.dat don‚Äôt exist, so if we run the code without quotes around $filename, we get errors:\nhead: cannot open 'red' for reading: No such file or directory\nhead: cannot open 'dragon.dat' for reading: No such file or directory\nhead: cannot open 'purple' for reading: No such file or directory\nWith quotes, we‚Äôd see:\nhead: cannot open 'red dragon.dat' for reading: No such file or directory\nhead: cannot open 'purple unicorn.dat' for reading: No such file or directory\n\n\n\nWithout quotes: - Shell splits by spaces - \"red dragon.dat\" becomes two items: red, dragon.dat - Commands fail\nWith quotes: - Treated as single item - Commands work correctly\nBest practice: Avoid spaces in filenames entirely (use - or _).\n\n\n\nProblem: Copy all .dat files to original- versions.\nCan‚Äôt do this:\ncp *.dat original-*.dat  # ERROR!\nExpands to: cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\nShell sees 4 arguments, expects last to be directory!\n\n\n\nfor filename in *.dat\ndo\n    cp $filename original-$filename\ndone\nEach iteration: - $filename = basilisk.dat ‚Üí cp basilisk.dat original-basilisk.dat - $filename = minotaur.dat ‚Üí cp minotaur.dat original-minotaur.dat - $filename = unicorn.dat ‚Üí cp unicorn.dat original-unicorn.dat\n\n\n\nHard to verify loop did what you want (no output from cp).\nSolution: Use echo to print commands without executing:\nfor filename in *.dat\ndo\n    echo cp $filename original-$filename\ndone\nSee what would run, verify correctness, then remove echo!\nThe judicious use of echo is a good debugging technique.\n\n\n\nThe following diagram shows what happens when the modified loop is executed, and demonstrates how the judicious use of echo is a good debugging technique.\n\n\n\n\nNelle is now ready to process her data files using goostats.sh ‚Äî a shell script written by her supervisor.\nThis calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince she‚Äôs still learning how to use the shell, she decides to build up the required commands in stages.\n\n\n\nHer first step is to make sure that she can select the right input files ‚Äî remember, these are ones whose names end in ‚ÄòA‚Äô or ‚ÄòB‚Äô, rather than ‚ÄòZ‚Äô.\nMoving to the north-pacific-gyre directory, Nelle types:\ncd\ncd Desktop/shell-lesson-data/north-pacific-gyre\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\ndone\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\nNENE02040B.txt\nNENE02043B.txt\nGood! Selects correct files.\n\n\n\nHer next step is to decide what to call the files that the goostats.sh analysis program will create.\nPrefixing each input file‚Äôs name with ‚Äòstats‚Äô seems simple, so she modifies her loop:\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile stats-$datafile\ndone\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01736A.txt\nNENE01751A.txt stats-NENE01751A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nPerfect! Ready to process.\nShe hasn‚Äôt actually run goostats.sh yet, but now she‚Äôs sure she can select the right files and generate the right output filenames.\n\n\n\nTyping same command repeatedly is tedious!\nShell remembers recent commands.\nView history:\nhistory\nShows numbered list of previous commands.\n\n\n\n\n\n\nMethod\nWhat it does\n\n\n\n\n‚Üë\nPrevious command\n\n\n‚Üì\nNext command\n\n\n!42\nRun command #42\n\n\nCtrl-R\nSearch history\n\n\n\n\n\n\nPress Up arrow:\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nEntire loop on one line using semicolons ;\nSame as multi-line version!\n\n\n\n\n\n\n\n\n\nBeginning and End\n\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E.\n\n\n\n\n\n\n\n\n\n\n\nThose Who Know History Can Choose to Repeat It\n\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where 123 is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:\nhistory | tail -n 5\n  456  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n  457  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n  458  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; done\n  459  cd ..\n  460  history | tail -n 5\nthen she can re-run bash goostats.sh on all her files by typing !457.\n\n\n\n\n\n\n\n\n\n\n\nOther history Commands\n\n\n\nThere are a number of other shortcut commands for getting at the history:\n\nCtrl+R enters a history search mode ‚Äòreverse-i-search‚Äô and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ‚Üë)\n!$ retrieves the last word of the last command. That‚Äôs useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ‚Üë and editing the command-line.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nA loop is a way to do many things at once ‚Äî or to make many mistakes at once if it does the wrong thing. One way to check what a loop would do is to echo the commands it would run instead of actually running them.\nSuppose we want to preview the commands the following loop will execute without actually running those commands:\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\nWhat is the difference between the two loops below, and which one would we want to run?\n# Version 1\nfor datafile in *.pdb\ndo\n    echo cat $datafile &gt;&gt; all.pdb\ndone\n# Version 2\nfor datafile in *.pdb\ndo\n    echo \"cat $datafile &gt;&gt; all.pdb\"\ndone\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also does not modify nor create the file all.pdb, as the &gt;&gt; is treated literally as part of a string rather than as a redirection instruction.\nThe first version appends the output from the command echo cat $datafile to the file, all.pdb. This file will just contain the list; cat cubane.pdb, cat ethane.pdb, cat methane.pdb etc.\nTry both versions for yourself to see the output! Be sure to open the all.pdb file to view its contents.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nSuppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds and different temperatures. What would be the result of the following code:\nfor species in cubane ethane methane\ndo\n    for temperature in 25 30 37 40\n    do\n        mkdir $species-$temperature\n    done\ndone\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe have a nested loop, i.e.¬†contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.\nTry running the code for yourself to see which directories are created!"
  },
  {
    "objectID": "slides/06-loop.html#what-are-loops",
    "href": "slides/06-loop.html#what-are-loops",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Loops are a programming construct which allow us to repeat a command or set of commands for each item in a list.\nAs such they are key to productivity improvements through automation.\nSimilar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes)."
  },
  {
    "objectID": "slides/06-loop.html#loop-structure",
    "href": "slides/06-loop.html#loop-structure",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "# The word \"for\" indicates the start of a \"For-loop\" command\nfor thing in list_of_things\n# The word \"do\" indicates the start of job execution list\ndo\n    # Execute command(s) using the variable\n    operation_using/command $thing\n# The word \"done\" indicates the end of a loop\ndone\nThree keywords: for, do, done"
  },
  {
    "objectID": "slides/06-loop.html#example-files",
    "href": "slides/06-loop.html#example-files",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Suppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat.\nFor this example, we‚Äôll use the exercise-data/creatures directory which only has three example files, but the principles can be applied to many many more files at once.\nThe structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines."
  },
  {
    "objectID": "slides/06-loop.html#looking-at-the-files",
    "href": "slides/06-loop.html#looking-at-the-files",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Let‚Äôs look at the files:\nhead -n 5 basilisk.dat minotaur.dat unicorn.dat\nWe would like to print out the classification for each species, which is given on the second line of each file.\nFor each file, we would need to execute the command head -n 2 and pipe this to tail -n 1."
  },
  {
    "objectID": "slides/06-loop.html#general-form-of-a-loop",
    "href": "slides/06-loop.html#general-form-of-a-loop",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "We‚Äôll use a loop to solve this problem, but first let‚Äôs look at the general form of a loop:\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    echo $filename\ndone\nbasilisk.dat\nminotaur.dat\nunicorn.dat"
  },
  {
    "objectID": "slides/06-loop.html#follow-the-prompt",
    "href": "slides/06-loop.html#follow-the-prompt",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "When typing a loop, shell prompt changes:\n$ for filename in basilisk.dat minotaur.dat unicorn.dat\n&gt; do\n&gt;     echo $filename\n&gt; done\nThe &gt; prompt reminds you the command isn‚Äôt complete yet.\nA semicolon ; can separate commands on one line."
  },
  {
    "objectID": "slides/06-loop.html#same-symbols-different-meanings",
    "href": "slides/06-loop.html#same-symbols-different-meanings",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Shell prints &gt; or $: it‚Äôs a prompt (expects input)\nYou type &gt; or $: it‚Äôs an instruction (redirect or variable)\n\nContext matters!"
  },
  {
    "objectID": "slides/06-loop.html#loop-iteration",
    "href": "slides/06-loop.html#loop-iteration",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Each time loop runs, variable holds next value:\n\nFirst: $filename = basilisk.dat\nSecond: $filename = minotaur.dat\nThird: $filename = unicorn.dat\n\nThen shell exits loop (no more items)."
  },
  {
    "objectID": "slides/06-loop.html#variable-substitution",
    "href": "slides/06-loop.html#variable-substitution",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Use $varname to access the value.\nThe $ tells shell: treat this as a variable, not literal text.\nReplace with actual value before executing command."
  },
  {
    "objectID": "slides/06-loop.html#practical-loop-example",
    "href": "slides/06-loop.html#practical-loop-example",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Get classification line from creature files:\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    echo $filename\n    head -n 2 $filename | tail -n 1\ndone\nbasilisk.dat\nCLASSIFICATION: basiliscus vulgaris\nminotaur.dat\nCLASSIFICATION: bos hominus\nunicorn.dat\nCLASSIFICATION: equus monoceros"
  },
  {
    "objectID": "slides/06-loop.html#variable-name-vs-value",
    "href": "slides/06-loop.html#variable-name-vs-value",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Variable name: filename (the name)\nVariable value: basilisk.dat (the data)\nUse $filename to get the value, not the name."
  },
  {
    "objectID": "slides/06-loop.html#variable-naming",
    "href": "slides/06-loop.html#variable-naming",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Two syntaxes:\necho $filename      # Simple\necho ${filename}    # With braces (clearer)\nBraces useful when variable next to text:\necho ${filename}.bak    # Shows: basilisk.dat.bak\necho $filename.bak      # Looks for variable \"filename.bak\"!"
  },
  {
    "objectID": "slides/06-loop.html#variable-naming-tips",
    "href": "slides/06-loop.html#variable-naming-tips",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Use meaningful names: filename, not x\nHelps others (and future you) understand code\nIncreases odds people interpret it correctly\n\nThe shell doesn‚Äôt care‚Äîonly we do!"
  },
  {
    "objectID": "slides/06-loop.html#loops-with-numbers",
    "href": "slides/06-loop.html#loops-with-numbers",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Loops work with any list, not just filenames:\nfor number in 0 1 2 3 4 5\ndo\n    echo $number\ndone"
  },
  {
    "objectID": "slides/06-loop.html#challenge-write-your-own-loop",
    "href": "slides/06-loop.html#challenge-write-your-own-loop",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nHow would you write a loop that echoes all 10 numbers from 0 to 9?"
  },
  {
    "objectID": "slides/06-loop.html#solution",
    "href": "slides/06-loop.html#solution",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nfor loop_variable in 0 1 2 3 4 5 6 7 8 9\ndo\n    echo $loop_variable\ndone\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nAlternatively, try replacing the enumeration of integers 0 1 2 3 4 5 6 7 8 9 by {0..9} to obtain an identical output."
  },
  {
    "objectID": "slides/06-loop.html#challenge-variables-in-loops",
    "href": "slides/06-loop.html#challenge-variables-in-loops",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, ls *.pdb gives:\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\nFirst code:\nfor datafile in *.pdb\ndo\n    ls *.pdb\ndone\nSecond code:\nfor datafile in *.pdb\ndo\n    ls $datafile\ndone\nWhat‚Äôs the difference?"
  },
  {
    "objectID": "slides/06-loop.html#solution-2",
    "href": "slides/06-loop.html#solution-2",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nFirst code: lists ALL .pdb files each iteration (6 times total).\nShell expands *.pdb in loop body for each iteration.\nSecond code: lists ONE file per iteration (6 different files).\nVariable $datafile evaluates to current file each time.\nSecond code is cleaner and what we usually want!"
  },
  {
    "objectID": "slides/06-loop.html#challenge-limiting-sets-of-files-c",
    "href": "slides/06-loop.html#challenge-limiting-sets-of-files-c",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop output?\nfor filename in c*\ndo\n    ls $filename\ndone\n\nNo files listed\nAll files are listed\nOnly cubane.pdb, octane.pdb, pentane.pdb\nOnly cubane.pdb"
  },
  {
    "objectID": "slides/06-loop.html#solution-4",
    "href": "slides/06-loop.html#solution-4",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 4 is correct.\n* matches zero or more characters.\nc* matches any filename starting with ‚Äòc‚Äô (only cubane.pdb)."
  },
  {
    "objectID": "slides/06-loop.html#challenge-limiting-sets-c",
    "href": "slides/06-loop.html#challenge-limiting-sets-c",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nHow different is this loop?\nfor filename in *c*\ndo\n    ls $filename\ndone\n\nSame files listed\nAll files are listed now\nNo files listed now\ncubane.pdb and octane.pdb\nOnly octane.pdb"
  },
  {
    "objectID": "slides/06-loop.html#solution-6",
    "href": "slides/06-loop.html#solution-6",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 4 is correct.\n*c* matches filename with ‚Äòc‚Äô anywhere in name (before or after).\nMatches: cubane.pdb (c at start) and octane.pdb (c in middle)."
  },
  {
    "objectID": "slides/06-loop.html#challenge-saving-to-file-with",
    "href": "slides/06-loop.html#challenge-saving-to-file-with",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop do?\nfor alkanes in *.pdb\ndo\n    echo $alkanes\n    cat $alkanes &gt; alkanes.pdb\ndone\n\nPrints all 6 files; only propane.pdb saved to alkanes.pdb\nPrints 3 files; all concatenated and saved to alkanes.pdb\nPrints 5 files; only propane.pdb saved to alkanes.pdb\nNone of the above"
  },
  {
    "objectID": "slides/06-loop.html#solution-8",
    "href": "slides/06-loop.html#solution-8",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 1 is correct.\nEach iteration: &gt; overwrites (not appends).\nLast file processed (propane.pdb) is final content.\nUse &gt;&gt; to append instead!"
  },
  {
    "objectID": "slides/06-loop.html#challenge-saving-to-file-with-1",
    "href": "slides/06-loop.html#challenge-saving-to-file-with-1",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nIn shell-lesson-data/exercise-data/alkanes, what does this loop do?\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\n\nAll files up to pentane.pdb concatenated\nOnly ethane.pdb saved\nAll 6 files concatenated to all.pdb\nAll 5 files concatenated"
  },
  {
    "objectID": "slides/06-loop.html#solution-10",
    "href": "slides/06-loop.html#solution-10",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 3 is correct.\n&gt;&gt; appends each file (doesn‚Äôt overwrite).\nAll 6 files concatenated to all.pdb.\nNothing printed (output redirected to file)."
  },
  {
    "objectID": "slides/06-loop.html#another-practical-example",
    "href": "slides/06-loop.html#another-practical-example",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "In shell-lesson-data/exercise-data/creatures:\nfor filename in *.dat\ndo\n    echo $filename\n    head -n 100 $filename | tail -n 20\ndone\nLoop body: two commands - Echo filename - Select lines 81-100 (or all if fewer than 100)"
  },
  {
    "objectID": "slides/06-loop.html#spaces-in-filenames",
    "href": "slides/06-loop.html#spaces-in-filenames",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Shell uses spaces to separate items!\nFilenames with spaces: red dragon.dat, purple unicorn.dat\nMust quote them:\nfor filename in \"red dragon.dat\" \"purple unicorn.dat\"\ndo\n    head -n 100 \"$filename\" | tail -n 20\ndone\nAlways quote variables to be safe: \"$filename\"\nIt is simpler to avoid using spaces (or other special characters) in filenames."
  },
  {
    "objectID": "slides/06-loop.html#what-happens-without-quotes",
    "href": "slides/06-loop.html#what-happens-without-quotes",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "The files red dragon.dat and purple unicorn.dat don‚Äôt exist, so if we run the code without quotes around $filename, we get errors:\nhead: cannot open 'red' for reading: No such file or directory\nhead: cannot open 'dragon.dat' for reading: No such file or directory\nhead: cannot open 'purple' for reading: No such file or directory\nWith quotes, we‚Äôd see:\nhead: cannot open 'red dragon.dat' for reading: No such file or directory\nhead: cannot open 'purple unicorn.dat' for reading: No such file or directory"
  },
  {
    "objectID": "slides/06-loop.html#why-quote-variables",
    "href": "slides/06-loop.html#why-quote-variables",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Without quotes: - Shell splits by spaces - \"red dragon.dat\" becomes two items: red, dragon.dat - Commands fail\nWith quotes: - Treated as single item - Commands work correctly\nBest practice: Avoid spaces in filenames entirely (use - or _)."
  },
  {
    "objectID": "slides/06-loop.html#backing-up-files-in-a-loop",
    "href": "slides/06-loop.html#backing-up-files-in-a-loop",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Problem: Copy all .dat files to original- versions.\nCan‚Äôt do this:\ncp *.dat original-*.dat  # ERROR!\nExpands to: cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\nShell sees 4 arguments, expects last to be directory!"
  },
  {
    "objectID": "slides/06-loop.html#solution-use-a-loop",
    "href": "slides/06-loop.html#solution-use-a-loop",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "for filename in *.dat\ndo\n    cp $filename original-$filename\ndone\nEach iteration: - $filename = basilisk.dat ‚Üí cp basilisk.dat original-basilisk.dat - $filename = minotaur.dat ‚Üí cp minotaur.dat original-minotaur.dat - $filename = unicorn.dat ‚Üí cp unicorn.dat original-unicorn.dat"
  },
  {
    "objectID": "slides/06-loop.html#testing-loops-with-echo",
    "href": "slides/06-loop.html#testing-loops-with-echo",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Hard to verify loop did what you want (no output from cp).\nSolution: Use echo to print commands without executing:\nfor filename in *.dat\ndo\n    echo cp $filename original-$filename\ndone\nSee what would run, verify correctness, then remove echo!\nThe judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "slides/06-loop.html#loop-flow-chart",
    "href": "slides/06-loop.html#loop-flow-chart",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "The following diagram shows what happens when the modified loop is executed, and demonstrates how the judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "slides/06-loop.html#nelles-pipeline-processing-files",
    "href": "slides/06-loop.html#nelles-pipeline-processing-files",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Nelle is now ready to process her data files using goostats.sh ‚Äî a shell script written by her supervisor.\nThis calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince she‚Äôs still learning how to use the shell, she decides to build up the required commands in stages."
  },
  {
    "objectID": "slides/06-loop.html#nelle-tests-file-selection",
    "href": "slides/06-loop.html#nelle-tests-file-selection",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Her first step is to make sure that she can select the right input files ‚Äî remember, these are ones whose names end in ‚ÄòA‚Äô or ‚ÄòB‚Äô, rather than ‚ÄòZ‚Äô.\nMoving to the north-pacific-gyre directory, Nelle types:\ncd\ncd Desktop/shell-lesson-data/north-pacific-gyre\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\ndone\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\nNENE02040B.txt\nNENE02043B.txt\nGood! Selects correct files."
  },
  {
    "objectID": "slides/06-loop.html#nelle-builds-output-filenames",
    "href": "slides/06-loop.html#nelle-builds-output-filenames",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Her next step is to decide what to call the files that the goostats.sh analysis program will create.\nPrefixing each input file‚Äôs name with ‚Äòstats‚Äô seems simple, so she modifies her loop:\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile stats-$datafile\ndone\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01736A.txt\nNENE01751A.txt stats-NENE01751A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nPerfect! Ready to process.\nShe hasn‚Äôt actually run goostats.sh yet, but now she‚Äôs sure she can select the right files and generate the right output filenames."
  },
  {
    "objectID": "slides/06-loop.html#command-history",
    "href": "slides/06-loop.html#command-history",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Typing same command repeatedly is tedious!\nShell remembers recent commands.\nView history:\nhistory\nShows numbered list of previous commands."
  },
  {
    "objectID": "slides/06-loop.html#accessing-history",
    "href": "slides/06-loop.html#accessing-history",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Method\nWhat it does\n\n\n\n\n‚Üë\nPrevious command\n\n\n‚Üì\nNext command\n\n\n!42\nRun command #42\n\n\nCtrl-R\nSearch history"
  },
  {
    "objectID": "slides/06-loop.html#one-liner-loop",
    "href": "slides/06-loop.html#one-liner-loop",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Press Up arrow:\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nEntire loop on one line using semicolons ;\nSame as multi-line version!"
  },
  {
    "objectID": "slides/06-loop.html#beginning-and-end",
    "href": "slides/06-loop.html#beginning-and-end",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Beginning and End\n\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E."
  },
  {
    "objectID": "slides/06-loop.html#those-who-know-history",
    "href": "slides/06-loop.html#those-who-know-history",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Those Who Know History Can Choose to Repeat It\n\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where 123 is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:\nhistory | tail -n 5\n  456  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n  457  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n  458  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; done\n  459  cd ..\n  460  history | tail -n 5\nthen she can re-run bash goostats.sh on all her files by typing !457."
  },
  {
    "objectID": "slides/06-loop.html#other-history-commands",
    "href": "slides/06-loop.html#other-history-commands",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Other history Commands\n\n\n\nThere are a number of other shortcut commands for getting at the history:\n\nCtrl+R enters a history search mode ‚Äòreverse-i-search‚Äô and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ‚Üë)\n!$ retrieves the last word of the last command. That‚Äôs useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ‚Üë and editing the command-line."
  },
  {
    "objectID": "slides/06-loop.html#challenge-doing-a-dry-run",
    "href": "slides/06-loop.html#challenge-doing-a-dry-run",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nA loop is a way to do many things at once ‚Äî or to make many mistakes at once if it does the wrong thing. One way to check what a loop would do is to echo the commands it would run instead of actually running them.\nSuppose we want to preview the commands the following loop will execute without actually running those commands:\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\nWhat is the difference between the two loops below, and which one would we want to run?\n# Version 1\nfor datafile in *.pdb\ndo\n    echo cat $datafile &gt;&gt; all.pdb\ndone\n# Version 2\nfor datafile in *.pdb\ndo\n    echo \"cat $datafile &gt;&gt; all.pdb\"\ndone"
  },
  {
    "objectID": "slides/06-loop.html#solution-12",
    "href": "slides/06-loop.html#solution-12",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also does not modify nor create the file all.pdb, as the &gt;&gt; is treated literally as part of a string rather than as a redirection instruction.\nThe first version appends the output from the command echo cat $datafile to the file, all.pdb. This file will just contain the list; cat cubane.pdb, cat ethane.pdb, cat methane.pdb etc.\nTry both versions for yourself to see the output! Be sure to open the all.pdb file to view its contents."
  },
  {
    "objectID": "slides/06-loop.html#challenge-nested-loops",
    "href": "slides/06-loop.html#challenge-nested-loops",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Challenge\n\n\n\nSuppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds and different temperatures. What would be the result of the following code:\nfor species in cubane ethane methane\ndo\n    for temperature in 25 30 37 40\n    do\n        mkdir $species-$temperature\n    done\ndone"
  },
  {
    "objectID": "slides/06-loop.html#solution-14",
    "href": "slides/06-loop.html#solution-14",
    "title": "Episode 6: Loops",
    "section": "",
    "text": "Solution\n\n\n\n\n\nWe have a nested loop, i.e.¬†contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.\nTry running the code for yourself to see which directories are created!"
  },
  {
    "objectID": "slides/07-script.html",
    "href": "slides/07-script.html",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I save and re-use commands?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nWrite shell script that runs commands for fixed file set\nRun shell script from command line\nWrite shell script that operates on user-defined file set\nCreate pipelines with shell scripts you and others wrote\n\n\n\n\n\nA file containing shell commands = a small program\nBenefits of shell scripts:\n\nSpeed: No retyping commands\nAccuracy: Fewer chances for typos\nReproducibility: Same results every time\nDocumentation: Shows what was done\nSharing: Others can use your work\n\nLet‚Äôs turn repeated commands into reusable programs!\n\n\n\nNavigate to alkanes/ directory and create a script:\ncd alkanes\nnano middle.sh\nThe nano command opens a text editor in the shell.\n\n\n\n\n\n\n\n\n\nText vs.¬†Whatever\n\n\n\nWord processors (Microsoft Word, LibreOffice) store formatting information about fonts, headings, etc.\nShell commands need plain text only ‚Äî no formatting codes.\nWhen editing programs, save as plain text, not .docx or .odt!\n\n\n\n\n\nIn nano, type this pipe that selects lines 11-15:\nhead -n 15 octane.pdb | tail -n 5\nSave with: Ctrl-O, then Enter, then Ctrl-X to exit\nVerify it was created:\nls -l middle.sh\n\n\n\nExecute the script:\nbash middle.sh\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOutput matches running the command manually!\n\n\n\nCurrent issue: Script only works on octane.pdb\nSolution: Make it accept command-line arguments!\nThen same script works on any file.\n\n\n\nEdit middle.sh to use a variable:\nnano middle.sh\nReplace octane.pdb with special variable $1:\nhead -n 15 \"$1\" | tail -n 5\n$1 means: first command-line argument\n\n\n\nNow the script works on any file:\nbash middle.sh octane.pdb\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOr with a different file:\nbash middle.sh pentane.pdb\nSame script, different results!\n\n\n\n\n\n\n\n\n\nDouble-Quotes Around Arguments\n\n\n\nAlways put double-quotes around variables to handle filenames with spaces:\nhead \"$1\" | tail -n 5     # Safe!\nhead $1 | tail -n 5       # Breaks if spaces in filename!\nThis also protects special characters in filenames.\n\n\n\n\n\nMake the script control all parameters:\nnano middle.sh\nEdit to:\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nNow: - $1 = filename - $2 = lines for head - $3 = lines for tail\n\n\n\nWith three parameters, we can change behavior:\nbash middle.sh pentane.pdb 15 5\nATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00\nATOM     10  H           1       1.271   1.378   0.122  1.00  0.00\nATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00\nATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00\nATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00\nOr with different numbers:\nbash middle.sh pentane.pdb 20 5\nATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00\nATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00\nATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00\nATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00\nTER      18              1\n\n\n\nThe next reader won‚Äôt know what $2 and $3 mean!\nEdit middle.sh to add helpful comments:\nnano middle.sh\n# Select lines from the middle of a file.\n# Usage: bash middle.sh filename end_line num_lines\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nComments start with # and run to end of line.\n\n\n\nKeep comments accurate and up-to-date!\nAn inaccurate comment is worse than no comment.\nUpdate comments whenever you change code.\n\n\n\nChallenge: Process many files at once.\nExample: sort .pdb files by line count:\nwc -l *.pdb | sort -n\nWe need a way to pass any number of filenames.\nSolution: $@ = all command-line arguments\n\n\n\nCreate a new script that accepts many files:\nnano sorted.sh\n# Sort files by their length.\n# Usage: bash sorted.sh one_or_more_filenames\nwc -l \"$@\" | sort -n\n$@ automatically expands to all arguments!\n\n\n\nbash sorted.sh *.pdb ../creatures/*.dat\n9 methane.pdb\n12 ethane.pdb\n15 propane.pdb\n20 cubane.pdb\n21 pentane.pdb\n30 octane.pdb\n163 ../creatures/basilisk.dat\n163 ../creatures/minotaur.dat\n163 ../creatures/unicorn.dat\n596 total\nWorks with any number of files!\n\n\n\n\n\n\nVariable\nMeaning\n\n\n\n\n$1\nFirst argument\n\n\n$2\nSecond argument\n\n\n$3\nThird argument\n\n\n$@\nAll arguments\n\n\n$#\nNumber of arguments\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nLeah has hundreds of data files formatted like animals.csv:\n2013-11-05,deer,5\n2013-11-05,rabbit,22\n2013-11-05,raccoon,7\n2013-11-06,rabbit,19\n2013-11-06,deer,2\n2013-11-06,fox,1\n2013-11-07,rabbit,18\n2013-11-07,bear,1\nCommand to extract unique species (second field, separated by commas):\ncut -d , -f 2 animals.csv | sort | uniq\nWrite a shell script called species.sh that takes any number of filenames as arguments and prints the unique species in each file (one file per section).\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCreate species.sh:\n# Script to find unique species in csv files \n# where species is the second data field\n# This script accepts any number of file names as command line arguments\n\n# Loop over all files\nfor file in $@\ndo\n    cut -d , -f 2 $file | sort | uniq\ndone\nUsage:\nbash species.sh animals.csv other-animals.csv\n\n\n\n\n\n\nMost scripts start with a shebang line:\n#!/bin/bash\nThis tells the system: Use bash to run this script\nThen you can run the script directly:\n./middle.sh octane.pdb\nInstead of always typing:\nbash middle.sh octane.pdb\n\n\n\nAdd shebang as first line:\n#!/bin/bash\n# Select lines from middle of file\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nThen make it executable:\nchmod u+x middle.sh\nNow run it directly:\n./middle.sh pentane.pdb 15 5\nCongratulations! You‚Äôve created a true executable program!\n\n\n\nYou‚Äôve run useful commands ‚Äî save them for later!\nhistory | tail -n 5 &gt; redo-figure-3.sh\nThe file redo-figure-3.sh now contains:\n297 bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n298 bash goodiff.sh stats-NENE01729B.txt /data/validated/01729.txt &gt; 01729-differences.txt\n299 cut -d ',' -f 2-3 01729-differences.txt &gt; 01729-time-series.txt\n300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png\n301 history | tail -n 5 &gt; redo-figure-3.sh\nEdit to remove line numbers and the history command itself.\nResult: Perfect reproduction record!\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIf you run the command:\nhistory | tail -n 5 &gt; recent.sh\nthe last command in the file is the history command itself, i.e., the shell has added history to the command log before actually running it.\nIn fact, the shell always adds commands to the log before running them.\nWhy do you think it does this?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf a command causes something to crash or hang, it might be useful to know what that command was, in order to investigate the problem.\nWere the command only be recorded after running it, we would not have a record of the last command run in the event of a crash.\n\n\n\n\n\n\nIn practice, most people develop shell scripts by running commands at the shell prompt a few times to make sure they‚Äôre doing the right thing, then saving them in a file for re-use.\nThis style of work allows people to recycle what they discover about their data and their workflow with one call to history and a bit of editing to clean up the output and save it as a shell script.\n\n\n\nNelle‚Äôs supervisor insisted that all her analytics must be reproducible.\nThe easiest way to capture all the steps is in a script.\nFirst we return to Nelle‚Äôs project directory:\ncd ../../north-pacific-gyre/\n\n\n\nShe creates a file using nano:\nnano do-stats.sh\n‚Ä¶which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\n\n\n\nShe saves this in a file called do-stats.sh so that she can now re-do the first stage of her analysis by typing:\nbash do-stats.sh NENE*A.txt NENE*B.txt\nShe can also do this:\nbash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed.\n\n\n\nOne thing to note about Nelle‚Äôs script is that it lets the person running it decide what files to process.\nShe could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\n\n\n\nAdvantage: This always selects the right files ‚Äî she doesn‚Äôt have to remember to exclude the ‚ÄòZ‚Äô files.\nDisadvantage: It always selects just those files ‚Äî she can‚Äôt run it on all files (including the ‚ÄòZ‚Äô files), or on the ‚ÄòG‚Äô or ‚ÄòH‚Äô files her colleagues in Antarctica are producing, without editing the script.\nIf she wanted to be more adventurous, she could modify her script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided.\nOf course, this introduces another tradeoff between flexibility and complexity.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\nbash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\nhead -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\ntail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks.\nAs such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension.\nFor example:\nbash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\nbash longest.sh shell-lesson-data/exercise-data/writing txt\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nExplanation:\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last).\nWhen there‚Äôs more than one file, wc also outputs a final summary line, giving the total number of lines across all files.\nWe use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we‚Äôll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created.\nExplain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\nScript 1:\necho *.*\nScript 2:\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\nScript 3:\necho $@.pdb\n\n\n\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e.¬†all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nSuppose you have saved the following script in a file called do-errors.sh in Nelle‚Äôs north-pacific-gyre directory:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats.sh $datafile stats-$datafile\ndone\nWhen you run it from the north-pacific-gyre directory:\nbash do-errors.sh NENE*A.txt NENE*B.txt\nthe output is blank. To figure out why, re-run the script using the -x option:\nbash -x do-errors.sh NENE*A.txt NENE*B.txt\nWhat is the output showing you? Which line is responsible for the error?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -x option causes bash to run in debug mode. This prints out each command as it is run, which will help you to locate errors. In this example, we can see that echo isn‚Äôt printing anything. We have made a typo in the loop variable name, and the variable datfile doesn‚Äôt exist, hence returning an empty string."
  },
  {
    "objectID": "slides/07-script.html#why-shell-scripts",
    "href": "slides/07-script.html#why-shell-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "A file containing shell commands = a small program\nBenefits of shell scripts:\n\nSpeed: No retyping commands\nAccuracy: Fewer chances for typos\nReproducibility: Same results every time\nDocumentation: Shows what was done\nSharing: Others can use your work\n\nLet‚Äôs turn repeated commands into reusable programs!"
  },
  {
    "objectID": "slides/07-script.html#creating-your-first-script",
    "href": "slides/07-script.html#creating-your-first-script",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Navigate to alkanes/ directory and create a script:\ncd alkanes\nnano middle.sh\nThe nano command opens a text editor in the shell."
  },
  {
    "objectID": "slides/07-script.html#text-editors-vs.-word-processors",
    "href": "slides/07-script.html#text-editors-vs.-word-processors",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Text vs.¬†Whatever\n\n\n\nWord processors (Microsoft Word, LibreOffice) store formatting information about fonts, headings, etc.\nShell commands need plain text only ‚Äî no formatting codes.\nWhen editing programs, save as plain text, not .docx or .odt!"
  },
  {
    "objectID": "slides/07-script.html#your-first-script-content",
    "href": "slides/07-script.html#your-first-script-content",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "In nano, type this pipe that selects lines 11-15:\nhead -n 15 octane.pdb | tail -n 5\nSave with: Ctrl-O, then Enter, then Ctrl-X to exit\nVerify it was created:\nls -l middle.sh"
  },
  {
    "objectID": "slides/07-script.html#running-your-script",
    "href": "slides/07-script.html#running-your-script",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Execute the script:\nbash middle.sh\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOutput matches running the command manually!"
  },
  {
    "objectID": "slides/07-script.html#problem-not-flexible",
    "href": "slides/07-script.html#problem-not-flexible",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Current issue: Script only works on octane.pdb\nSolution: Make it accept command-line arguments!\nThen same script works on any file."
  },
  {
    "objectID": "slides/07-script.html#making-scripts-flexible-using-1",
    "href": "slides/07-script.html#making-scripts-flexible-using-1",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Edit middle.sh to use a variable:\nnano middle.sh\nReplace octane.pdb with special variable $1:\nhead -n 15 \"$1\" | tail -n 5\n$1 means: first command-line argument"
  },
  {
    "objectID": "slides/07-script.html#using-the-1-argument",
    "href": "slides/07-script.html#using-the-1-argument",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Now the script works on any file:\nbash middle.sh octane.pdb\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOr with a different file:\nbash middle.sh pentane.pdb\nSame script, different results!"
  },
  {
    "objectID": "slides/07-script.html#quoting-arguments-matters",
    "href": "slides/07-script.html#quoting-arguments-matters",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Double-Quotes Around Arguments\n\n\n\nAlways put double-quotes around variables to handle filenames with spaces:\nhead \"$1\" | tail -n 5     # Safe!\nhead $1 | tail -n 5       # Breaks if spaces in filename!\nThis also protects special characters in filenames."
  },
  {
    "objectID": "slides/07-script.html#making-it-more-flexible-2-3",
    "href": "slides/07-script.html#making-it-more-flexible-2-3",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Make the script control all parameters:\nnano middle.sh\nEdit to:\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nNow: - $1 = filename - $2 = lines for head - $3 = lines for tail"
  },
  {
    "objectID": "slides/07-script.html#using-multiple-arguments",
    "href": "slides/07-script.html#using-multiple-arguments",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "With three parameters, we can change behavior:\nbash middle.sh pentane.pdb 15 5\nATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00\nATOM     10  H           1       1.271   1.378   0.122  1.00  0.00\nATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00\nATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00\nATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00\nOr with different numbers:\nbash middle.sh pentane.pdb 20 5\nATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00\nATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00\nATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00\nATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00\nTER      18              1"
  },
  {
    "objectID": "slides/07-script.html#adding-comments-for-documentation",
    "href": "slides/07-script.html#adding-comments-for-documentation",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "The next reader won‚Äôt know what $2 and $3 mean!\nEdit middle.sh to add helpful comments:\nnano middle.sh\n# Select lines from the middle of a file.\n# Usage: bash middle.sh filename end_line num_lines\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nComments start with # and run to end of line."
  },
  {
    "objectID": "slides/07-script.html#comment-best-practices",
    "href": "slides/07-script.html#comment-best-practices",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Keep comments accurate and up-to-date!\nAn inaccurate comment is worse than no comment.\nUpdate comments whenever you change code."
  },
  {
    "objectID": "slides/07-script.html#all-arguments-using",
    "href": "slides/07-script.html#all-arguments-using",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge: Process many files at once.\nExample: sort .pdb files by line count:\nwc -l *.pdb | sort -n\nWe need a way to pass any number of filenames.\nSolution: $@ = all command-line arguments"
  },
  {
    "objectID": "slides/07-script.html#using-in-a-script",
    "href": "slides/07-script.html#using-in-a-script",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Create a new script that accepts many files:\nnano sorted.sh\n# Sort files by their length.\n# Usage: bash sorted.sh one_or_more_filenames\nwc -l \"$@\" | sort -n\n$@ automatically expands to all arguments!"
  },
  {
    "objectID": "slides/07-script.html#running-script-with-multiple-files",
    "href": "slides/07-script.html#running-script-with-multiple-files",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "bash sorted.sh *.pdb ../creatures/*.dat\n9 methane.pdb\n12 ethane.pdb\n15 propane.pdb\n20 cubane.pdb\n21 pentane.pdb\n30 octane.pdb\n163 ../creatures/basilisk.dat\n163 ../creatures/minotaur.dat\n163 ../creatures/unicorn.dat\n596 total\nWorks with any number of files!"
  },
  {
    "objectID": "slides/07-script.html#script-arguments-reference",
    "href": "slides/07-script.html#script-arguments-reference",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Variable\nMeaning\n\n\n\n\n$1\nFirst argument\n\n\n$2\nSecond argument\n\n\n$3\nThird argument\n\n\n$@\nAll arguments\n\n\n$#\nNumber of arguments"
  },
  {
    "objectID": "slides/07-script.html#challenge-list-unique-species",
    "href": "slides/07-script.html#challenge-list-unique-species",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge\n\n\n\nLeah has hundreds of data files formatted like animals.csv:\n2013-11-05,deer,5\n2013-11-05,rabbit,22\n2013-11-05,raccoon,7\n2013-11-06,rabbit,19\n2013-11-06,deer,2\n2013-11-06,fox,1\n2013-11-07,rabbit,18\n2013-11-07,bear,1\nCommand to extract unique species (second field, separated by commas):\ncut -d , -f 2 animals.csv | sort | uniq\nWrite a shell script called species.sh that takes any number of filenames as arguments and prints the unique species in each file (one file per section)."
  },
  {
    "objectID": "slides/07-script.html#solution-list-unique-species",
    "href": "slides/07-script.html#solution-list-unique-species",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Solution\n\n\n\n\n\nCreate species.sh:\n# Script to find unique species in csv files \n# where species is the second data field\n# This script accepts any number of file names as command line arguments\n\n# Loop over all files\nfor file in $@\ndo\n    cut -d , -f 2 $file | sort | uniq\ndone\nUsage:\nbash species.sh animals.csv other-animals.csv"
  },
  {
    "objectID": "slides/07-script.html#the-shebang-binbash",
    "href": "slides/07-script.html#the-shebang-binbash",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Most scripts start with a shebang line:\n#!/bin/bash\nThis tells the system: Use bash to run this script\nThen you can run the script directly:\n./middle.sh octane.pdb\nInstead of always typing:\nbash middle.sh octane.pdb"
  },
  {
    "objectID": "slides/07-script.html#making-scripts-executable",
    "href": "slides/07-script.html#making-scripts-executable",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Add shebang as first line:\n#!/bin/bash\n# Select lines from middle of file\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\nThen make it executable:\nchmod u+x middle.sh\nNow run it directly:\n./middle.sh pentane.pdb 15 5\nCongratulations! You‚Äôve created a true executable program!"
  },
  {
    "objectID": "slides/07-script.html#saving-command-history",
    "href": "slides/07-script.html#saving-command-history",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "You‚Äôve run useful commands ‚Äî save them for later!\nhistory | tail -n 5 &gt; redo-figure-3.sh\nThe file redo-figure-3.sh now contains:\n297 bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n298 bash goodiff.sh stats-NENE01729B.txt /data/validated/01729.txt &gt; 01729-differences.txt\n299 cut -d ',' -f 2-3 01729-differences.txt &gt; 01729-time-series.txt\n300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png\n301 history | tail -n 5 &gt; redo-figure-3.sh\nEdit to remove line numbers and the history command itself.\nResult: Perfect reproduction record!"
  },
  {
    "objectID": "slides/07-script.html#challenge-why-record-commands-in-the-history-before-running-them",
    "href": "slides/07-script.html#challenge-why-record-commands-in-the-history-before-running-them",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge\n\n\n\nIf you run the command:\nhistory | tail -n 5 &gt; recent.sh\nthe last command in the file is the history command itself, i.e., the shell has added history to the command log before actually running it.\nIn fact, the shell always adds commands to the log before running them.\nWhy do you think it does this?"
  },
  {
    "objectID": "slides/07-script.html#solution-why-record-commands-in-the-history-before-running-them",
    "href": "slides/07-script.html#solution-why-record-commands-in-the-history-before-running-them",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Solution\n\n\n\n\n\nIf a command causes something to crash or hang, it might be useful to know what that command was, in order to investigate the problem.\nWere the command only be recorded after running it, we would not have a record of the last command run in the event of a crash."
  },
  {
    "objectID": "slides/07-script.html#developing-shell-scripts",
    "href": "slides/07-script.html#developing-shell-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "In practice, most people develop shell scripts by running commands at the shell prompt a few times to make sure they‚Äôre doing the right thing, then saving them in a file for re-use.\nThis style of work allows people to recycle what they discover about their data and their workflow with one call to history and a bit of editing to clean up the output and save it as a shell script."
  },
  {
    "objectID": "slides/07-script.html#nelles-pipeline-creating-a-script",
    "href": "slides/07-script.html#nelles-pipeline-creating-a-script",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Nelle‚Äôs supervisor insisted that all her analytics must be reproducible.\nThe easiest way to capture all the steps is in a script.\nFirst we return to Nelle‚Äôs project directory:\ncd ../../north-pacific-gyre/"
  },
  {
    "objectID": "slides/07-script.html#nelle-creates-do-stats.sh",
    "href": "slides/07-script.html#nelle-creates-do-stats.sh",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "She creates a file using nano:\nnano do-stats.sh\n‚Ä¶which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone"
  },
  {
    "objectID": "slides/07-script.html#running-nelles-script",
    "href": "slides/07-script.html#running-nelles-script",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "She saves this in a file called do-stats.sh so that she can now re-do the first stage of her analysis by typing:\nbash do-stats.sh NENE*A.txt NENE*B.txt\nShe can also do this:\nbash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed."
  },
  {
    "objectID": "slides/07-script.html#script-design-tradeoffs",
    "href": "slides/07-script.html#script-design-tradeoffs",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "One thing to note about Nelle‚Äôs script is that it lets the person running it decide what files to process.\nShe could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone"
  },
  {
    "objectID": "slides/07-script.html#hardcoded-vs.-flexible-scripts",
    "href": "slides/07-script.html#hardcoded-vs.-flexible-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Advantage: This always selects the right files ‚Äî she doesn‚Äôt have to remember to exclude the ‚ÄòZ‚Äô files.\nDisadvantage: It always selects just those files ‚Äî she can‚Äôt run it on all files (including the ‚ÄòZ‚Äô files), or on the ‚ÄòG‚Äô or ‚ÄòH‚Äô files her colleagues in Antarctica are producing, without editing the script.\nIf she wanted to be more adventurous, she could modify her script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided.\nOf course, this introduces another tradeoff between flexibility and complexity."
  },
  {
    "objectID": "slides/07-script.html#challenge-variables-in-shell-scripts",
    "href": "slides/07-script.html#challenge-variables-in-shell-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge\n\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\nbash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb"
  },
  {
    "objectID": "slides/07-script.html#solution-variables-in-shell-scripts",
    "href": "slides/07-script.html#solution-variables-in-shell-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\nhead -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\ntail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks.\nAs such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail."
  },
  {
    "objectID": "slides/07-script.html#challenge-find-the-longest-file-with-a-given-extension",
    "href": "slides/07-script.html#challenge-find-the-longest-file-with-a-given-extension",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge\n\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension.\nFor example:\nbash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\nbash longest.sh shell-lesson-data/exercise-data/writing txt"
  },
  {
    "objectID": "slides/07-script.html#solution-find-the-longest-file-with-a-given-extension",
    "href": "slides/07-script.html#solution-find-the-longest-file-with-a-given-extension",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Solution\n\n\n\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nExplanation:\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last).\nWhen there‚Äôs more than one file, wc also outputs a final summary line, giving the total number of lines across all files.\nWe use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we‚Äôll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output."
  },
  {
    "objectID": "slides/07-script.html#challenge-script-reading-comprehension",
    "href": "slides/07-script.html#challenge-script-reading-comprehension",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge\n\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created.\nExplain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\nScript 1:\necho *.*\nScript 2:\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\nScript 3:\necho $@.pdb"
  },
  {
    "objectID": "slides/07-script.html#solution-script-reading-comprehension",
    "href": "slides/07-script.html#solution-script-reading-comprehension",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Solutions\n\n\n\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e.¬†all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb"
  },
  {
    "objectID": "slides/07-script.html#challenge-debugging-scripts",
    "href": "slides/07-script.html#challenge-debugging-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Challenge\n\n\n\nSuppose you have saved the following script in a file called do-errors.sh in Nelle‚Äôs north-pacific-gyre directory:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats.sh $datafile stats-$datafile\ndone\nWhen you run it from the north-pacific-gyre directory:\nbash do-errors.sh NENE*A.txt NENE*B.txt\nthe output is blank. To figure out why, re-run the script using the -x option:\nbash -x do-errors.sh NENE*A.txt NENE*B.txt\nWhat is the output showing you? Which line is responsible for the error?"
  },
  {
    "objectID": "slides/07-script.html#solution-debugging-scripts",
    "href": "slides/07-script.html#solution-debugging-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe -x option causes bash to run in debug mode. This prints out each command as it is run, which will help you to locate errors. In this example, we can see that echo isn‚Äôt printing anything. We have made a typo in the loop variable name, and the variable datfile doesn‚Äôt exist, hence returning an empty string."
  },
  {
    "objectID": "slides/09-awk.html",
    "href": "slides/09-awk.html",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Questions\n\n\n\n\nHow do I print specific columns from a text table?\nHow can I use patterns to select only certain lines in a file?\nHow do I count lines or matched lines in a file?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nSelect and print fields with $0, $1, $2, $NF, and NF\nUse field separator (-F) to handle CSV input\nMatch lines using regex like /^ATOM/\nCount lines with counter and END block\nExplain difference between wc -l and awk 'END {print NR}'\n\n\n\n\n\nUsing wc -l:\nwc -l example.txt\nThe issue: wc counts newlines only.\nIf last line has no carriage return, result is off by one.\n\n\n\nAWK = command-line program for text processing.\n\nTakes instructions and one or more files\nExecutes on each line\nInstructions in single quotes or from file\n\n\n\n\nawk '{print $0}' example.txt\nSame output as cat example.txt.\nStructure: - {} surrounds instructions - print sends output to terminal - $0 = entire current line (variable)\n\n\n\nAWK automatically splits each line by spaces.\nColumns stored in variables: - $1 = first column - $2 = second column - $3 = third column - And so on‚Ä¶\n\n\n\nawk '{print $0}' example.txt\n$0 means ‚Äúthe whole line‚Äù.\nSame as cat but using AWK!\n\n\n\nPrint only second column:\nawk '{print $2}' example.txt\nPrint multiple columns (second and fourth):\nawk '{print $2, $4}' example.txt\nCommas add spaces between output values.\n\n\n\nPrint with custom text:\nawk '{print \"chr\", $2, $4}' example.txt\nchr value2 value4\nchr value2 value4\nchr value2 value4\nText must be in quotes.\n\n\n\nNF = Number of Fields (columns)\nawk '{print NF}' example.txt\nShows how many columns in each row.\nUseful when files have variable column counts.\n\n\n\nSome lines have 6 fields, others have 7:\nawk '{print \"This line has\", NF, \"columns. The last one contains\", $NF}' example.txt\nNF gives column count for current line.\n\n\n\nPrint the last column without knowing its number:\nawk '{print $NF}' example.txt\nPerfect when: - Files are huge - Lines have different column counts - You only need the final value\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOut there we have different file formats: our data may be comma separated (CSV), tab separated (TSV), by semicolon or by any other character.\n\n\n\n\n\nBy default, AWK splits on spaces and tabs.\nFor other separators, use -F flag.\n\n\n\nFor CSV files:\nawk -F \",\" '{print $2}' example.csv\nNote: comma becomes the separator, not part of field!\nSpaces in fields are now part of the value.\n\n\n\nColon separator:\nawk -F \":\" '{print $1}' /etc/passwd\nTab separator:\nawk -F \"\\t\" '{print $2}' file.tsv\n\n\n\nRun action only on matching lines\nawk '/PATTERN/ {action}' file\n\nPattern: regex to match\nAction: what to do if matched\n\n\n\n\nPrint only lines starting with ‚ÄúATOM‚Äù:\nawk '/^ATOM/ {print $0}' example.pdb\n^ means beginning of line.\n\n\n\nApply different actions to different patterns:\nawk '/^ATOM/ {count1++} /^HEADER/ {count2++}' file.pdb\nOr print specific fields from matching lines:\nawk '/^ATOM/ {print $7, $8, $9}' file.pdb\nExample: Print x, y, z coordinates of atoms.\nCombined patterns printing fields and header last field (from episode example):\nawk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb\n\n\n\nRuns after all lines are processed\nPerfect for printing totals and summaries.\nawk '{sum += $2} END {print sum}' file.txt\nSums values from column 2 across all lines.\n\n\n\nNR = Number of Records (total lines processed)\nAfter file is read, NR = line count:\nawk 'END {print NR}' example.txt\nMore robust than wc -l (handles missing final newline).\n\n\n\nUsing wc:\nwc -l file.txt\nMay undercount if last line lacks newline!\nUsing AWK:\nawk 'END {print NR}' file.txt\nAlways counts correctly!\n\n\n\nCount only lines starting with ‚ÄúATOM‚Äù:\nawk '/^ATOM/ {count++} END {print count}' file.pdb\n\n/^ATOM/ = match lines starting with ATOM\ncount++ = increment counter\nEND = print final count\n\n\n\n\nAvoid errors if no lines match:\nawk '/^ATOM/ {c++} END {print c+0}' file.pdb\nAdding +0 safely prints 0 if no matches.\n\n\n\nCount atoms and sum their coordinates:\nawk '/^ATOM/ {count++; x += $7; y += $8; z += $9} \\\n    END {print count, x, y, z}' file.pdb\n\ncount++ = count atoms\nx += $7 = sum x coordinates\nEND = print all totals\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing only the ideas covered above (field selection, patterns, NF, and END):\n\nWrite an awk command that prints the number of lines in example.txt.\nWrite an awk command that prints the number of lines in example.pdb that start with ATOM.\nWrite an awk command that prints the last field of each ATOM line in example.pdb (just the values, one per line).\n\nBonus (optional): Print both the count of ATOM lines and, at the end, the total number of characters across all those last fields.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n1) Total lines (robust):\nawk 'END {print NR}' example.txt\n2) Count lines starting with ATOM:\nawk '/^ATOM/ {c++} END {print c+0}' example.pdb\n3) Last field of each ATOM line:\nawk '/^ATOM/ {print $NF}' example.pdb\nBonus (count and accumulate character lengths of last field):\nawk '/^ATOM/ {c++; total += length($NF)} END {print \"ATOM lines:\", c+0; print \"Total chars in last field:\", total+0}' example.pdb\nExplanation: - NR gives total lines after reading the file. - /^ATOM/ pattern restricts actions to lines starting with ATOM. - $NF is the last field; length($NF) measures its size. - Counters (c, total) are printed in END.\n\n\n\n\n\n\nlength(): measure string length\nawk '{print length($1)}' file.txt\nString concatenation:\nawk '{print $1 \"_\" $2}' file.txt\nJoins fields with underscore.\n\n\n\nSum values:\nawk '{sum += $1} END {print sum}' numbers.txt\nCalculate average:\nawk '{sum += $1; count++} END {print sum/count}' numbers.txt\n\n\n\nSet variables in AWK:\nawk '{x = $2 * 2; print x}' file.txt\nUse variables in calculations throughout.\n\n\n\nInitialize variables before processing:\nawk 'BEGIN {total=0} {total += $1} END {print total}' file.txt\n\nBEGIN runs first (before any lines)\n{total += $1} processes each line\nEND prints result\n\n\n\n\nFor complex scripts, save to file.\nCreate script.awk:\n/^ATOM/ {\n    count++\n    x += $7\n    y += $8\n    z += $9\n}\n\nEND {\n    print \"Atoms:\", count\n    if (count &gt; 0) {\n        print \"Avg X:\", x/count\n        print \"Avg Y:\", y/count\n        print \"Avg Z:\", z/count\n    }\n}\nRun it:\nawk -f script.awk protein.pdb\n\n\n\nExtract chromosome and position from BED file:\nawk -F \"\\t\" '{print $1, $2, $3}' file.bed\n\n\n\nCount records by type:\nawk '{type[$1]++} END {for (t in type) print t, type[t]}' data.txt\n\n\n\nFilter and sum:\nawk '$3 &gt; 1000 {sum += $3} END {print sum}' file.txt\nOnly sum values in column 3 greater than 1000.\n\n\n\n\n\n\nConcept\nMeaning\n\n\n\n\n$0\nEntire line\n\n\n$1, $2, ...\nColumns (fields)\n\n\nNF\nNumber of fields\n\n\n$NF\nLast field\n\n\nNR\nLine number / total lines\n\n\n-F\nField separator\n\n\n/pattern/\nRegex match\n\n\nEND\nAfter all lines\n\n\n\n\n\n\n\nCongratulations! üéâ\nYou now know how to:\n‚úì Navigate files and directories\n‚úì Manage and create files\n‚úì Combine commands with pipes\n‚úì Write loops and shell scripts\n‚úì Find files and search text\n‚úì Process data with AWK"
  },
  {
    "objectID": "slides/09-awk.html#counting-lines-the-problem",
    "href": "slides/09-awk.html#counting-lines-the-problem",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Using wc -l:\nwc -l example.txt\nThe issue: wc counts newlines only.\nIf last line has no carriage return, result is off by one."
  },
  {
    "objectID": "slides/09-awk.html#awk-a-better-solution",
    "href": "slides/09-awk.html#awk-a-better-solution",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "AWK = command-line program for text processing.\n\nTakes instructions and one or more files\nExecutes on each line\nInstructions in single quotes or from file"
  },
  {
    "objectID": "slides/09-awk.html#basic-awk-syntax",
    "href": "slides/09-awk.html#basic-awk-syntax",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "awk '{print $0}' example.txt\nSame output as cat example.txt.\nStructure: - {} surrounds instructions - print sends output to terminal - $0 = entire current line (variable)"
  },
  {
    "objectID": "slides/09-awk.html#how-awk-works",
    "href": "slides/09-awk.html#how-awk-works",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "AWK automatically splits each line by spaces.\nColumns stored in variables: - $1 = first column - $2 = second column - $3 = third column - And so on‚Ä¶"
  },
  {
    "objectID": "slides/09-awk.html#printing-entire-line",
    "href": "slides/09-awk.html#printing-entire-line",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "awk '{print $0}' example.txt\n$0 means ‚Äúthe whole line‚Äù.\nSame as cat but using AWK!"
  },
  {
    "objectID": "slides/09-awk.html#printing-specific-columns",
    "href": "slides/09-awk.html#printing-specific-columns",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Print only second column:\nawk '{print $2}' example.txt\nPrint multiple columns (second and fourth):\nawk '{print $2, $4}' example.txt\nCommas add spaces between output values."
  },
  {
    "objectID": "slides/09-awk.html#adding-text-to-output",
    "href": "slides/09-awk.html#adding-text-to-output",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Print with custom text:\nawk '{print \"chr\", $2, $4}' example.txt\nchr value2 value4\nchr value2 value4\nchr value2 value4\nText must be in quotes."
  },
  {
    "objectID": "slides/09-awk.html#the-nf-variable",
    "href": "slides/09-awk.html#the-nf-variable",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "NF = Number of Fields (columns)\nawk '{print NF}' example.txt\nShows how many columns in each row.\nUseful when files have variable column counts."
  },
  {
    "objectID": "slides/09-awk.html#example-lines-with-different-columns",
    "href": "slides/09-awk.html#example-lines-with-different-columns",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Some lines have 6 fields, others have 7:\nawk '{print \"This line has\", NF, \"columns. The last one contains\", $NF}' example.txt\nNF gives column count for current line."
  },
  {
    "objectID": "slides/09-awk.html#the-last-column-nf",
    "href": "slides/09-awk.html#the-last-column-nf",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Print the last column without knowing its number:\nawk '{print $NF}' example.txt\nPerfect when: - Files are huge - Lines have different column counts - You only need the final value"
  },
  {
    "objectID": "slides/09-awk.html#field-separator-formats",
    "href": "slides/09-awk.html#field-separator-formats",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Note\n\n\n\nOut there we have different file formats: our data may be comma separated (CSV), tab separated (TSV), by semicolon or by any other character."
  },
  {
    "objectID": "slides/09-awk.html#field-separators-default-behavior",
    "href": "slides/09-awk.html#field-separators-default-behavior",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "By default, AWK splits on spaces and tabs.\nFor other separators, use -F flag."
  },
  {
    "objectID": "slides/09-awk.html#field-separator-comma--f",
    "href": "slides/09-awk.html#field-separator-comma--f",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "For CSV files:\nawk -F \",\" '{print $2}' example.csv\nNote: comma becomes the separator, not part of field!\nSpaces in fields are now part of the value."
  },
  {
    "objectID": "slides/09-awk.html#field-separator-other-examples",
    "href": "slides/09-awk.html#field-separator-other-examples",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Colon separator:\nawk -F \":\" '{print $1}' /etc/passwd\nTab separator:\nawk -F \"\\t\" '{print $2}' file.tsv"
  },
  {
    "objectID": "slides/09-awk.html#pattern-action-model",
    "href": "slides/09-awk.html#pattern-action-model",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Run action only on matching lines\nawk '/PATTERN/ {action}' file\n\nPattern: regex to match\nAction: what to do if matched"
  },
  {
    "objectID": "slides/09-awk.html#regex-pattern-start-of-line",
    "href": "slides/09-awk.html#regex-pattern-start-of-line",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Print only lines starting with ‚ÄúATOM‚Äù:\nawk '/^ATOM/ {print $0}' example.pdb\n^ means beginning of line."
  },
  {
    "objectID": "slides/09-awk.html#multiple-patterns",
    "href": "slides/09-awk.html#multiple-patterns",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Apply different actions to different patterns:\nawk '/^ATOM/ {count1++} /^HEADER/ {count2++}' file.pdb\nOr print specific fields from matching lines:\nawk '/^ATOM/ {print $7, $8, $9}' file.pdb\nExample: Print x, y, z coordinates of atoms.\nCombined patterns printing fields and header last field (from episode example):\nawk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb"
  },
  {
    "objectID": "slides/09-awk.html#the-end-block",
    "href": "slides/09-awk.html#the-end-block",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Runs after all lines are processed\nPerfect for printing totals and summaries.\nawk '{sum += $2} END {print sum}' file.txt\nSums values from column 2 across all lines."
  },
  {
    "objectID": "slides/09-awk.html#the-nr-variable",
    "href": "slides/09-awk.html#the-nr-variable",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "NR = Number of Records (total lines processed)\nAfter file is read, NR = line count:\nawk 'END {print NR}' example.txt\nMore robust than wc -l (handles missing final newline)."
  },
  {
    "objectID": "slides/09-awk.html#comparing-line-counting-methods",
    "href": "slides/09-awk.html#comparing-line-counting-methods",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Using wc:\nwc -l file.txt\nMay undercount if last line lacks newline!\nUsing AWK:\nawk 'END {print NR}' file.txt\nAlways counts correctly!"
  },
  {
    "objectID": "slides/09-awk.html#counting-matching-lines",
    "href": "slides/09-awk.html#counting-matching-lines",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Count only lines starting with ‚ÄúATOM‚Äù:\nawk '/^ATOM/ {count++} END {print count}' file.pdb\n\n/^ATOM/ = match lines starting with ATOM\ncount++ = increment counter\nEND = print final count"
  },
  {
    "objectID": "slides/09-awk.html#safe-counter-initialization",
    "href": "slides/09-awk.html#safe-counter-initialization",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Avoid errors if no lines match:\nawk '/^ATOM/ {c++} END {print c+0}' file.pdb\nAdding +0 safely prints 0 if no matches."
  },
  {
    "objectID": "slides/09-awk.html#multiple-counters-in-a-pattern",
    "href": "slides/09-awk.html#multiple-counters-in-a-pattern",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Count atoms and sum their coordinates:\nawk '/^ATOM/ {count++; x += $7; y += $8; z += $9} \\\n    END {print count, x, y, z}' file.pdb\n\ncount++ = count atoms\nx += $7 = sum x coordinates\nEND = print all totals"
  },
  {
    "objectID": "slides/09-awk.html#challenge-counting-and-selecting-simple",
    "href": "slides/09-awk.html#challenge-counting-and-selecting-simple",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Challenge\n\n\n\nUsing only the ideas covered above (field selection, patterns, NF, and END):\n\nWrite an awk command that prints the number of lines in example.txt.\nWrite an awk command that prints the number of lines in example.pdb that start with ATOM.\nWrite an awk command that prints the last field of each ATOM line in example.pdb (just the values, one per line).\n\nBonus (optional): Print both the count of ATOM lines and, at the end, the total number of characters across all those last fields."
  },
  {
    "objectID": "slides/09-awk.html#solution-counting-and-selecting",
    "href": "slides/09-awk.html#solution-counting-and-selecting",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Solution\n\n\n\n\n\n1) Total lines (robust):\nawk 'END {print NR}' example.txt\n2) Count lines starting with ATOM:\nawk '/^ATOM/ {c++} END {print c+0}' example.pdb\n3) Last field of each ATOM line:\nawk '/^ATOM/ {print $NF}' example.pdb\nBonus (count and accumulate character lengths of last field):\nawk '/^ATOM/ {c++; total += length($NF)} END {print \"ATOM lines:\", c+0; print \"Total chars in last field:\", total+0}' example.pdb\nExplanation: - NR gives total lines after reading the file. - /^ATOM/ pattern restricts actions to lines starting with ATOM. - $NF is the last field; length($NF) measures its size. - Counters (c, total) are printed in END."
  },
  {
    "objectID": "slides/09-awk.html#built-in-functions",
    "href": "slides/09-awk.html#built-in-functions",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "length(): measure string length\nawk '{print length($1)}' file.txt\nString concatenation:\nawk '{print $1 \"_\" $2}' file.txt\nJoins fields with underscore."
  },
  {
    "objectID": "slides/09-awk.html#arithmetic-and-aggregation",
    "href": "slides/09-awk.html#arithmetic-and-aggregation",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Sum values:\nawk '{sum += $1} END {print sum}' numbers.txt\nCalculate average:\nawk '{sum += $1; count++} END {print sum/count}' numbers.txt"
  },
  {
    "objectID": "slides/09-awk.html#variable-assignment",
    "href": "slides/09-awk.html#variable-assignment",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Set variables in AWK:\nawk '{x = $2 * 2; print x}' file.txt\nUse variables in calculations throughout."
  },
  {
    "objectID": "slides/09-awk.html#begin-block-advanced",
    "href": "slides/09-awk.html#begin-block-advanced",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Initialize variables before processing:\nawk 'BEGIN {total=0} {total += $1} END {print total}' file.txt\n\nBEGIN runs first (before any lines)\n{total += $1} processes each line\nEND prints result"
  },
  {
    "objectID": "slides/09-awk.html#awk-programs-from-files",
    "href": "slides/09-awk.html#awk-programs-from-files",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "For complex scripts, save to file.\nCreate script.awk:\n/^ATOM/ {\n    count++\n    x += $7\n    y += $8\n    z += $9\n}\n\nEND {\n    print \"Atoms:\", count\n    if (count &gt; 0) {\n        print \"Avg X:\", x/count\n        print \"Avg Y:\", y/count\n        print \"Avg Z:\", z/count\n    }\n}\nRun it:\nawk -f script.awk protein.pdb"
  },
  {
    "objectID": "slides/09-awk.html#real-world-example-1",
    "href": "slides/09-awk.html#real-world-example-1",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Extract chromosome and position from BED file:\nawk -F \"\\t\" '{print $1, $2, $3}' file.bed"
  },
  {
    "objectID": "slides/09-awk.html#real-world-example-2",
    "href": "slides/09-awk.html#real-world-example-2",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Count records by type:\nawk '{type[$1]++} END {for (t in type) print t, type[t]}' data.txt"
  },
  {
    "objectID": "slides/09-awk.html#real-world-example-3",
    "href": "slides/09-awk.html#real-world-example-3",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Filter and sum:\nawk '$3 &gt; 1000 {sum += $3} END {print sum}' file.txt\nOnly sum values in column 3 greater than 1000."
  },
  {
    "objectID": "slides/09-awk.html#key-concepts-summary",
    "href": "slides/09-awk.html#key-concepts-summary",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Concept\nMeaning\n\n\n\n\n$0\nEntire line\n\n\n$1, $2, ...\nColumns (fields)\n\n\nNF\nNumber of fields\n\n\n$NF\nLast field\n\n\nNR\nLine number / total lines\n\n\n-F\nField separator\n\n\n/pattern/\nRegex match\n\n\nEND\nAfter all lines"
  },
  {
    "objectID": "slides/09-awk.html#youve-completed-the-unix-shell-workshop",
    "href": "slides/09-awk.html#youve-completed-the-unix-shell-workshop",
    "title": "Episode 9: AWK for Text Processing",
    "section": "",
    "text": "Congratulations! üéâ\nYou now know how to:\n‚úì Navigate files and directories\n‚úì Manage and create files\n‚úì Combine commands with pipes\n‚úì Write loops and shell scripts\n‚úì Find files and search text\n‚úì Process data with AWK"
  }
]