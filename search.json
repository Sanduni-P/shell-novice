[
  {
    "objectID": "slides/00-intro-overview.html#workshop-overview",
    "href": "slides/00-intro-overview.html#workshop-overview",
    "title": "Unix Shell Workshop",
    "section": "Workshop Overview",
    "text": "Workshop Overview\nMaster the Unix shell (Bash) to:\n\nNavigate your file system efficiently\nCreate, copy, move, and delete files and directories\nCombine commands with pipes and filters\nAutomate repetitive tasks with loops\nWrite and execute shell scripts\nSearch files and text patterns"
  },
  {
    "objectID": "slides/00-intro-overview.html#learning-objectives",
    "href": "slides/00-intro-overview.html#learning-objectives",
    "title": "Unix Shell Workshop",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this workshop, you will know how to:\n\n\nUnderstand what the shell is and when to use it\nMove around folders and find your way to files\nMake, copy, rename, and delete files and folders\nJoin simple commands together to get the result you want\nRepeat actions on many files without retyping\nSave steps in small scripts so you can reuse them\nSearch for files and for text inside files quickly"
  },
  {
    "objectID": "slides/00-intro-overview.html#prerequisites",
    "href": "slides/00-intro-overview.html#prerequisites",
    "title": "Unix Shell Workshop",
    "section": "Prerequisites",
    "text": "Prerequisites\nStep 1: Download Files\nDownload shell-lesson-data.zip and move it to your Desktop.\nStep 2: Extract the Archive\nUnzip/extract the file. You should end up with a new folder called:\nshell-lesson-data on your Desktop\nStep 3: You’re Ready!\nAll data files will be in this directory for use throughout the workshop."
  },
  {
    "objectID": "slides/00-intro-overview.html#workshop-structure",
    "href": "slides/00-intro-overview.html#workshop-structure",
    "title": "Unix Shell Workshop",
    "section": "Workshop Structure",
    "text": "Workshop Structure\n\n\n\nEpisode\nTopic\n\n\n\n\n1\nIntroducing the Shell\n\n\n2\nNavigating Files and Directories\n\n\n3\nWorking With Files and Directories\n\n\n4\nFile Permissions\n\n\n5\nPipes and Filters\n\n\n6\nLoops\n\n\n7\nShell Scripts\n\n\n8\nFinding Things\n\n\n9\nAWK for Text Processing"
  },
  {
    "objectID": "slides/00-intro-overview.html#before-we-begin",
    "href": "slides/00-intro-overview.html#before-we-begin",
    "title": "Unix Shell Workshop",
    "section": "Before We Begin…",
    "text": "Before We Begin…\nYou can copy any command directly from the slides by clicking the clipboard icon on the right-hand side of each code block. Then paste it straight into your terminal."
  },
  {
    "objectID": "slides/00-intro-overview.html#file-permissions-in-unix",
    "href": "slides/00-intro-overview.html#file-permissions-in-unix",
    "title": "Unix Shell Workshop",
    "section": "File Permissions in Unix",
    "text": "File Permissions in Unix\nUnix controls who can read, modify, and run files using permissions.\nLet’s start with Nelle:\n\nUnique user name: nnemo\nUser ID: 1404\n\nUsers can belong to multiple groups, each with a name and numeric group ID.\n\n\n\n\n\n\nWhy Integer IDs?\n\n\nIn early Unix, integers were faster and smaller to store and compare than strings.\nSystems often keep numeric IDs internally and map them to human-friendly names when displaying information."
  },
  {
    "objectID": "slides/00-intro-overview.html#file-ownership",
    "href": "slides/00-intro-overview.html#file-ownership",
    "title": "Unix Shell Workshop",
    "section": "File Ownership",
    "text": "File Ownership\nEvery file and directory on a Unix computer:\n\nBelongs to one owner\nBelongs to one group\n\nThe operating system stores the numeric IDs of the user and group that own it."
  },
  {
    "objectID": "slides/00-intro-overview.html#three-user-categories",
    "href": "slides/00-intro-overview.html#three-user-categories",
    "title": "Unix Shell Workshop",
    "section": "Three User Categories",
    "text": "Three User Categories\nFor each file, every user falls into one of three categories:\n\nOwner of the file\nSomeone in the file’s group\nEveryone else"
  },
  {
    "objectID": "slides/00-intro-overview.html#three-permission-types",
    "href": "slides/00-intro-overview.html#three-permission-types",
    "title": "Unix Shell Workshop",
    "section": "Three Permission Types",
    "text": "Three Permission Types\nFor each category, the computer tracks whether people can:\n\nRead the file\nWrite to the file\nExecute the file (run it if it’s a program)"
  },
  {
    "objectID": "slides/00-intro-overview.html#example-permission-table",
    "href": "slides/00-intro-overview.html#example-permission-table",
    "title": "Unix Shell Workshop",
    "section": "Example Permission Table",
    "text": "Example Permission Table\n\n\n\n\n\nuser\n\n\ngroup\n\n\nall\n\n\n\n\nread\n\n\nyes\n\n\nyes\n\n\nno\n\n\n\n\nwrite\n\n\nyes\n\n\nno\n\n\nno\n\n\n\n\nexecute\n\n\nno\n\n\nno\n\n\nno\n\n\n\nThis means:\n\nOwner can read and write, but not run it\nGroup can read, but not modify or run it\nEveryone else can do nothing with it"
  },
  {
    "objectID": "slides/00-intro-overview.html#permissions-in-action",
    "href": "slides/00-intro-overview.html#permissions-in-action",
    "title": "Unix Shell Workshop",
    "section": "Permissions in Action",
    "text": "Permissions in Action\ncd into the labs directory and run ls -F:\ncd labs\nls -F\nsafety.txt    setup*     waiver.txt\nThe * at the end of setup tells us it’s executable - probably something the computer can run."
  },
  {
    "objectID": "slides/00-intro-overview.html#necessary-but-not-sufficient",
    "href": "slides/00-intro-overview.html#necessary-but-not-sufficient",
    "title": "Unix Shell Workshop",
    "section": "Necessary But Not Sufficient",
    "text": "Necessary But Not Sufficient\n\n\n\n\n\n\nNote\n\n\nThe fact that something is marked as executable doesn’t actually mean it contains a runnable program.\nMarking an HTML file executable won’t make it run as a program; the OS may instead open it in the associated application."
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-strings",
    "href": "slides/00-intro-overview.html#permission-strings",
    "title": "Unix Shell Workshop",
    "section": "Permission Strings",
    "text": "Permission Strings\nRun ls -l for a long-form listing:\nls -l\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n-rwxr-xr-x 1 nnemo bio 31988  2010-07-23 20:04 setup\n-rw-rw-r-- 1 nnemo bio  2312  2010-07-11 08:23 waiver.txt\nThe -l flag gives us detailed information."
  },
  {
    "objectID": "slides/00-intro-overview.html#reading-ls--l-output",
    "href": "slides/00-intro-overview.html#reading-ls--l-output",
    "title": "Unix Shell Workshop",
    "section": "Reading ls -l Output",
    "text": "Reading ls -l Output\nLet’s examine the columns from right to left:\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n\nRight side: Filename\nNext left: Last modified time and date\nNext: File size in bytes\nNext: Owner (nnemo) and group (bio)\nSecond column: Number of links (skip for now)\nFirst column: Permissions (most important!)"
  },
  {
    "objectID": "slides/00-intro-overview.html#understanding-permission-strings",
    "href": "slides/00-intro-overview.html#understanding-permission-strings",
    "title": "Unix Shell Workshop",
    "section": "Understanding Permission Strings",
    "text": "Understanding Permission Strings\nLet’s examine: -rwxr-xr-x\nFirst character: Type of thing - - = regular file - d = directory - Other characters for esoteric things\nNext 9 characters in groups of 3: - Owner permissions: rwx (read, write, execute) - Group permissions: r-x (read, execute, no write) - Others permissions: r-x (read, execute, no write)"
  },
  {
    "objectID": "slides/00-intro-overview.html#permission-string-breakdown",
    "href": "slides/00-intro-overview.html#permission-string-breakdown",
    "title": "Unix Shell Workshop",
    "section": "Permission String Breakdown",
    "text": "Permission String Breakdown\n-rwxr-xr-x\n\n- = regular file\nrwx = owner can read, write, and execute\nr-x = group can read and execute (dash means permission is off)\nr-x = everyone else can read and execute\n\nSo everyone on the system can look at the file’s contents and run it."
  },
  {
    "objectID": "slides/00-intro-overview.html#changing-permissions-with-chmod",
    "href": "slides/00-intro-overview.html#changing-permissions-with-chmod",
    "title": "Unix Shell Workshop",
    "section": "Changing Permissions with chmod",
    "text": "Changing Permissions with chmod\nHere’s a file with problematic permissions:\nls -l final.grd\n-rwxrwxrwx 1 nnemo bio  4215  2010-08-29 22:30 final.grd\nWhoops! Everyone can read it—and worse, modify it!\n(They could also try to run it as a program, which wouldn’t work.)"
  },
  {
    "objectID": "slides/00-intro-overview.html#chmod---change-owner-permissions",
    "href": "slides/00-intro-overview.html#chmod---change-owner-permissions",
    "title": "Unix Shell Workshop",
    "section": "chmod - Change Owner Permissions",
    "text": "chmod - Change Owner Permissions\nChange owner’s permissions to rw-:\nchmod u=rw final.grd\n\nu = changing privileges of the user (file’s owner)\nrw = new set of permissions\n\nVerify it worked:\nls -l final.grd\n-rw-rwxrwx 1 nnemo bio  4215  2010-08-30 08:19 final.grd"
  },
  {
    "objectID": "slides/00-intro-overview.html#chmod---change-group-permissions",
    "href": "slides/00-intro-overview.html#chmod---change-group-permissions",
    "title": "Unix Shell Workshop",
    "section": "chmod - Change Group Permissions",
    "text": "chmod - Change Group Permissions\nGive the group read-only permission:\nchmod g=r final.grd\nls -l final.grd\n-rw-r--rw- 1 nnemo bio  4215  2010-08-30 08:19 final.grd\nGroup now has r-- (read only)."
  },
  {
    "objectID": "slides/00-intro-overview.html#chmod---change-all-permissions",
    "href": "slides/00-intro-overview.html#chmod---change-all-permissions",
    "title": "Unix Shell Workshop",
    "section": "chmod - Change All Permissions",
    "text": "chmod - Change All Permissions\nGive “all” (everyone else) no permissions:\nchmod a= final.grd\nls -l final.grd\n-rw-r----- 1 nnemo bio  4215  2010-08-30 08:20 final.grd\n\na = changing permissions for “all”\nNothing after = means “all” has empty permissions"
  },
  {
    "objectID": "slides/00-intro-overview.html#octal-modes-shortcut",
    "href": "slides/00-intro-overview.html#octal-modes-shortcut",
    "title": "Unix Shell Workshop",
    "section": "Octal Modes (Shortcut)",
    "text": "Octal Modes (Shortcut)\n\n\n\n\n\n\nTip\n\n\nSymbolic modes like u=rw are clear, but you’ll often see octal numbers:\nchmod 755 script.sh   # owner rwx (7), group r-x (5), others r-x (5)\nchmod 644 notes.txt   # owner rw- (6), group r-- (4), others r-- (4)\nEach digit is a sum: read=4, write=2, execute=1."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge",
    "href": "slides/00-intro-overview.html#challenge",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nOctal chmod\n\n\nSet the permissions for script.sh so that the owner can read, write, and execute; the group can read and execute; and others have no permissions. Use octal mode.\n\nWhich octal number represents these permissions?\nWhich command will apply it to script.sh?"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution",
    "href": "slides/00-intro-overview.html#solution",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\n\nOwner rwx → 7, group r-x → 5, others — → 0, so the octal is 750.\n\nchmod 750 script.sh\nVariants you may see:\n\nchmod 750 ./script.sh (explicit path)\nchmod 0750 script.sh (leading 0 sometimes used, effect is the same)"
  },
  {
    "objectID": "slides/00-intro-overview.html#hidden-directory-entries",
    "href": "slides/00-intro-overview.html#hidden-directory-entries",
    "title": "Unix Shell Workshop",
    "section": "Hidden Directory Entries",
    "text": "Hidden Directory Entries\nRun ls -a -l to include normally hidden entries:\nls -a -l\ndrwxr-xr-x 1 nnemo bio     0  2010-08-14 09:55 .\ndrwxr-xr-x 1 nnemo bio  8192  2010-08-27 23:11 ..\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n-rwxr-xr-x 1 nnemo bio 31988  2010-07-23 20:04 setup\n-rw-rw-r-- 1 nnemo bio  2312  2010-07-11 08:23 waiver.txt\nNotice . and .. start with d (directory)."
  },
  {
    "objectID": "slides/00-intro-overview.html#what-does-x-mean-for-directories",
    "href": "slides/00-intro-overview.html#what-does-x-mean-for-directories",
    "title": "Unix Shell Workshop",
    "section": "What Does ‘x’ Mean for Directories?",
    "text": "What Does ‘x’ Mean for Directories?\nThe permissions for . and .. show ‘x’ (execute) is on.\nWhat does that mean? A directory isn’t a program—how can we “run” it?\nFor directories, ‘x’ means something different: - Gives the right to traverse the directory - But not to look at its contents\nThe distinction is subtle…"
  },
  {
    "objectID": "slides/00-intro-overview.html#directory-permission-example",
    "href": "slides/00-intro-overview.html#directory-permission-example",
    "title": "Unix Shell Workshop",
    "section": "Directory Permission Example",
    "text": "Directory Permission Example\nNelle’s home directory has three subdirectories:\n\nEach has a notes subdirectory with various files."
  },
  {
    "objectID": "slides/00-intro-overview.html#different-permission-scenarios",
    "href": "slides/00-intro-overview.html#different-permission-scenarios",
    "title": "Unix Shell Workshop",
    "section": "Different Permission Scenarios",
    "text": "Different Permission Scenarios\nIf permissions on venus are r-x: - User can see contents of both venus and venus/notes\nIf permissions on mars are r--: - User can read contents of both mars and mars/notes\nIf permissions on pluto are --x: - Cannot see what’s in pluto: ls pluto denied - But can look in pluto/notes if she knows it exists! - Allowed to go through pluto, but not look at what’s there"
  },
  {
    "objectID": "slides/00-intro-overview.html#making-directories-selectively-visible",
    "href": "slides/00-intro-overview.html#making-directories-selectively-visible",
    "title": "Unix Shell Workshop",
    "section": "Making Directories Selectively Visible",
    "text": "Making Directories Selectively Visible\nThis trick gives people a way to make some of their directories visible to the world without opening up everything else.\nUseful for: - Sharing specific subdirectories - Keeping parent directory contents private - Allowing access to known paths only"
  },
  {
    "objectID": "slides/00-intro-overview.html#what-about-windows",
    "href": "slides/00-intro-overview.html#what-about-windows",
    "title": "Unix Shell Workshop",
    "section": "What About Windows?",
    "text": "What About Windows?\nThings work differently on Windows.\nWindows uses Access Control Lists (ACLs): - A list of pairs: “who” + “what” - Example: Give Mummy permission to append without reading/deleting - Example: Give Frankenstein permission to delete without seeing contents\nMore flexible than Unix, but more complex to administer."
  },
  {
    "objectID": "slides/00-intro-overview.html#unix-vs-windows-permissions",
    "href": "slides/00-intro-overview.html#unix-vs-windows-permissions",
    "title": "Unix Shell Workshop",
    "section": "Unix vs Windows Permissions",
    "text": "Unix vs Windows Permissions\n\n\n\n\n\n\nNote\n\n\nUnix: owner/group/others with rwx triplets\nWindows: ACLs grant fine-grained rights per user or group\nSame ideas, different mechanisms.\n\n\n\nSome modern Unix variants support ACLs, but hardly anyone uses them."
  },
  {
    "objectID": "slides/00-intro-overview.html#challenge-1",
    "href": "slides/00-intro-overview.html#challenge-1",
    "title": "Unix Shell Workshop",
    "section": "Challenge",
    "text": "Challenge\n\n\n\n\nChallenge\n\n\nIf ls -l myfile.php returns the following details:\n-rwxr-xr-- 1 caro zoo  2312  2014-10-25 18:30 myfile.php\nWhich of the following statements is true?\n\ncaro (the owner) can read, write, and execute myfile.php\ncaro (the owner) cannot write to myfile.php\nmembers of caro (a group) can read, write, and execute myfile.php\nmembers of zoo (a group) cannot execute myfile.php"
  },
  {
    "objectID": "slides/00-intro-overview.html#solution-2",
    "href": "slides/00-intro-overview.html#solution-2",
    "title": "Unix Shell Workshop",
    "section": "Solution",
    "text": "Solution\n\n\n\n\nSolution\n\n\nOption 1 is correct.\nThe mode -rwxr-xr-- gives: - Owner: rwx (read, write, execute) - Group: r-x (read, execute, no write) - Others: r-- (read only)\nTherefore the owner can read, write, and execute; group members can read and execute (not write); others can only read."
  },
  {
    "objectID": "slides/00-intro-overview.html#key-points",
    "href": "slides/00-intro-overview.html#key-points",
    "title": "Unix Shell Workshop",
    "section": "Key Points",
    "text": "Key Points\n\n\nCorrect permissions are critical for the security of a system.\nFile permissions describe who and what can read, write, modify, and access a file.\nUse ls -l to view the permissions for a specific file.\nUse chmod to change permissions on a file or directory."
  },
  {
    "objectID": "slides/02-filedir.html",
    "href": "slides/02-filedir.html",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I move around on my computer?\nHow can I see what files and directories I have?\nHow can I specify the location of a file or directory on my computer?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nExplain the similarities and differences between a file and a directory.\nTranslate an absolute path into a relative path and vice versa.\nConstruct absolute and relative paths that identify specific files and directories.\nUse options and arguments to change the behaviour of a shell command.\nDemonstrate the use of tab completion and explain its advantages.\n\n\n\n\n\n\nFiles = store information\nDirectories (folders) = store files or other directories\n\n\n\n\n/ (root)\n├── bin\n├── data\n├── Users\n│   └── nelle\n├── tmp\n└── ...\nThe root directory is / - everything else is inside it.\n\n\n\n\n\n\n\n\n\nbin = built-in programs and commands\ndata = miscellaneous data files\nUsers = user home directories (e.g., /Users/nelle)\ntmp = temporary files that don’t need long-term storage\n\n\n\n\nWhere are you right now?\n$ pwd\n/Users/nelle\nThis shows your current working directory (your current location).\n\n\n\nThe shell usually starts in your home directory:\n\nmacOS: /Users/username\nLinux: /home/username\nWindows: C:\\Users\\username\n\n\n\n\nWhat’s in your current location?\n$ ls\nApplications  Documents    Library      Music        Public\nDesktop      Downloads    Movies       Pictures\n\n\n\nUse the -F flag to mark file types:\n$ ls -F\nApplications/  Documents/    Library/      Music/        Public/\nDesktop/       Downloads/    Movies/       Pictures/\n\n\n\n\n\n\nNote\n\n\n\n\n/ after name = directory\n* after name = executable file\n@ after name = symbolic link\nNo marker = regular file\n\n\n\n\n\n\nIf your screen gets cluttered:\nclear -x\nYou can still access previous commands using ↑ and ↓ to move line-by-line, or by scrolling in your terminal after clear -x.\nFor some Bash configurations, clear may also clear the scrollbuffer\n\n\n\n\n\n\nTip\n\n\n\nShortcut: Press Ctrl+L to clear the screen.\n\n\n\n\n\nThere are two common ways to learn command options:\n\n--help (Linux and Git Bash)\n\nls --help\n\nman (Linux and macOS)\n\nman ls\nPress q to quit the manual.\n\n\n\n\n\n\nTip\n\n\n\nBuilt-in commands: If man cd fails, try help cd instead.\n\n\n\n\n\n--help option displays more information on how to use the command or program.\nls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if neither -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options, too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n  -C                         list entries by columns\n      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n                               if omitted), 'auto', or 'never'; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=&gt;@|) to entries\n...        ...        ...\n\n\n\nUse short options when typing commands into the shell to minimize keystrokes and get your task done faster:\nls -F\nUse long options in scripts for clarity:\nls --classify\n\n\n\nIf you use an option the command doesn’t support, you’ll see an error:\nls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\nThis command will turn your terminal into a page with a description of the ls command and its options.\nman ls\nTo navigate through the man pages,\n\nuse ↑ and ↓ to move line-by-line\ntry b and Spacebar to skip up and down by a full page.\nuse / followed by the character or word you are searching for to find it in the manual.\nSometimes a search will result in multiple hits. If so, you can move between hits using N (for moving forward) and Shift+N (for moving backward).\npress q to quit the manual and return to the command prompt.\n\n\n\n\n\nThea third way to access help for commands is to search for the manual page on the web.\nWhen using internet search, including the phrase unix man page in your search query will help to find relevant results.\n\n\n\n\n\n\n\n\n\n\nExploring More ls Options\n\n\n\nYou can also use two options at the same time. What does the command ls do when used with the -l option? What about if you use both the -l and the -h option?\nSome of its output is about properties that we do not cover in this lesson (such as file permissions and ownership), but the rest should be useful nevertheless.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -l option makes ls use a long listing format, showing not only the file/directory names but also additional information, such as the file size and the time of its last modification. If you use both the -h option and the -l option, this makes the file size ‘human readable’, i.e. displaying something like 5.3K instead of 5369.\n\n\n\n\n\n\n\n\n\n\n\n\nListing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates.\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written.\n\n\n\n\n\n\nList contents of the Desktop directory:\n$ ls -F Desktop\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error.\n\n\n\nMove to a different location\n$ cd Desktop\n$ pwd\n/Users/nelle/Desktop\nNotice: cd produces no output, but pwd confirms you moved!\n\n\n\nGo deeper into the file structure:\n$ cd Desktop/shell-lesson-data\n$ cd exercise-data\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data/exercise-data\n\n\n\nCheck what’s here:\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/\n\n\n\nTo go to the parent directory (one level up):\n$ cd ..\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\n.. = “the directory containing this one”\n\n\n\nTo refer to the current directory:\n$ ls -F .\nThis lists the current directory (same as just ls -F).\n\n\n\n\n\n\nSymbol\nMeaning\n\n\n\n\n/ at start\nRoot directory\n\n\n/ between names\nPath separator\n\n\n..\nParent directory\n\n\n.\nCurrent directory\n\n\n~\nHome directory\n\n\n-\nPrevious directory\n\n\n\n\n\n\nThe special directory .. doesn’t usually show up when we run ls. To display it, add the -a option:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn addition to .. and ., you may see files like .bash_profile or .gitignore.\n\nThese files usually contain shell configuration settings\nThe prefix . prevents them from cluttering the terminal\nUse ls -a to see them\nMultiple options can be combined: ls -F -a = ls -Fa\n\n\n\n\n\n\n\n\n\n\nStarts with /\nWorks from anywhere on the computer\nExample: /Users/nelle/Desktop/shell-lesson-data\n\n\n\n\n\n\n\nDoes not start with /\nDepends on where you are now\nExample: Desktop/shell-lesson-data\n\n\n\n\n\n\nUse ~ to mean your home directory:\n$ cd ~/Desktop\n$ pwd\n/Users/nelle/Desktop\n\n\n\ncd with no arguments returns to home:\n$ cd\n$ pwd\n/Users/nelle\n\n\n\nGo to previous directory with -:\n$ cd -\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nGreat for switching between two locations!\n\n\n\nSave typing! Use Tab to auto-complete:\nType: ls nor then press Tab\n$ ls nor[TAB]\nBecomes:\n$ ls north-pacific-gyre/\nIf multiple options, press Tab twice to see all.\n\n\n\nWe have now encountered commands, options, and arguments.\nConsider this example:\nls -F /\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbsolute vs Relative Paths\n\n\n\nStarting from /Users/nelle/data, which of the following commands could Nelle use to navigate to her home directory, which is /Users/nelle?\n\ncd .\ncd /\ncd /home/nelle\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: Nelle’s home directory is /Users/nelle.\nNo: this command goes up two levels, i.e. ends in /Users.\nYes: ~ stands for the user’s home directory, in this case /Users/nelle.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user’s home directory.\nYes: goes up one level.\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/.\n\n\n\n\n\n\n\n\n\n\n\n\n\nls Reading Comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly.\n\n\n\n\n\n\n\nNelle is ready to organize the files from the protein assay machine.\n\n\nCreates directory north-pacific-gyre for her data\nEach sample has a unique 10-character ID (e.g., NENE01729A)\nFiles named like NENE01729A.txt, NENE01812A.txt, etc.\nAll 1520 files in the same directory\n\n\n\n\n\nNelle can see her files:\n$ ls north-pacific-gyre/\nBut that’s a lot to type! She can use tab completion:\n\n\nType ls nor and press Tab\nShell completes to ls north-pacific-gyre/\nPressing Tab again shows multiple files\nType ls north-pacific-gyre/goo and press Tab for files starting with “goo”"
  },
  {
    "objectID": "slides/02-filedir.html#the-file-system",
    "href": "slides/02-filedir.html#the-file-system",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Files = store information\nDirectories (folders) = store files or other directories"
  },
  {
    "objectID": "slides/02-filedir.html#the-file-system-tree",
    "href": "slides/02-filedir.html#the-file-system-tree",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "/ (root)\n├── bin\n├── data\n├── Users\n│   └── nelle\n├── tmp\n└── ...\nThe root directory is / - everything else is inside it."
  },
  {
    "objectID": "slides/02-filedir.html#what-these-folders-mean",
    "href": "slides/02-filedir.html#what-these-folders-mean",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "bin = built-in programs and commands\ndata = miscellaneous data files\nUsers = user home directories (e.g., /Users/nelle)\ntmp = temporary files that don’t need long-term storage"
  },
  {
    "objectID": "slides/02-filedir.html#pwd---print-working-directory",
    "href": "slides/02-filedir.html#pwd---print-working-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Where are you right now?\n$ pwd\n/Users/nelle\nThis shows your current working directory (your current location)."
  },
  {
    "objectID": "slides/02-filedir.html#your-home-directory",
    "href": "slides/02-filedir.html#your-home-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "The shell usually starts in your home directory:\n\nmacOS: /Users/username\nLinux: /home/username\nWindows: C:\\Users\\username"
  },
  {
    "objectID": "slides/02-filedir.html#ls---list-files-and-directories",
    "href": "slides/02-filedir.html#ls---list-files-and-directories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "What’s in your current location?\n$ ls\nApplications  Documents    Library      Music        Public\nDesktop      Downloads    Movies       Pictures"
  },
  {
    "objectID": "slides/02-filedir.html#making-ls-output-clearer",
    "href": "slides/02-filedir.html#making-ls-output-clearer",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Use the -F flag to mark file types:\n$ ls -F\nApplications/  Documents/    Library/      Music/        Public/\nDesktop/       Downloads/    Movies/       Pictures/\n\n\n\n\n\n\nNote\n\n\n\n\n/ after name = directory\n* after name = executable file\n@ after name = symbolic link\nNo marker = regular file"
  },
  {
    "objectID": "slides/02-filedir.html#clearing-your-terminal",
    "href": "slides/02-filedir.html#clearing-your-terminal",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "If your screen gets cluttered:\nclear -x\nYou can still access previous commands using ↑ and ↓ to move line-by-line, or by scrolling in your terminal after clear -x.\nFor some Bash configurations, clear may also clear the scrollbuffer\n\n\n\n\n\n\nTip\n\n\n\nShortcut: Press Ctrl+L to clear the screen."
  },
  {
    "objectID": "slides/02-filedir.html#getting-help",
    "href": "slides/02-filedir.html#getting-help",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "There are two common ways to learn command options:\n\n--help (Linux and Git Bash)\n\nls --help\n\nman (Linux and macOS)\n\nman ls\nPress q to quit the manual.\n\n\n\n\n\n\nTip\n\n\n\nBuilt-in commands: If man cd fails, try help cd instead."
  },
  {
    "objectID": "slides/02-filedir.html#the---help-option",
    "href": "slides/02-filedir.html#the---help-option",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "--help option displays more information on how to use the command or program.\nls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if neither -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options, too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n  -C                         list entries by columns\n      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n                               if omitted), 'auto', or 'never'; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=&gt;@|) to entries\n...        ...        ..."
  },
  {
    "objectID": "slides/02-filedir.html#short-vs-long-options",
    "href": "slides/02-filedir.html#short-vs-long-options",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Use short options when typing commands into the shell to minimize keystrokes and get your task done faster:\nls -F\nUse long options in scripts for clarity:\nls --classify"
  },
  {
    "objectID": "slides/02-filedir.html#unsupported-command-options",
    "href": "slides/02-filedir.html#unsupported-command-options",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "If you use an option the command doesn’t support, you’ll see an error:\nls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information."
  },
  {
    "objectID": "slides/02-filedir.html#the-man-command",
    "href": "slides/02-filedir.html#the-man-command",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "This command will turn your terminal into a page with a description of the ls command and its options.\nman ls\nTo navigate through the man pages,\n\nuse ↑ and ↓ to move line-by-line\ntry b and Spacebar to skip up and down by a full page.\nuse / followed by the character or word you are searching for to find it in the manual.\nSometimes a search will result in multiple hits. If so, you can move between hits using N (for moving forward) and Shift+N (for moving backward).\npress q to quit the manual and return to the command prompt."
  },
  {
    "objectID": "slides/02-filedir.html#manual-pages-on-the-web",
    "href": "slides/02-filedir.html#manual-pages-on-the-web",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Thea third way to access help for commands is to search for the manual page on the web.\nWhen using internet search, including the phrase unix man page in your search query will help to find relevant results."
  },
  {
    "objectID": "slides/02-filedir.html#challenge",
    "href": "slides/02-filedir.html#challenge",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Exploring More ls Options\n\n\n\nYou can also use two options at the same time. What does the command ls do when used with the -l option? What about if you use both the -l and the -h option?\nSome of its output is about properties that we do not cover in this lesson (such as file permissions and ownership), but the rest should be useful nevertheless."
  },
  {
    "objectID": "slides/02-filedir.html#solution",
    "href": "slides/02-filedir.html#solution",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe -l option makes ls use a long listing format, showing not only the file/directory names but also additional information, such as the file size and the time of its last modification. If you use both the -h option and the -l option, this makes the file size ‘human readable’, i.e. displaying something like 5.3K instead of 5369."
  },
  {
    "objectID": "slides/02-filedir.html#challenge-1",
    "href": "slides/02-filedir.html#challenge-1",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Listing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates."
  },
  {
    "objectID": "slides/02-filedir.html#solution-2",
    "href": "slides/02-filedir.html#solution-2",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written."
  },
  {
    "objectID": "slides/02-filedir.html#exploring-other-directories",
    "href": "slides/02-filedir.html#exploring-other-directories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "List contents of the Desktop directory:\n$ ls -F Desktop\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error."
  },
  {
    "objectID": "slides/02-filedir.html#cd---change-directory",
    "href": "slides/02-filedir.html#cd---change-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Move to a different location\n$ cd Desktop\n$ pwd\n/Users/nelle/Desktop\nNotice: cd produces no output, but pwd confirms you moved!"
  },
  {
    "objectID": "slides/02-filedir.html#moving-into-subdirectories",
    "href": "slides/02-filedir.html#moving-into-subdirectories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Go deeper into the file structure:\n$ cd Desktop/shell-lesson-data\n$ cd exercise-data\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data/exercise-data"
  },
  {
    "objectID": "slides/02-filedir.html#listing-current-directory",
    "href": "slides/02-filedir.html#listing-current-directory",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Check what’s here:\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/"
  },
  {
    "objectID": "slides/02-filedir.html#moving-up-one-level-..",
    "href": "slides/02-filedir.html#moving-up-one-level-..",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "To go to the parent directory (one level up):\n$ cd ..\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\n.. = “the directory containing this one”"
  },
  {
    "objectID": "slides/02-filedir.html#current-directory-.",
    "href": "slides/02-filedir.html#current-directory-.",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "To refer to the current directory:\n$ ls -F .\nThis lists the current directory (same as just ls -F)."
  },
  {
    "objectID": "slides/02-filedir.html#special-symbols-in-paths",
    "href": "slides/02-filedir.html#special-symbols-in-paths",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Symbol\nMeaning\n\n\n\n\n/ at start\nRoot directory\n\n\n/ between names\nPath separator\n\n\n..\nParent directory\n\n\n.\nCurrent directory\n\n\n~\nHome directory\n\n\n-\nPrevious directory"
  },
  {
    "objectID": "slides/02-filedir.html#hidden-files-and-directories",
    "href": "slides/02-filedir.html#hidden-files-and-directories",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "The special directory .. doesn’t usually show up when we run ls. To display it, add the -a option:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/"
  },
  {
    "objectID": "slides/02-filedir.html#other-hidden-files",
    "href": "slides/02-filedir.html#other-hidden-files",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nIn addition to .. and ., you may see files like .bash_profile or .gitignore.\n\nThese files usually contain shell configuration settings\nThe prefix . prevents them from cluttering the terminal\nUse ls -a to see them\nMultiple options can be combined: ls -F -a = ls -Fa"
  },
  {
    "objectID": "slides/02-filedir.html#two-types-of-paths",
    "href": "slides/02-filedir.html#two-types-of-paths",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Starts with /\nWorks from anywhere on the computer\nExample: /Users/nelle/Desktop/shell-lesson-data\n\n\n\n\n\n\n\nDoes not start with /\nDepends on where you are now\nExample: Desktop/shell-lesson-data"
  },
  {
    "objectID": "slides/02-filedir.html#home-directory-shortcut",
    "href": "slides/02-filedir.html#home-directory-shortcut",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Use ~ to mean your home directory:\n$ cd ~/Desktop\n$ pwd\n/Users/nelle/Desktop"
  },
  {
    "objectID": "slides/02-filedir.html#return-to-home",
    "href": "slides/02-filedir.html#return-to-home",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "cd with no arguments returns to home:\n$ cd\n$ pwd\n/Users/nelle"
  },
  {
    "objectID": "slides/02-filedir.html#navigate-back-and-forth",
    "href": "slides/02-filedir.html#navigate-back-and-forth",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Go to previous directory with -:\n$ cd -\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nGreat for switching between two locations!"
  },
  {
    "objectID": "slides/02-filedir.html#tab-completion",
    "href": "slides/02-filedir.html#tab-completion",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Save typing! Use Tab to auto-complete:\nType: ls nor then press Tab\n$ ls nor[TAB]\nBecomes:\n$ ls north-pacific-gyre/\nIf multiple options, press Tab twice to see all."
  },
  {
    "objectID": "slides/02-filedir.html#general-syntax-of-a-shell-command",
    "href": "slides/02-filedir.html#general-syntax-of-a-shell-command",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "We have now encountered commands, options, and arguments.\nConsider this example:\nls -F /"
  },
  {
    "objectID": "slides/02-filedir.html#challenge-2",
    "href": "slides/02-filedir.html#challenge-2",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Absolute vs Relative Paths\n\n\n\nStarting from /Users/nelle/data, which of the following commands could Nelle use to navigate to her home directory, which is /Users/nelle?\n\ncd .\ncd /\ncd /home/nelle\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd .."
  },
  {
    "objectID": "slides/02-filedir.html#solution-4",
    "href": "slides/02-filedir.html#solution-4",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: Nelle’s home directory is /Users/nelle.\nNo: this command goes up two levels, i.e. ends in /Users.\nYes: ~ stands for the user’s home directory, in this case /Users/nelle.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user’s home directory.\nYes: goes up one level."
  },
  {
    "objectID": "slides/02-filedir.html#challenge-3",
    "href": "slides/02-filedir.html#challenge-3",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Relative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/"
  },
  {
    "objectID": "slides/02-filedir.html#solution-6",
    "href": "slides/02-filedir.html#solution-6",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/."
  },
  {
    "objectID": "slides/02-filedir.html#challenge-4",
    "href": "slides/02-filedir.html#challenge-4",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "ls Reading Comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup"
  },
  {
    "objectID": "slides/02-filedir.html#solution-8",
    "href": "slides/02-filedir.html#solution-8",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly."
  },
  {
    "objectID": "slides/02-filedir.html#nelles-pipeline-organizing-files",
    "href": "slides/02-filedir.html#nelles-pipeline-organizing-files",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Nelle is ready to organize the files from the protein assay machine.\n\n\nCreates directory north-pacific-gyre for her data\nEach sample has a unique 10-character ID (e.g., NENE01729A)\nFiles named like NENE01729A.txt, NENE01812A.txt, etc.\nAll 1520 files in the same directory"
  },
  {
    "objectID": "slides/02-filedir.html#using-tab-completion",
    "href": "slides/02-filedir.html#using-tab-completion",
    "title": "Episode 2: Navigating Files and Directories",
    "section": "",
    "text": "Nelle can see her files:\n$ ls north-pacific-gyre/\nBut that’s a lot to type! She can use tab completion:\n\n\nType ls nor and press Tab\nShell completes to ls north-pacific-gyre/\nPressing Tab again shows multiple files\nType ls north-pacific-gyre/goo and press Tab for files starting with “goo”"
  },
  {
    "objectID": "slides/03-create.html",
    "href": "slides/03-create.html",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I create, copy, and delete files and directories?\nHow can I edit files?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nDelete, copy and move specified files and/or directories.\nCreate files in that hierarchy using an editor or by copying and renaming existing files.\nCreate a directory hierarchy that matches a given diagram.\n\n\n\n\n\nWe now know how to explore files and directories, but how do we create them?\n\n\nFirst, check where we are:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nMove to exercise-data/writing and see what’s there:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt\n\n\n\n\nCreate a new directory called thesis:\nmkdir thesis\nmkdir means “make directory”\nCheck it was created:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/\n\n\n\nSince we just created it:\nls -F thesis\nNo output means the directory is empty.\n\n\n\nThe -p option creates nested subdirectories in one operation:\nmkdir -p ../project/data ../project/results\nUse ls -FR to recursively list the new hierarchy:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nUsing the shell to create a directory is no different than using a file explorer.\nIf you open the current directory using your operating system’s graphical file explorer, the thesis directory will appear there too.\nThe shell and the file explorer are two different ways of interacting with the files, but the files and directories themselves are the same.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nTips for naming files and directories:\n\nDon’t use spaces - Use - or _ instead\n\nGood: north-pacific-gyre/\nBad: north pacific gyre/\n\nDon’t begin with - - Commands treat these as options\nStick with: lowercase letters, numbers, ., -, _\n\nMany special characters have special meanings\n\n\n\n\n\n\n\nIf you need to refer to names with spaces or special characters, surround the name in quotes:\n'my file with spaces.txt'\nBest practice:\n\n\nUse all lowercase letters\nWindows and macOS are typically case insensitive\nCan’t distinguish between thesis and Thesis in same directory\n\n\n\n\n\nChange to thesis directory and create a file with nano:\ncd thesis\nnano draft.txt\nnano is a simple text editor that runs in your terminal.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nnano is a text editor - it only works with plain character data.\nOther options:\n\nUnix: Emacs, Vim, Gedit, VSCode\nWindows: Notepad++, notepad\n\nImportant: Know where your editor searches for and saves files!\n\n\n\n\n\nType some text,\n\nThen,\n\nPress Ctrl+O to write data to disk\nPress Return to accept filename draft.txt\nPress Ctrl+X to quit and return to shell\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe Control key can be described in various ways:\n\nControl-X, Control+X\nCtrl-X, Ctrl+X\n^X\nC-x\n\nIn nano, the bottom shows: ^G Get Help ^O WriteOut\nThis means Ctrl+G for help, Ctrl+O to save.\n\n\n\n\n\nnano doesn’t leave output, but ls confirms the file exists:\nls\ndraft.txt\n\n\n\n\n\n\n\n\n\nCreating Files a Different Way\n\n\n\nTry this command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you’ve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMost file names are something.extension:\n\n.txt = plain text file\n.pdf = PDF document\n.cfg = configuration file\n.png = PNG image\n\nImportant: This is just a convention! Files contain bytes. Naming whale.png as whale.mp3 doesn’t make it a sound file - it might just confuse programs trying to open it.\n\n\n\n\n\nReturn to the writing directory:\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\ndraft.txt isn’t a very informative name. Let’s rename it using mv:\nmv thesis/draft.txt thesis/quotes.txt\n\n\n\nmv [old] [new] moves or renames files\nCheck the result:\nls thesis\nquotes.txt\nWarning: mv will silently overwrite existing files with the same name!\nUse mv -i or mv --interactive to ask for confirmation before overwriting.\n\n\n\nMove quotes.txt to the current working directory:\nmv thesis/quotes.txt .\nThe . means “current directory”\nVerify thesis is now empty:\nls thesis\n$\n\n\n\nTry to list the file in thesis:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nConfirm it’s in current directory:\nls quotes.txt\nquotes.txt\n\n\n\n\n\n\n\n\n\nMoving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e. the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e. one above the current directory) and that . refers to the current directory.\n\n\n\n\n\n\nThe cp command copies instead of moving:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nls can take multiple paths to show multiple files at once.\n\n\n\nUse the -r (recursive) option to copy directories:\ncp -r thesis thesis_backup\nCheck both directories:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\n\n\n\nIf you omit -r when copying a directory:\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\nThe -r flag is required to copy directories.\n\n\n\n\n\n\n\n\n\nRenaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo. While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‘go up a level’, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\n\n\n\n\n\n\n\nReturn to the writing directory and remove quotes.txt:\nrm quotes.txt\nConfirm it’s gone:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThe Unix shell doesn’t have a trash bin!\nWhen we delete files, they are unlinked from the file system so their storage space can be recycled.\nTools for finding and recovering deleted files exist, but there’s no guarantee they’ll work - the computer may recycle the file’s disk space right away.\n\n\n\n\n\n\n\n\n\n\n\nUsing rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\n\n\n\nIf we try to remove a directory with just rm:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nrm by default only works on files, not directories.\n\n\n\nUse -r (recursive) to remove a directory and all contents:\nrm -r thesis\n⚠️ Warning: This works without confirmation prompts!\nGiven that files can’t be retrieved, use rm -r with great caution.\nConsider using rm -r -i for interactive confirmation.\n\n\n\nOftentimes we need to copy or move several files at once.\nThis can be done by:\n\n\nProviding a list of individual filenames\nSpecifying a naming pattern using wildcards\n\n\nWildcards are special characters that represent unknown characters or sets of characters.\n\n\n\n\n\n\n\n\n\nCopy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let’s try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory, cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n* is a wildcard - represents zero or more characters.\nIn shell-lesson-data/exercise-data/alkanes:\n\n*.pdb matches ethane.pdb, propane.pdb, and all files ending in .pdb\np*.pdb only matches pentane.pdb and propane.pdb\n\n? is also a wildcard\n\nrepresents exactly one character.\n?ethane.pdb matches methane.pdb\n*ethane.pdb matches ethane.pdb and methane.pdb\n\n\n\n\n\n\nWildcards can be used together:\n\n\n???ane.pdb = three characters followed by ane.pdb\n\nMatches: cubane.pdb, ethane.pdb, octane.pdb\n\n\n\nHow wildcards work:\nThe shell expands wildcards to create a list of matching filenames before running the command.\nException: If no files match, Bash passes the expression as-is to the command.\n\n\n\n\n\n\n\n\n\nList filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn’t match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   └── datasets\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    └── all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   │   ├── 2015-10-23-calibration.txt\n│   │   ├── 2015-10-26-calibration.txt\n│   │   └── 2015-11-23-calibration.txt\n│   └── datasets\n│       ├── 2015-10-23-dataset1.txt\n│       ├── 2015-10-23-dataset2.txt\n│       ├── 2015-10-23-dataset_overview.txt\n│       ├── 2015-10-26-dataset1.txt\n│       ├── 2015-10-26-dataset2.txt\n│       ├── 2015-10-26-dataset_overview.txt\n│       ├── 2015-11-23-dataset1.txt\n│       ├── 2015-11-23-dataset2.txt\n│       └── 2015-11-23-dataset_overview.txt\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    │   ├── 2015-10-23-dataset1.txt\n    │   ├── 2015-10-23-dataset2.txt\n    │   ├── 2015-10-23-dataset_overview.txt\n    │   ├── 2015-11-23-dataset1.txt\n    │   ├── 2015-11-23-dataset2.txt\n    │   └── 2015-11-23-dataset_overview.txt\n    └── all_november_files\n        ├── 2015-11-23-calibration.txt\n        ├── 2015-11-23-dataset1.txt\n        ├── 2015-11-23-dataset2.txt\n        └── 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\n\n\n\nOrganizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren’t very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‘analyzed’ directory.\n\n\n\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nYou’re starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n└── data\n   ├── processed\n   └── raw\n\n\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won’t create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‘raw’ and ‘processed’ directories at the same level as the ‘data’ directory."
  },
  {
    "objectID": "slides/03-create.html#creating-directories",
    "href": "slides/03-create.html#creating-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "We now know how to explore files and directories, but how do we create them?\n\n\nFirst, check where we are:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nMove to exercise-data/writing and see what’s there:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt"
  },
  {
    "objectID": "slides/03-create.html#creating-a-directory",
    "href": "slides/03-create.html#creating-a-directory",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Create a new directory called thesis:\nmkdir thesis\nmkdir means “make directory”\nCheck it was created:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/"
  },
  {
    "objectID": "slides/03-create.html#verify-the-directory-is-empty",
    "href": "slides/03-create.html#verify-the-directory-is-empty",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Since we just created it:\nls -F thesis\nNo output means the directory is empty."
  },
  {
    "objectID": "slides/03-create.html#creating-nested-directories",
    "href": "slides/03-create.html#creating-nested-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "The -p option creates nested subdirectories in one operation:\nmkdir -p ../project/data ../project/results\nUse ls -FR to recursively list the new hierarchy:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:"
  },
  {
    "objectID": "slides/03-create.html#two-ways-of-doing-the-same-thing",
    "href": "slides/03-create.html#two-ways-of-doing-the-same-thing",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nUsing the shell to create a directory is no different than using a file explorer.\nIf you open the current directory using your operating system’s graphical file explorer, the thesis directory will appear there too.\nThe shell and the file explorer are two different ways of interacting with the files, but the files and directories themselves are the same."
  },
  {
    "objectID": "slides/03-create.html#good-names-for-files-and-directories",
    "href": "slides/03-create.html#good-names-for-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Tip\n\n\n\nTips for naming files and directories:\n\nDon’t use spaces - Use - or _ instead\n\nGood: north-pacific-gyre/\nBad: north pacific gyre/\n\nDon’t begin with - - Commands treat these as options\nStick with: lowercase letters, numbers, ., -, _\n\nMany special characters have special meanings"
  },
  {
    "objectID": "slides/03-create.html#spaces-and-special-characters",
    "href": "slides/03-create.html#spaces-and-special-characters",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "If you need to refer to names with spaces or special characters, surround the name in quotes:\n'my file with spaces.txt'\nBest practice:\n\n\nUse all lowercase letters\nWindows and macOS are typically case insensitive\nCan’t distinguish between thesis and Thesis in same directory"
  },
  {
    "objectID": "slides/03-create.html#creating-a-text-file",
    "href": "slides/03-create.html#creating-a-text-file",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Change to thesis directory and create a file with nano:\ncd thesis\nnano draft.txt\nnano is a simple text editor that runs in your terminal."
  },
  {
    "objectID": "slides/03-create.html#which-editor",
    "href": "slides/03-create.html#which-editor",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nnano is a text editor - it only works with plain character data.\nOther options:\n\nUnix: Emacs, Vim, Gedit, VSCode\nWindows: Notepad++, notepad\n\nImportant: Know where your editor searches for and saves files!"
  },
  {
    "objectID": "slides/03-create.html#using-nano",
    "href": "slides/03-create.html#using-nano",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Type some text,\n\nThen,\n\nPress Ctrl+O to write data to disk\nPress Return to accept filename draft.txt\nPress Ctrl+X to quit and return to shell"
  },
  {
    "objectID": "slides/03-create.html#control-key-notation",
    "href": "slides/03-create.html#control-key-notation",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Tip\n\n\n\nThe Control key can be described in various ways:\n\nControl-X, Control+X\nCtrl-X, Ctrl+X\n^X\nC-x\n\nIn nano, the bottom shows: ^G Get Help ^O WriteOut\nThis means Ctrl+G for help, Ctrl+O to save."
  },
  {
    "objectID": "slides/03-create.html#verify-file-creation",
    "href": "slides/03-create.html#verify-file-creation",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "nano doesn’t leave output, but ls confirms the file exists:\nls\ndraft.txt"
  },
  {
    "objectID": "slides/03-create.html#challenge",
    "href": "slides/03-create.html#challenge",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Creating Files a Different Way\n\n\n\nTry this command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?"
  },
  {
    "objectID": "slides/03-create.html#solution",
    "href": "slides/03-create.html#solution",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you’ve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt"
  },
  {
    "objectID": "slides/03-create.html#whats-in-a-name",
    "href": "slides/03-create.html#whats-in-a-name",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\nMost file names are something.extension:\n\n.txt = plain text file\n.pdf = PDF document\n.cfg = configuration file\n.png = PNG image\n\nImportant: This is just a convention! Files contain bytes. Naming whale.png as whale.mp3 doesn’t make it a sound file - it might just confuse programs trying to open it."
  },
  {
    "objectID": "slides/03-create.html#moving-files-and-directories",
    "href": "slides/03-create.html#moving-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Return to the writing directory:\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\ndraft.txt isn’t a very informative name. Let’s rename it using mv:\nmv thesis/draft.txt thesis/quotes.txt"
  },
  {
    "objectID": "slides/03-create.html#how-mv-works",
    "href": "slides/03-create.html#how-mv-works",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "mv [old] [new] moves or renames files\nCheck the result:\nls thesis\nquotes.txt\nWarning: mv will silently overwrite existing files with the same name!\nUse mv -i or mv --interactive to ask for confirmation before overwriting."
  },
  {
    "objectID": "slides/03-create.html#moving-to-current-directory",
    "href": "slides/03-create.html#moving-to-current-directory",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Move quotes.txt to the current working directory:\nmv thesis/quotes.txt .\nThe . means “current directory”\nVerify thesis is now empty:\nls thesis\n$"
  },
  {
    "objectID": "slides/03-create.html#confirming-file-location",
    "href": "slides/03-create.html#confirming-file-location",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Try to list the file in thesis:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nConfirm it’s in current directory:\nls quotes.txt\nquotes.txt"
  },
  {
    "objectID": "slides/03-create.html#challenge-1",
    "href": "slides/03-create.html#challenge-1",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Moving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e. the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____"
  },
  {
    "objectID": "slides/03-create.html#solution-2",
    "href": "slides/03-create.html#solution-2",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e. one above the current directory) and that . refers to the current directory."
  },
  {
    "objectID": "slides/03-create.html#copying-files-and-directories",
    "href": "slides/03-create.html#copying-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "The cp command copies instead of moving:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nls can take multiple paths to show multiple files at once."
  },
  {
    "objectID": "slides/03-create.html#copying-directories",
    "href": "slides/03-create.html#copying-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Use the -r (recursive) option to copy directories:\ncp -r thesis thesis_backup\nCheck both directories:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt"
  },
  {
    "objectID": "slides/03-create.html#forgetting--r-when-copying-directories",
    "href": "slides/03-create.html#forgetting--r-when-copying-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "If you omit -r when copying a directory:\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\nThe -r flag is required to copy directories."
  },
  {
    "objectID": "slides/03-create.html#challenge-2",
    "href": "slides/03-create.html#challenge-2",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Renaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt ."
  },
  {
    "objectID": "slides/03-create.html#solution-4",
    "href": "slides/03-create.html#solution-4",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nNo. While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created."
  },
  {
    "objectID": "slides/03-create.html#challenge-3",
    "href": "slides/03-create.html#challenge-3",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Moving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat"
  },
  {
    "objectID": "slides/03-create.html#solution-6",
    "href": "slides/03-create.html#solution-6",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‘go up a level’, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie"
  },
  {
    "objectID": "slides/03-create.html#removing-files-and-directories",
    "href": "slides/03-create.html#removing-files-and-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Return to the writing directory and remove quotes.txt:\nrm quotes.txt\nConfirm it’s gone:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory"
  },
  {
    "objectID": "slides/03-create.html#deleting-is-forever",
    "href": "slides/03-create.html#deleting-is-forever",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Caution\n\n\n\nThe Unix shell doesn’t have a trash bin!\nWhen we delete files, they are unlinked from the file system so their storage space can be recycled.\nTools for finding and recovering deleted files exist, but there’s no guarantee they’ll work - the computer may recycle the file’s disk space right away."
  },
  {
    "objectID": "slides/03-create.html#challenge-4",
    "href": "slides/03-create.html#challenge-4",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Using rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?"
  },
  {
    "objectID": "slides/03-create.html#solution-8",
    "href": "slides/03-create.html#solution-8",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove."
  },
  {
    "objectID": "slides/03-create.html#removing-directories",
    "href": "slides/03-create.html#removing-directories",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "If we try to remove a directory with just rm:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nrm by default only works on files, not directories."
  },
  {
    "objectID": "slides/03-create.html#removing-directories-with--r",
    "href": "slides/03-create.html#removing-directories-with--r",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Use -r (recursive) to remove a directory and all contents:\nrm -r thesis\n⚠️ Warning: This works without confirmation prompts!\nGiven that files can’t be retrieved, use rm -r with great caution.\nConsider using rm -r -i for interactive confirmation."
  },
  {
    "objectID": "slides/03-create.html#operations-with-multiple-files",
    "href": "slides/03-create.html#operations-with-multiple-files",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Oftentimes we need to copy or move several files at once.\nThis can be done by:\n\n\nProviding a list of individual filenames\nSpecifying a naming pattern using wildcards\n\n\nWildcards are special characters that represent unknown characters or sets of characters."
  },
  {
    "objectID": "slides/03-create.html#challenge-5",
    "href": "slides/03-create.html#challenge-5",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Copy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let’s try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat"
  },
  {
    "objectID": "slides/03-create.html#solution-10",
    "href": "slides/03-create.html#solution-10",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory, cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory"
  },
  {
    "objectID": "slides/03-create.html#using-wildcards",
    "href": "slides/03-create.html#using-wildcards",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Note\n\n\n\n* is a wildcard - represents zero or more characters.\nIn shell-lesson-data/exercise-data/alkanes:\n\n*.pdb matches ethane.pdb, propane.pdb, and all files ending in .pdb\np*.pdb only matches pentane.pdb and propane.pdb\n\n? is also a wildcard\n\nrepresents exactly one character.\n?ethane.pdb matches methane.pdb\n*ethane.pdb matches ethane.pdb and methane.pdb"
  },
  {
    "objectID": "slides/03-create.html#wildcards-in-combination",
    "href": "slides/03-create.html#wildcards-in-combination",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Wildcards can be used together:\n\n\n???ane.pdb = three characters followed by ane.pdb\n\nMatches: cubane.pdb, ethane.pdb, octane.pdb\n\n\n\nHow wildcards work:\nThe shell expands wildcards to create a list of matching filenames before running the command.\nException: If no files match, Bash passes the expression as-is to the command."
  },
  {
    "objectID": "slides/03-create.html#challenge-6",
    "href": "slides/03-create.html#challenge-6",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "List filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*"
  },
  {
    "objectID": "slides/03-create.html#solution-12",
    "href": "slides/03-create.html#solution-12",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn’t match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane.."
  },
  {
    "objectID": "slides/03-create.html#challenge-7",
    "href": "slides/03-create.html#challenge-7",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "More on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   └── datasets\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    └── all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/"
  },
  {
    "objectID": "slides/03-create.html#challenge-8",
    "href": "slides/03-create.html#challenge-8",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "More on Wildcards\n\n\n\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   │   ├── 2015-10-23-calibration.txt\n│   │   ├── 2015-10-26-calibration.txt\n│   │   └── 2015-11-23-calibration.txt\n│   └── datasets\n│       ├── 2015-10-23-dataset1.txt\n│       ├── 2015-10-23-dataset2.txt\n│       ├── 2015-10-23-dataset_overview.txt\n│       ├── 2015-10-26-dataset1.txt\n│       ├── 2015-10-26-dataset2.txt\n│       ├── 2015-10-26-dataset_overview.txt\n│       ├── 2015-11-23-dataset1.txt\n│       ├── 2015-11-23-dataset2.txt\n│       └── 2015-11-23-dataset_overview.txt\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    │   ├── 2015-10-23-dataset1.txt\n    │   ├── 2015-10-23-dataset2.txt\n    │   ├── 2015-10-23-dataset_overview.txt\n    │   ├── 2015-11-23-dataset1.txt\n    │   ├── 2015-11-23-dataset2.txt\n    │   └── 2015-11-23-dataset_overview.txt\n    └── all_november_files\n        ├── 2015-11-23-calibration.txt\n        ├── 2015-11-23-dataset1.txt\n        ├── 2015-11-23-dataset2.txt\n        └── 2015-11-23-dataset_overview.txt"
  },
  {
    "objectID": "slides/03-create.html#solution-14",
    "href": "slides/03-create.html#solution-14",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/"
  },
  {
    "objectID": "slides/03-create.html#challenge-9",
    "href": "slides/03-create.html#challenge-9",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Organizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren’t very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat"
  },
  {
    "objectID": "slides/03-create.html#solution-16",
    "href": "slides/03-create.html#solution-16",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‘analyzed’ directory."
  },
  {
    "objectID": "slides/03-create.html#challenge-10",
    "href": "slides/03-create.html#challenge-10",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Reproduce a folder structure\n\n\n\nYou’re starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n└── data\n   ├── processed\n   └── raw"
  },
  {
    "objectID": "slides/03-create.html#challenge-11",
    "href": "slides/03-create.html#challenge-11",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Reproduce a folder structure\n\n\n\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed"
  },
  {
    "objectID": "slides/03-create.html#solution-18",
    "href": "slides/03-create.html#solution-18",
    "title": "Episode 3: Working With Files and Directories",
    "section": "",
    "text": "Solution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won’t create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‘raw’ and ‘processed’ directories at the same level as the ‘data’ directory."
  },
  {
    "objectID": "slides/05-pipefilter.html#the-power-of-pipes",
    "href": "slides/05-pipefilter.html#the-power-of-pipes",
    "title": "Episode 5: Pipes and Filters",
    "section": "The Power of Pipes",
    "text": "The Power of Pipes\nCombine simple programs into powerful workflows!\nInstead of: - Create intermediate files - Run separate commands - Clean up temporary files\nWe can: - Chain commands together - Process data in steps - Keep everything clean"
  },
  {
    "objectID": "slides/05-pipefilter.html#sample-data",
    "href": "slides/05-pipefilter.html#sample-data",
    "title": "Episode 5: Pipes and Filters",
    "section": "Sample Data",
    "text": "Sample Data\nWe have 6 molecular data files:\n$ ls *.pdb\ncubane.pdb    methane.pdb    pentane.pdb\nethane.pdb    octane.pdb     propane.pdb"
  },
  {
    "objectID": "slides/05-pipefilter.html#command-1-wc---count-lines-words-characters",
    "href": "slides/05-pipefilter.html#command-1-wc---count-lines-words-characters",
    "title": "Episode 5: Pipes and Filters",
    "section": "Command 1: wc - Count Lines, Words, Characters",
    "text": "Command 1: wc - Count Lines, Words, Characters\n$ wc cubane.pdb\n20  156  1158  cubane.pdb\n\n20 = lines\n156 = words\n\n1158 = characters"
  },
  {
    "objectID": "slides/05-pipefilter.html#using-wildcards-with-wc",
    "href": "slides/05-pipefilter.html#using-wildcards-with-wc",
    "title": "Episode 5: Pipes and Filters",
    "section": "Using Wildcards with wc",
    "text": "Using Wildcards with wc\nCount all .pdb files:\n$ wc *.pdb\n  20  156  1158  cubane.pdb\n  12   84   622  ethane.pdb\n   9   57   422  methane.pdb\n  30  246  1828  octane.pdb\n  21  165  1226  pentane.pdb\n  15  111   825  propane.pdb\n 107  819  6081  total"
  },
  {
    "objectID": "slides/05-pipefilter.html#wc-with-options",
    "href": "slides/05-pipefilter.html#wc-with-options",
    "title": "Episode 5: Pipes and Filters",
    "section": "wc with Options",
    "text": "wc with Options\nCount only lines:\n$ wc -l *.pdb\n  20  cubane.pdb\n  12  ethane.pdb\n  ...\n 107  total\nOther options: -m (characters), -w (words)"
  },
  {
    "objectID": "slides/05-pipefilter.html#command-2-cat---display-file-contents",
    "href": "slides/05-pipefilter.html#command-2-cat---display-file-contents",
    "title": "Episode 5: Pipes and Filters",
    "section": "Command 2: cat - Display File Contents",
    "text": "Command 2: cat - Display File Contents\n$ cat cubane.pdb\nOutputs the entire file contents to the terminal.\nUse with wildcards:\n$ cat *.pdb\nDisplays all files sequentially."
  },
  {
    "objectID": "slides/05-pipefilter.html#command-3-sort---sort-lines",
    "href": "slides/05-pipefilter.html#command-3-sort---sort-lines",
    "title": "Episode 5: Pipes and Filters",
    "section": "Command 3: sort - Sort Lines",
    "text": "Command 3: sort - Sort Lines\n$ sort names.txt\nSorts lines in alphabetical order."
  },
  {
    "objectID": "slides/05-pipefilter.html#command-4-head---first-lines",
    "href": "slides/05-pipefilter.html#command-4-head---first-lines",
    "title": "Episode 5: Pipes and Filters",
    "section": "Command 4: head - First Lines",
    "text": "Command 4: head - First Lines\nShow first 10 lines by default:\n$ head cubane.pdb\nShow first 5 lines:\n$ head -n 5 cubane.pdb"
  },
  {
    "objectID": "slides/05-pipefilter.html#command-5-tail---last-lines",
    "href": "slides/05-pipefilter.html#command-5-tail---last-lines",
    "title": "Episode 5: Pipes and Filters",
    "section": "Command 5: tail - Last Lines",
    "text": "Command 5: tail - Last Lines\nShow last 10 lines by default:\n$ tail cubane.pdb\nShow last 3 lines:\n$ tail -n 3 cubane.pdb"
  },
  {
    "objectID": "slides/05-pipefilter.html#the-pipe",
    "href": "slides/05-pipefilter.html#the-pipe",
    "title": "Episode 5: Pipes and Filters",
    "section": "The Pipe: |",
    "text": "The Pipe: |\nConnect two commands!\nOutput of first command becomes input of second:\n$ command1 | command2\nThink of it like a water pipe carrying data."
  },
  {
    "objectID": "slides/05-pipefilter.html#pipe-example",
    "href": "slides/05-pipefilter.html#pipe-example",
    "title": "Episode 5: Pipes and Filters",
    "section": "Pipe Example",
    "text": "Pipe Example\nShow last 5 lines of a file:\n$ wc -l cubane.pdb\n20  cubane.pdb\nvs.\n$ head -n 5 cubane.pdb | tail -n 5"
  },
  {
    "objectID": "slides/05-pipefilter.html#multiple-pipes",
    "href": "slides/05-pipefilter.html#multiple-pipes",
    "title": "Episode 5: Pipes and Filters",
    "section": "Multiple Pipes",
    "text": "Multiple Pipes\nChain as many as you want:\n$ cat *.pdb | wc -l\nCount total lines in all files.\n$ cat species.txt | head -n 20 | tail -n 5\nGet lines 16-20."
  },
  {
    "objectID": "slides/05-pipefilter.html#filtering-with-grep-preview",
    "href": "slides/05-pipefilter.html#filtering-with-grep-preview",
    "title": "Episode 5: Pipes and Filters",
    "section": "Filtering with grep (Preview)",
    "text": "Filtering with grep (Preview)\nFind lines matching a pattern:\n$ grep ATOM example.pdb\nDisplays all lines containing “ATOM”.\nIn a pipeline:\n$ cat *.pdb | grep ATOM | wc -l\nCount all ATOM entries in all files!"
  },
  {
    "objectID": "slides/05-pipefilter.html#redirecting-output",
    "href": "slides/05-pipefilter.html#redirecting-output",
    "title": "Episode 5: Pipes and Filters",
    "section": "Redirecting Output: >",
    "text": "Redirecting Output: &gt;\nSave output to a file (overwrites):\n$ wc -l *.pdb &gt; line-counts.txt\n$ cat line-counts.txt\n  20  cubane.pdb\n  ...\n 107  total\n⚠️ Warning: &gt; overwrites existing files!"
  },
  {
    "objectID": "slides/05-pipefilter.html#appending-output",
    "href": "slides/05-pipefilter.html#appending-output",
    "title": "Episode 5: Pipes and Filters",
    "section": "Appending Output: >>",
    "text": "Appending Output: &gt;&gt;\nAdd to a file (doesn’t overwrite):\n$ echo \"New entry\" &gt;&gt; log.txt\nAdds text to the end of the file."
  },
  {
    "objectID": "slides/05-pipefilter.html#practical-example",
    "href": "slides/05-pipefilter.html#practical-example",
    "title": "Episode 5: Pipes and Filters",
    "section": "Practical Example",
    "text": "Practical Example\nCount lines in all files and save:\n$ wc -l *.pdb &gt; line-counts.txt\nSort them:\n$ sort -n line-counts.txt\n   9 methane.pdb\n  12 ethane.pdb\n  15 propane.pdb\n  20 cubane.pdb\n  21 pentane.pdb\n  30 octane.pdb\n 107 total"
  },
  {
    "objectID": "slides/05-pipefilter.html#real-world-pipeline",
    "href": "slides/05-pipefilter.html#real-world-pipeline",
    "title": "Episode 5: Pipes and Filters",
    "section": "Real-World Pipeline",
    "text": "Real-World Pipeline\nProblem: Find all ATOM lines, count them, save to file\nSolution:\n$ cat *.pdb | grep ATOM | wc -l &gt; atom-count.txt\nBreaking it down: 1. cat *.pdb = show all files 2. grep ATOM = filter for ATOM lines only 3. wc -l = count the lines 4. &gt; atom-count.txt = save result"
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---question-1",
    "href": "slides/05-pipefilter.html#try-it-yourself---question-1",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Question 1",
    "text": "Try It Yourself - Question 1\nYou have a file called data.txt with 100 lines\nWrite a command to: 1. Show the middle 10 lines (lines 46-55)"
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---solution-1",
    "href": "slides/05-pipefilter.html#try-it-yourself---solution-1",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Solution 1",
    "text": "Try It Yourself - Solution 1\nUsing pipes:\n$ head -n 55 data.txt | tail -n 10\nBreaking it down: - head -n 55 = first 55 lines - tail -n 10 = last 10 of those = lines 46-55"
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---question-2",
    "href": "slides/05-pipefilter.html#try-it-yourself---question-2",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Question 2",
    "text": "Try It Yourself - Question 2\nSort molecular files by size (largest first)\nYou have: cubane.pdb, ethane.pdb, etc.\nHint: You already know wc -l and sort -n"
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---solution-2",
    "href": "slides/05-pipefilter.html#try-it-yourself---solution-2",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Solution 2",
    "text": "Try It Yourself - Solution 2\nUsing pipes and redirection:\n$ wc -l *.pdb | sort -rn &gt; sorted-sizes.txt\n$ cat sorted-sizes.txt\n 107 total\n  30 octane.pdb\n  21 pentane.pdb\n  20 cubane.pdb\n  15 propane.pdb\n  12 ethane.pdb\n   9 methane.pdb\nsort -rn sorts in reverse numeric order."
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---question-3",
    "href": "slides/05-pipefilter.html#try-it-yourself---question-3",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Question 3",
    "text": "Try It Yourself - Question 3\nYou want to save the 3 longest files to a list\nUsing the output from above, extract just the filenames (no “total” line, no line counts)."
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---solution-3",
    "href": "slides/05-pipefilter.html#try-it-yourself---solution-3",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Solution 3",
    "text": "Try It Yourself - Solution 3\nUsing pipes and redirection:\n$ wc -l *.pdb | sort -rn | head -n 4 | tail -n 3\nOr more precisely with grep to exclude “total”:\n$ wc -l *.pdb | grep -v total | sort -rn | head -n 3"
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---question-4",
    "href": "slides/05-pipefilter.html#try-it-yourself---question-4",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Question 4",
    "text": "Try It Yourself - Question 4\nCombine and count\nWrite a command that: 1. Shows all .pdb files 2. Filters for lines starting with “ATOM” 3. Counts them"
  },
  {
    "objectID": "slides/05-pipefilter.html#try-it-yourself---solution-4",
    "href": "slides/05-pipefilter.html#try-it-yourself---solution-4",
    "title": "Episode 5: Pipes and Filters",
    "section": "Try It Yourself - Solution 4",
    "text": "Try It Yourself - Solution 4\nUsing pipes:\n$ cat *.pdb | grep ^ATOM | wc -l\nBreaking it down: - cat *.pdb = display all files - grep ^ATOM = filter for lines starting with ATOM - wc -l = count the lines\nThe result is the total number of atoms!"
  },
  {
    "objectID": "slides/05-pipefilter.html#filter-philosophy",
    "href": "slides/05-pipefilter.html#filter-philosophy",
    "title": "Episode 5: Pipes and Filters",
    "section": "Filter Philosophy",
    "text": "Filter Philosophy\nUnix philosophy: Do one thing well\nEach command: - Does one job well - Takes input and produces output - Can be combined with others\nThink of them as LEGO blocks you snap together!"
  },
  {
    "objectID": "slides/05-pipefilter.html#key-points",
    "href": "slides/05-pipefilter.html#key-points",
    "title": "Episode 5: Pipes and Filters",
    "section": "Key Points",
    "text": "Key Points\n\nwc counts lines, words, characters\n\n\nhead and tail show beginning and end\n\n\nsort arranges data in order\n\n\nPipe | connects commands\n\n\n&gt; saves output (overwrites)\n\n\n&gt;&gt; appends to a file\n\n\nCombine simple commands into powerful pipelines"
  },
  {
    "objectID": "slides/04-permissions.html",
    "href": "slides/04-permissions.html",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Questions\n\n\n\n\nHow do file and directory permissions work?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nWhat are file and directory permissions?\nHow to view permissions?\nHow to change permissions?\nWhat are permission differences on Windows?\n\n\n\n\n\nUnix controls who can read, modify, and run files using permissions.\nLet’s start with Nelle:\n\nUnique user name: nnemo\nUser ID: 1404\n\nUsers can belong to multiple groups, each with a name and numeric group ID.\n\n\n\n\n\n\nWhy Integer IDs?\n\n\n\nIn early Unix, integers were faster and smaller to store and compare than strings.\nSystems often keep numeric IDs internally and map them to human-friendly names when displaying information.\n\n\n\n\n\nEvery file and directory on a Unix computer:\n\nBelongs to one owner\nBelongs to one group\n\nThe operating system stores the numeric IDs of the user and group that own it.\n\n\n\nFor each file, every user falls into one of three categories:\n\nOwner of the file\nSomeone in the file’s group\nEveryone else\n\n\n\n\nFor each category, the computer tracks whether people can:\n\nRead the file\nWrite to the file\nExecute the file (run it if it’s a program)\n\n\n\n\n\n\n\n\n\nuser\n\n\ngroup\n\n\nall\n\n\n\n\nread\n\n\nyes\n\n\nyes\n\n\nno\n\n\n\n\nwrite\n\n\nyes\n\n\nno\n\n\nno\n\n\n\n\nexecute\n\n\nno\n\n\nno\n\n\nno\n\n\n\nThis means:\n\nOwner can read and write, but not run it\nGroup can read, but not modify or run it\nEveryone else can do nothing with it\n\n\n\n\ncd into the labs directory and run ls -F:\ncd labs\nls -F\nsafety.txt    setup*     waiver.txt\nThe * at the end of setup tells us it’s executable - probably something the computer can run.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe fact that something is marked as executable doesn’t actually mean it contains a runnable program.\nMarking an HTML file executable won’t make it run as a program; the OS may instead open it in the associated application.\n\n\n\n\n\nRun ls -l for a long-form listing:\nls -l\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n-rwxr-xr-x 1 nnemo bio 31988  2010-07-23 20:04 setup\n-rw-rw-r-- 1 nnemo bio  2312  2010-07-11 08:23 waiver.txt\nThe -l flag gives us detailed information.\n\n\n\nLet’s examine the columns from right to left:\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n\nRight side: Filename\nNext left: Last modified time and date\nNext: File size in bytes\nNext: Owner (nnemo) and group (bio)\nSecond column: Number of links (skip for now)\nFirst column: Permissions (most important!)\n\n\n\n\nLet’s examine: -rwxr-xr-x\nFirst character: Type of thing - - = regular file - d = directory - Other characters for esoteric things\nNext 9 characters in groups of 3: - Owner permissions: rwx (read, write, execute) - Group permissions: r-x (read, execute, no write) - Others permissions: r-x (read, execute, no write)\n\n\n\n-rwxr-xr-x\n\n- = regular file\nrwx = owner can read, write, and execute\nr-x = group can read and execute (dash means permission is off)\nr-x = everyone else can read and execute\n\nSo everyone on the system can look at the file’s contents and run it.\n\n\n\nHere’s a file with problematic permissions:\nls -l final.grd\n-rwxrwxrwx 1 nnemo bio  4215  2010-08-29 22:30 final.grd\nWhoops! Everyone can read it—and worse, modify it!\n(They could also try to run it as a program, which wouldn’t work.)\n\n\n\nChange owner’s permissions to rw-:\nchmod u=rw final.grd\n\nu = changing privileges of the user (file’s owner)\nrw = new set of permissions\n\nVerify it worked:\nls -l final.grd\n-rw-rwxrwx 1 nnemo bio  4215  2010-08-30 08:19 final.grd\n\n\n\nGive the group read-only permission:\nchmod g=r final.grd\nls -l final.grd\n-rw-r--rw- 1 nnemo bio  4215  2010-08-30 08:19 final.grd\nGroup now has r-- (read only).\n\n\n\nGive “all” (everyone else) no permissions:\nchmod a= final.grd\nls -l final.grd\n-rw-r----- 1 nnemo bio  4215  2010-08-30 08:20 final.grd\n\na = changing permissions for “all”\nNothing after = means “all” has empty permissions\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSymbolic modes like u=rw are clear, but you’ll often see octal numbers:\nchmod 755 script.sh   # owner rwx (7), group r-x (5), others r-x (5)\nchmod 644 notes.txt   # owner rw- (6), group r-- (4), others r-- (4)\nEach digit is a sum: read=4, write=2, execute=1.\n\n\n\n\n\n\n\n\n\n\n\nOctal chmod\n\n\n\nSet the permissions for script.sh so that the owner can read, write, and execute; the group can read and execute; and others have no permissions. Use octal mode.\n\nWhich octal number represents these permissions?\nWhich command will apply it to script.sh?\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nOwner rwx → 7, group r-x → 5, others — → 0, so the octal is 750.\n\nchmod 750 script.sh\nVariants you may see:\n\nchmod 750 ./script.sh (explicit path)\nchmod 0750 script.sh (leading 0 sometimes used, effect is the same)\n\n\n\n\n\n\n\nRun ls -a -l to include normally hidden entries:\nls -a -l\ndrwxr-xr-x 1 nnemo bio     0  2010-08-14 09:55 .\ndrwxr-xr-x 1 nnemo bio  8192  2010-08-27 23:11 ..\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n-rwxr-xr-x 1 nnemo bio 31988  2010-07-23 20:04 setup\n-rw-rw-r-- 1 nnemo bio  2312  2010-07-11 08:23 waiver.txt\nNotice . and .. start with d (directory).\n\n\n\nThe permissions for . and .. show ‘x’ (execute) is on.\nWhat does that mean? A directory isn’t a program—how can we “run” it?\nFor directories, ‘x’ means something different: - Gives the right to traverse the directory - But not to look at its contents\nThe distinction is subtle…\n\n\n\nNelle’s home directory has three subdirectories:\n\n\n\n\n\nEach has a notes subdirectory with various files.\n\n\n\nIf permissions on venus are r-x: - User can see contents of both venus and venus/notes\nIf permissions on mars are r--: - User can read contents of both mars and mars/notes\nIf permissions on pluto are --x: - Cannot see what’s in pluto: ls pluto denied - But can look in pluto/notes if she knows it exists! - Allowed to go through pluto, but not look at what’s there\n\n\n\nThis trick gives people a way to make some of their directories visible to the world without opening up everything else.\nUseful for: - Sharing specific subdirectories - Keeping parent directory contents private - Allowing access to known paths only\n\n\n\nThings work differently on Windows.\nWindows uses Access Control Lists (ACLs): - A list of pairs: “who” + “what” - Example: Give Mummy permission to append without reading/deleting - Example: Give Frankenstein permission to delete without seeing contents\nMore flexible than Unix, but more complex to administer.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nUnix: owner/group/others with rwx triplets\nWindows: ACLs grant fine-grained rights per user or group\nSame ideas, different mechanisms.\n\n\nSome modern Unix variants support ACLs, but hardly anyone uses them.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIf ls -l myfile.php returns the following details:\n-rwxr-xr-- 1 caro zoo  2312  2014-10-25 18:30 myfile.php\nWhich of the following statements is true?\n\ncaro (the owner) can read, write, and execute myfile.php\ncaro (the owner) cannot write to myfile.php\nmembers of caro (a group) can read, write, and execute myfile.php\nmembers of zoo (a group) cannot execute myfile.php\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct.\nThe mode -rwxr-xr-- gives: - Owner: rwx (read, write, execute) - Group: r-x (read, execute, no write) - Others: r-- (read only)\nTherefore the owner can read, write, and execute; group members can read and execute (not write); others can only read.\n\n\n\n\n\n\n\n\nCorrect permissions are critical for the security of a system.\nFile permissions describe who and what can read, write, modify, and access a file.\nUse ls -l to view the permissions for a specific file.\nUse chmod to change permissions on a file or directory.\n\n\n\nNext: Episode 5 - Pipes and Filters →"
  },
  {
    "objectID": "slides/04-permissions.html#file-permissions-in-unix",
    "href": "slides/04-permissions.html#file-permissions-in-unix",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Unix controls who can read, modify, and run files using permissions.\nLet’s start with Nelle:\n\nUnique user name: nnemo\nUser ID: 1404\n\nUsers can belong to multiple groups, each with a name and numeric group ID.\n\n\n\n\n\n\nWhy Integer IDs?\n\n\n\nIn early Unix, integers were faster and smaller to store and compare than strings.\nSystems often keep numeric IDs internally and map them to human-friendly names when displaying information."
  },
  {
    "objectID": "slides/04-permissions.html#file-ownership",
    "href": "slides/04-permissions.html#file-ownership",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Every file and directory on a Unix computer:\n\nBelongs to one owner\nBelongs to one group\n\nThe operating system stores the numeric IDs of the user and group that own it."
  },
  {
    "objectID": "slides/04-permissions.html#three-user-categories",
    "href": "slides/04-permissions.html#three-user-categories",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "For each file, every user falls into one of three categories:\n\nOwner of the file\nSomeone in the file’s group\nEveryone else"
  },
  {
    "objectID": "slides/04-permissions.html#three-permission-types",
    "href": "slides/04-permissions.html#three-permission-types",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "For each category, the computer tracks whether people can:\n\nRead the file\nWrite to the file\nExecute the file (run it if it’s a program)"
  },
  {
    "objectID": "slides/04-permissions.html#example-permission-table",
    "href": "slides/04-permissions.html#example-permission-table",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "user\n\n\ngroup\n\n\nall\n\n\n\n\nread\n\n\nyes\n\n\nyes\n\n\nno\n\n\n\n\nwrite\n\n\nyes\n\n\nno\n\n\nno\n\n\n\n\nexecute\n\n\nno\n\n\nno\n\n\nno\n\n\n\nThis means:\n\nOwner can read and write, but not run it\nGroup can read, but not modify or run it\nEveryone else can do nothing with it"
  },
  {
    "objectID": "slides/04-permissions.html#permissions-in-action",
    "href": "slides/04-permissions.html#permissions-in-action",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "cd into the labs directory and run ls -F:\ncd labs\nls -F\nsafety.txt    setup*     waiver.txt\nThe * at the end of setup tells us it’s executable - probably something the computer can run."
  },
  {
    "objectID": "slides/04-permissions.html#necessary-but-not-sufficient",
    "href": "slides/04-permissions.html#necessary-but-not-sufficient",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Note\n\n\n\nThe fact that something is marked as executable doesn’t actually mean it contains a runnable program.\nMarking an HTML file executable won’t make it run as a program; the OS may instead open it in the associated application."
  },
  {
    "objectID": "slides/04-permissions.html#permission-strings",
    "href": "slides/04-permissions.html#permission-strings",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Run ls -l for a long-form listing:\nls -l\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n-rwxr-xr-x 1 nnemo bio 31988  2010-07-23 20:04 setup\n-rw-rw-r-- 1 nnemo bio  2312  2010-07-11 08:23 waiver.txt\nThe -l flag gives us detailed information."
  },
  {
    "objectID": "slides/04-permissions.html#reading-ls--l-output",
    "href": "slides/04-permissions.html#reading-ls--l-output",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Let’s examine the columns from right to left:\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n\nRight side: Filename\nNext left: Last modified time and date\nNext: File size in bytes\nNext: Owner (nnemo) and group (bio)\nSecond column: Number of links (skip for now)\nFirst column: Permissions (most important!)"
  },
  {
    "objectID": "slides/04-permissions.html#understanding-permission-strings",
    "href": "slides/04-permissions.html#understanding-permission-strings",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Let’s examine: -rwxr-xr-x\nFirst character: Type of thing - - = regular file - d = directory - Other characters for esoteric things\nNext 9 characters in groups of 3: - Owner permissions: rwx (read, write, execute) - Group permissions: r-x (read, execute, no write) - Others permissions: r-x (read, execute, no write)"
  },
  {
    "objectID": "slides/04-permissions.html#permission-string-breakdown",
    "href": "slides/04-permissions.html#permission-string-breakdown",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "-rwxr-xr-x\n\n- = regular file\nrwx = owner can read, write, and execute\nr-x = group can read and execute (dash means permission is off)\nr-x = everyone else can read and execute\n\nSo everyone on the system can look at the file’s contents and run it."
  },
  {
    "objectID": "slides/04-permissions.html#changing-permissions-with-chmod",
    "href": "slides/04-permissions.html#changing-permissions-with-chmod",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Here’s a file with problematic permissions:\nls -l final.grd\n-rwxrwxrwx 1 nnemo bio  4215  2010-08-29 22:30 final.grd\nWhoops! Everyone can read it—and worse, modify it!\n(They could also try to run it as a program, which wouldn’t work.)"
  },
  {
    "objectID": "slides/04-permissions.html#chmod---change-owner-permissions",
    "href": "slides/04-permissions.html#chmod---change-owner-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Change owner’s permissions to rw-:\nchmod u=rw final.grd\n\nu = changing privileges of the user (file’s owner)\nrw = new set of permissions\n\nVerify it worked:\nls -l final.grd\n-rw-rwxrwx 1 nnemo bio  4215  2010-08-30 08:19 final.grd"
  },
  {
    "objectID": "slides/04-permissions.html#chmod---change-group-permissions",
    "href": "slides/04-permissions.html#chmod---change-group-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Give the group read-only permission:\nchmod g=r final.grd\nls -l final.grd\n-rw-r--rw- 1 nnemo bio  4215  2010-08-30 08:19 final.grd\nGroup now has r-- (read only)."
  },
  {
    "objectID": "slides/04-permissions.html#chmod---change-all-permissions",
    "href": "slides/04-permissions.html#chmod---change-all-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Give “all” (everyone else) no permissions:\nchmod a= final.grd\nls -l final.grd\n-rw-r----- 1 nnemo bio  4215  2010-08-30 08:20 final.grd\n\na = changing permissions for “all”\nNothing after = means “all” has empty permissions"
  },
  {
    "objectID": "slides/04-permissions.html#octal-modes-shortcut",
    "href": "slides/04-permissions.html#octal-modes-shortcut",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Tip\n\n\n\nSymbolic modes like u=rw are clear, but you’ll often see octal numbers:\nchmod 755 script.sh   # owner rwx (7), group r-x (5), others r-x (5)\nchmod 644 notes.txt   # owner rw- (6), group r-- (4), others r-- (4)\nEach digit is a sum: read=4, write=2, execute=1."
  },
  {
    "objectID": "slides/04-permissions.html#challenge",
    "href": "slides/04-permissions.html#challenge",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Octal chmod\n\n\n\nSet the permissions for script.sh so that the owner can read, write, and execute; the group can read and execute; and others have no permissions. Use octal mode.\n\nWhich octal number represents these permissions?\nWhich command will apply it to script.sh?"
  },
  {
    "objectID": "slides/04-permissions.html#solution",
    "href": "slides/04-permissions.html#solution",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Solution\n\n\n\n\n\n\nOwner rwx → 7, group r-x → 5, others — → 0, so the octal is 750.\n\nchmod 750 script.sh\nVariants you may see:\n\nchmod 750 ./script.sh (explicit path)\nchmod 0750 script.sh (leading 0 sometimes used, effect is the same)"
  },
  {
    "objectID": "slides/04-permissions.html#hidden-directory-entries",
    "href": "slides/04-permissions.html#hidden-directory-entries",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Run ls -a -l to include normally hidden entries:\nls -a -l\ndrwxr-xr-x 1 nnemo bio     0  2010-08-14 09:55 .\ndrwxr-xr-x 1 nnemo bio  8192  2010-08-27 23:11 ..\n-rw-rw-r-- 1 nnemo bio  1158  2010-07-11 08:22 safety.txt\n-rwxr-xr-x 1 nnemo bio 31988  2010-07-23 20:04 setup\n-rw-rw-r-- 1 nnemo bio  2312  2010-07-11 08:23 waiver.txt\nNotice . and .. start with d (directory)."
  },
  {
    "objectID": "slides/04-permissions.html#what-does-x-mean-for-directories",
    "href": "slides/04-permissions.html#what-does-x-mean-for-directories",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "The permissions for . and .. show ‘x’ (execute) is on.\nWhat does that mean? A directory isn’t a program—how can we “run” it?\nFor directories, ‘x’ means something different: - Gives the right to traverse the directory - But not to look at its contents\nThe distinction is subtle…"
  },
  {
    "objectID": "slides/04-permissions.html#directory-permission-example",
    "href": "slides/04-permissions.html#directory-permission-example",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Nelle’s home directory has three subdirectories:\n\n\n\n\n\nEach has a notes subdirectory with various files."
  },
  {
    "objectID": "slides/04-permissions.html#different-permission-scenarios",
    "href": "slides/04-permissions.html#different-permission-scenarios",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "If permissions on venus are r-x: - User can see contents of both venus and venus/notes\nIf permissions on mars are r--: - User can read contents of both mars and mars/notes\nIf permissions on pluto are --x: - Cannot see what’s in pluto: ls pluto denied - But can look in pluto/notes if she knows it exists! - Allowed to go through pluto, but not look at what’s there"
  },
  {
    "objectID": "slides/04-permissions.html#making-directories-selectively-visible",
    "href": "slides/04-permissions.html#making-directories-selectively-visible",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "This trick gives people a way to make some of their directories visible to the world without opening up everything else.\nUseful for: - Sharing specific subdirectories - Keeping parent directory contents private - Allowing access to known paths only"
  },
  {
    "objectID": "slides/04-permissions.html#what-about-windows",
    "href": "slides/04-permissions.html#what-about-windows",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Things work differently on Windows.\nWindows uses Access Control Lists (ACLs): - A list of pairs: “who” + “what” - Example: Give Mummy permission to append without reading/deleting - Example: Give Frankenstein permission to delete without seeing contents\nMore flexible than Unix, but more complex to administer."
  },
  {
    "objectID": "slides/04-permissions.html#unix-vs-windows-permissions",
    "href": "slides/04-permissions.html#unix-vs-windows-permissions",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Note\n\n\n\nUnix: owner/group/others with rwx triplets\nWindows: ACLs grant fine-grained rights per user or group\nSame ideas, different mechanisms.\n\n\nSome modern Unix variants support ACLs, but hardly anyone uses them."
  },
  {
    "objectID": "slides/04-permissions.html#challenge-1",
    "href": "slides/04-permissions.html#challenge-1",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Challenge\n\n\n\nIf ls -l myfile.php returns the following details:\n-rwxr-xr-- 1 caro zoo  2312  2014-10-25 18:30 myfile.php\nWhich of the following statements is true?\n\ncaro (the owner) can read, write, and execute myfile.php\ncaro (the owner) cannot write to myfile.php\nmembers of caro (a group) can read, write, and execute myfile.php\nmembers of zoo (a group) cannot execute myfile.php"
  },
  {
    "objectID": "slides/04-permissions.html#solution-2",
    "href": "slides/04-permissions.html#solution-2",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Solution\n\n\n\n\n\nOption 1 is correct.\nThe mode -rwxr-xr-- gives: - Owner: rwx (read, write, execute) - Group: r-x (read, execute, no write) - Others: r-- (read only)\nTherefore the owner can read, write, and execute; group members can read and execute (not write); others can only read."
  },
  {
    "objectID": "slides/04-permissions.html#key-points",
    "href": "slides/04-permissions.html#key-points",
    "title": "Episode 4: File Permissions",
    "section": "",
    "text": "Correct permissions are critical for the security of a system.\nFile permissions describe who and what can read, write, modify, and access a file.\nUse ls -l to view the permissions for a specific file.\nUse chmod to change permissions on a file or directory.\n\n\n\nNext: Episode 5 - Pipes and Filters →"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Unix Shell",
    "section": "",
    "text": "This workshop introduces the Unix shell (Bash) as a practical tool for working with files, automating repetitive tasks, and building reproducible workflows. You will learn how the shell relates to your operating system and applications, and how to efficiently navigate directories, inspect and manipulate files, chain commands with pipes and filters, iterate with loops, and write simple shell scripts. By the end, you’ll be comfortable using core command-line patterns to explore data, transform text, and compose small, simple pipelines."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "The Unix Shell",
    "section": "",
    "text": "This workshop introduces the Unix shell (Bash) as a practical tool for working with files, automating repetitive tasks, and building reproducible workflows. You will learn how the shell relates to your operating system and applications, and how to efficiently navigate directories, inspect and manipulate files, chain commands with pipes and filters, iterate with loops, and write simple shell scripts. By the end, you’ll be comfortable using core command-line patterns to explore data, transform text, and compose small, simple pipelines."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "The Unix Shell",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this workshop, you will know how to:\n\nUnderstand what the shell is and when to use it.\nMove around folders and find your way to files.\nMake, copy, rename, and delete files and folders.\nJoin simple commands together to get the result you want.\nRepeat actions on many files without retyping.\nSave steps in small scripts so you can reuse them.\nSearch for files and for text inside files quickly."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "The Unix Shell",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis lesson guides you through the basics of file systems and the shell. If you have stored files on a computer at all and recognize the word “file” and either “directory” or “folder” (two common words for the same thing), you’re ready for this lesson.\nIf you’re already comfortable manipulating files and directories, searching for files with grep and find, and writing simple loops and scripts, you probably want to skip this workshop.\n\nDownload files\nYou need to download some files to follow this lesson.\n\nDownload shell-lesson-data.zip and move the file to your Desktop.\nUnzip/extract the file. You should end up with a new folder called shell-lesson-data on your Desktop.\n\n\n\nInstall software\nIf you do not already have the shell software installed, you will need to download and install it.\n\nFor macOSFor LinuxFor Windows\n\n\nFor a Mac computer running macOS Mojave or earlier releases, the default Unix Shell is Bash. For a Mac computer running macOS Catalina or later releases, the default Unix Shell is Zsh. Your default shell is available via the Terminal program within your Utilities folder.\n\nTo open Terminal, try one or both of the following:\n\nIn Finder, select the Go menu, then select Utilities. Locate Terminal in the Utilities folder and open it.\nUse the Mac ‘Spotlight’ computer search function. Search for: Terminal and press Return.\n\nTo check if your machine is set up to use something other than Bash, type echo $SHELL in your terminal window.\nIf your machine is set up to use something other than Bash, you can run it by opening a terminal and typing bash.\n\n\n\n\nThe default Unix Shell for Linux operating systems is usually Bash. On most versions of Linux, it is accessible by running the Gnome Terminal or KDE Konsole or xterm, which can be found via the applications menu or the search bar.\nIf your machine is set up to use something other than Bash, you can run it by opening a terminal and typing bash.\n\n\n\nComputers with Windows operating systems do not automatically have a Unix Shell program installed. In this lesson, we encourage you to use an emulator included in Git for Windows which gives you access to both Bash shell commands and Git or Visual Studio Code which gives you access to Bash shell commands.\n\nOption 1: Git for Windows\n\nDownload and install Git for Windows from gitforwindows.org.\nDuring installation, ensure that the option to use Git from the Windows Command Prompt is selected.\nAfter installation, open Git Bash from the Start menu.\n\n\n\nOption 2: Visual Studio Code\n\nDownload and install Visual Studio Code from code.visualstudio.com.\nInstall the “Remote - WSL” extension from the Extensions Marketplace.\nOpen a new terminal in VS Code, and select the Bash shell.\n\nNote for Peter Mac Windows Users:  If you need to install new software on Peter Mac Windows computers, you will need to Create a Snow Ticket for installation."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "The Unix Shell",
    "section": "Course Outline",
    "text": "Course Outline\n\n\n\n\nTime\n\n\nLesson\n\n\nQuestions\n\n\n\n\n5\n\n\nIntroducing the Shell\n\n\nWhat is a command shell and why would I use one?\n\n\n\n\n30\n\n\nNavigating Files and Directories\n\n\nHow can I move around on my computer?How can I see what files and directories I have?How can I specify the location of a file or directory on my computer?\n\n\n\n\n30\n\n\nWorking With Files and Directories\n\n\nHow can I create, copy, and delete files and directories?How can I edit files?\n\n\n\n\n10\n\n\nFile Permissions\n\n\nHow do file and directory permissions work?\n\n\n\n\n25\n\n\nPipes and Filters\n\n\nHow can I combine existing commands to produce a desired output?How can I show only part of the output?\n\n\n\n\n40\n\n\nLoops\n\n\nHow can I perform the same actions on many different files?\n\n\n\n\n30\n\n\nShell Scripts\n\n\nHow can I save and re-use commands?\n\n\n\n\n25\n\n\nFinding Things\n\n\nHow can I find files?How can I find things in files?\n\n\n\n\n20\n\n\nAWK for Text Processing\n\n\nHow do I print specific columns from a text table?How can I use patterns to select only certain lines in a file?How do I count lines or matched lines in a file?"
  },
  {
    "objectID": "index.html#credits-and-acknowledgement",
    "href": "index.html#credits-and-acknowledgement",
    "title": "The Unix Shell",
    "section": "Credits and Acknowledgement",
    "text": "Credits and Acknowledgement\nThese content were adapted from the following course materials:\n\nThe Carpentries Incubator - The Unix Shell"
  },
  {
    "objectID": "episodes/02-filedir.html",
    "href": "episodes/02-filedir.html",
    "title": "Navigating Files and Directories",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 10\nQuestions:\n\nHow can I move around on my computer?\nHow can I see what files and directories I have?\nHow can I specify the location of a file or directory on my computer?\n\nObjectives:\n\nExplain the similarities and differences between a file and a directory.\nTranslate an absolute path into a relative path and vice versa.\nConstruct absolute and relative paths that identify specific files and directories.\nUse options and arguments to change the behaviour of a shell command.\nDemonstrate the use of tab completion and explain its advantages.\nThe part of the operating system responsible for managing files and directories is called the file system. It organizes our data into files, which hold information, and directories (also called ‘folders’), which hold files or other directories.\nSeveral commands are frequently used to create, inspect, rename, and delete files and directories. To start exploring them, we’ll go to our open shell window.\nFirst, let’s find out where we are by running a command called pwd (which stands for ‘print working directory’). Directories are like places — at any time while we are using the shell, we are in exactly one place called our current working directory. Commands mostly read and write files in the current working directory, i.e. ‘here’, so knowing where you are before running a command is important. pwd shows you where you are:\nHere, the computer’s response is /Users/nelle, which is Nelle’s home directory:\nTo understand what a ‘home directory’ is, let’s have a look at how the file system as a whole is organized. For the sake of this example, we’ll be illustrating the filesystem on our scientist Nelle’s computer. After this illustration, you’ll be learning commands to explore your own filesystem, which will be constructed in a similar way, but not be exactly identical.\nOn Nelle’s computer, the filesystem looks like this:\nThe filesystem looks like an upside down tree. The topmost directory is the root directory that holds everything else. We refer to it using a slash character, /, on its own; this character is the leading slash in /Users/nelle.\nInside that directory are several other directories: bin (which is where some built-in programs are stored), data (for miscellaneous data files), Users (where users’ personal directories are located), tmp (for temporary files that don’t need to be stored long-term), and so on.\nWe know that our current working directory /Users/nelle is stored inside /Users because /Users is the first part of its name. Similarly, we know that /Users is stored inside the root directory / because its name begins with /.\nUnderneath /Users, we find one directory for each user with an account on Nelle’s machine, her colleagues imhotep and larry.\nThe user imhotep’s files are stored in /Users/imhotep, user larry’s in /Users/larry, and Nelle’s in /Users/nelle. Nelle is the user in our examples here; therefore, we get /Users/nelle as our home directory. Typically, when you open a new command prompt, you will be in your home directory to start.\nNow let’s learn the command that will let us see the contents of our own filesystem. We can see what’s in our home directory by running ls:\n(Again, your results may be slightly different depending on your operating system and how you have customized your filesystem.)\nls prints the names of the files and directories in the current directory. We can make its output more comprehensible by using the -F option which tells ls to classify the output by adding a marker to file and directory names to indicate what they are:\nDepending on your shell’s default settings, the shell might also use colors to indicate whether each entry is a file or directory.\nHere, we can see that the home directory contains only sub-directories. Any names in the output that don’t have a classification symbol are files in the current working directory."
  },
  {
    "objectID": "episodes/02-filedir.html#general-syntax-of-a-shell-command",
    "href": "episodes/02-filedir.html#general-syntax-of-a-shell-command",
    "title": "Navigating Files and Directories",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments, but it is perhaps useful to formalise some terminology.\nConsider the command below as a general example of a command, which we will dissect into its component parts:\nls -F /\n\n\n\n\n\nls is the command, with an option -F and an argument /. We’ve already encountered options which either start with a single dash (-), known as short options, or two dashes (--), known as long options. Options change the behavior of a command and Arguments tell the command what to operate on (e.g. files and directories). Sometimes options and arguments are referred to as parameters. A command can be called with more than one option and more than one argument, but a command doesn’t always require an argument or an option.\nYou might sometimes see options being referred to as switches or flags, especially for options that take no argument. In this lesson we will stick with using the term option.\nEach part is separated by spaces. If you omit the space between ls and -F the shell will look for a command called ls-F, which doesn’t exist. Also, capitalization can be important. For example, ls -s will display the size of files and directories alongside the names, while ls -S will sort the files and directories by size, as shown below:\ncd ~/Desktop/shell-lesson-data\nls -s exercise-data\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 alkanes   4 writing\nNote that the sizes returned by ls -s are in blocks. As these are defined differently for different operating systems, you may not obtain the same figures as in the example.\nls -S exercise-data\nanimal-counts  creatures  alkanes  writing  numbers.txt\nPutting all that together, our command ls -F / above gives us a listing of files and directories in the root directory /. An example of the output you might get from the above command is given below:\nls -F /\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\n\nNelle’s Pipeline: Organizing Files\nKnowing this much about files and directories, Nelle is ready to organize the files that the protein assay machine will create.\nShe creates a directory called north-pacific-gyre (to remind herself where the data came from), which will contain the data files from the assay machine and her data processing scripts.\nEach of her physical samples is labelled according to her lab’s convention with a unique ten-character ID, such as ‘NENE01729A’. This ID is what she used in her collection log to record the location, time, depth, and other characteristics of the sample, so she decides to use it within the filename of each data file. Since the output of the assay machine is plain text, she will call her files NENE01729A.txt, NENE01812A.txt, and so on. All 1520 files will go into the same directory.\nNow in her current directory shell-lesson-data, Nelle can see what files she has using the command:\nls north-pacific-gyre/\nThis command is a lot to type, but she can let the shell do most of the work through what is called tab completion. If she types:\nls nor\nand then presses Tab (the tab key on her keyboard), the shell automatically completes the directory name for her:\nls north-pacific-gyre/\nPressing Tab again does nothing, since there are multiple possibilities; pressing Tab twice brings up a list of all the files.\nIf Nelle then presses G and then presses Tab again, the shell will append ‘goo’ since all files that start with ‘g’ share the first three characters ‘goo’.\nls north-pacific-gyre/goo\nTo see all of those files, she can press Tab twice more.\nls north-pacific-gyre/goo\ngoodiff.sh   goostats.sh\nThis is called tab completion, and we will see it in many other tools as we go on.\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which then form a directory tree.\npwd prints the user’s current working directory.\nls [path] prints a listing of a specific file or directory; ls on its own lists the current working directory.\ncd [path] changes the current working directory.\nMost commands take options that begin with a single -.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\nAn absolute path specifies a location from the root of the file system.\nA relative path specifies a location starting from the current location.\n. on its own means ‘the current directory’; .. means ‘the directory above the current one’.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/03-create.html",
    "href": "episodes/03-create.html",
    "title": "Working With Files and Directories",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 20\nQuestions:\n\nHow can I create, copy, and delete files and directories?\nHow can I edit files?\n\nObjectives:\n\nDelete, copy and move specified files and/or directories.\nCreate files in that hierarchy using an editor or by copying and renaming existing files.\nCreate a directory hierarchy that matches a given diagram."
  },
  {
    "objectID": "episodes/03-create.html#creating-directories",
    "href": "episodes/03-create.html#creating-directories",
    "title": "Working With Files and Directories",
    "section": "Creating directories",
    "text": "Creating directories\nWe now know how to explore files and directories, but how do we create them in the first place?\nIn this episode we will learn about creating and moving files and directories, using the exercise-data/writing directory as an example.\n\nStep one: see where we are and what we already have\nWe should still be in the shell-lesson-data directory on the Desktop, which we can check using:\npwd\n/Users/nelle/Desktop/shell-lesson-data\nNext we’ll move to the exercise-data/writing directory and see what it contains:\ncd exercise-data/writing/\nls -F\nhaiku.txt  LittleWomen.txt\n\n\nCreate a directory\nLet’s create a new directory called thesis using the command mkdir thesis (which has no output):\nmkdir thesis\nAs you might guess from its name, mkdir means ‘make directory’. Since thesis is a relative path (i.e., does not have a leading slash, like /what/ever/thesis), the new directory is created in the current working directory:\nls -F\nhaiku.txt  LittleWomen.txt  thesis/\nSince we’ve just created the thesis directory, there’s nothing in it yet:\nls -F thesis\nNote that mkdir is not limited to creating single directories one at a time. The -p option allows mkdir to create a directory with nested subdirectories in a single operation:\nmkdir -p ../project/data ../project/results\nThe -R option to the ls command will list all nested subdirectories within a directory. Let’s use ls -FR to recursively list the new directory hierarchy we just created in the project directory:\nls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\nTwo ways of doing the same thing\n\n\n\nUsing the shell to create a directory is no different than using a file explorer. If you open the current directory using your operating system’s graphical file explorer, the thesis directory will appear there too. While the shell and the file explorer are two different ways of interacting with the files, the files and directories themselves are the same.\n\n\n\n\n\n\n\n\nGood names for files and directories\n\n\n\nComplicated names of files and directories can make your life painful when working on the command line. Here we provide a few useful tips for the names of your files and directories.\n\nDon’t use spaces.\n\nSpaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g. north-pacific-gyre/ rather than north pacific gyre/). To test this out, try typing mkdir north pacific gyre and see what directory (or directories!) are made when you check with ls -F.\n\nDon’t begin the name with - (dash).\n\nCommands treat names starting with - as options.\n\nStick with lowercase letters, numbers, . (period or ‘full stop’), - (dash) and _ (underscore).\n\nMany other characters have special meanings on the command line. We will learn about some of these during this lesson. There are special characters that can cause your command to not work as expected and can even result in data loss.\nIf you need to refer to names of files or directories that have spaces or other special characters, you should surround the name in single quotes ('').\nIt is often good practice to use all lowercase letters in names of files and directories; Windows and macOS file systems are typically case insensitive and therefore unable to distinguish between thesis and Thesis in the same directory.\n\n\n\n\nCreate a text file\nLet’s change our working directory to thesis using cd, then run a text editor called Nano to create a file called draft.txt:\ncd thesis\nnano draft.txt\n\n\n\n\n\n\nWhich Editor?\n\n\n\nWhen we say, ‘nano is a text editor’ we really do mean ‘text’. It can only work with plain character data, not tables, images, or any other human-friendly media. We use it in examples because it is one of the least complex text editors. However, because of this trait, it may not be powerful enough or flexible enough for the work you need to do after this workshop. On Unix systems (such as Linux and macOS), many programmers use Emacs or Vim (both of which require more time to learn), or a graphical editor such as Gedit or VScode. On Windows, you may wish to use Notepad++. Windows also has a built-in editor called notepad that can be run from the command line in the same way as nano for the purposes of this lesson.\nNo matter what editor you use, you will need to know where it searches for and saves files. If you start it from the shell, it will (probably) use your current working directory as its default location. If you use your computer’s start menu, it may want to save files in your Desktop or Documents directory instead. You can change this by navigating to another directory the first time you ‘Save As…’\n\n\nLet’s type in a few lines of text.\n\nOnce we’re happy with our text, we can press Ctrl+O (press the Ctrl or Control key and, while holding it down, press the O key) to write our data to disk. We will be asked to provide a name for the file that will contain our text. Press Return to accept the suggested default of draft.txt.\nOnce our file is saved, we can use Ctrl+X to quit the editor and return to the shell.\n\n\n\n\n\n\nControl, Ctrl, or ^ Key\n\n\n\nThe Control key is also called the ‘Ctrl’ key. There are various ways in which using the Control key may be described. For example, you may see an instruction to press the Control key and, while holding it down, press the X key, described as any of:\n\nControl-X\nControl+X\nCtrl-X\nCtrl+X\n^X\nC-x\n\nIn nano, along the bottom of the screen you’ll see ^G Get Help ^O WriteOut. This means that you can use Control-G to get help and Control-O to save your file.\n\n\nnano doesn’t leave any output on the screen after it exits, but ls now shows that we have created a file called draft.txt:\nls\ndraft.txt\n\n\n\n\n\n\nCreating Files a Different Way\n\n\n\nWe have seen how to create text files using the nano editor. Now, try the following command:\ntouch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you’ve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\nrm my_file.txt\n\n\n\n\n\n\n\n\n\nWhat’s In A Name?\n\n\n\nYou may have noticed that all of Nelle’s files are named ‘something dot something’, and in this part of the lesson, we always used the extension .txt. This is just a convention; we can call a file mythesis or almost anything else we want. However, most people use two-part names most of the time to help them (and their programs) tell different kinds of files apart. The second part of such a name is called the filename extension and indicates what type of data the file holds: .txt signals a plain text file, .pdf indicates a PDF document, .cfg is a configuration file full of parameters for some program or other, .png is a PNG image, and so on.\nThis is just a convention, albeit an important one. Files merely contain bytes; it’s up to us and our programs to interpret those bytes according to the rules for plain text files, PDF documents, configuration files, images, and so on.\nNaming a PNG image of a whale as whale.mp3 doesn’t somehow magically turn it into a recording of whale song, though it might cause the operating system to associate the file with a music player program. In this case, if someone double-clicked whale.mp3 in a file explorer program, the music player will automatically (and erroneously) attempt to open the whale.mp3 file."
  },
  {
    "objectID": "episodes/03-create.html#moving-files-and-directories",
    "href": "episodes/03-create.html#moving-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Moving files and directories",
    "text": "Moving files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory,\ncd ~/Desktop/shell-lesson-data/exercise-data/writing\nIn our thesis directory we have a file draft.txt which isn’t a particularly informative name, so let’s change the file’s name using mv, which is short for ‘move’:\nmv thesis/draft.txt thesis/quotes.txt\nThe first argument tells mv what we’re ‘moving’, while the second is where it’s to go. In this case, we’re moving thesis/draft.txt to thesis/quotes.txt, which has the same effect as renaming the file. Sure enough, ls shows us that thesis now contains one file called quotes.txt:\nls thesis\nquotes.txt\nOne must be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name, which could lead to data loss. By default, mv will not ask for confirmation before overwriting files. However, an additional option, mv -i (or mv --interactive), will cause mv to request such confirmation.\nNote that mv also works on directories.\nLet’s move quotes.txt into the current working directory. We use mv once again, but this time we’ll use just the name of a directory as the second argument to tell mv that we want to keep the filename but put the file somewhere new. (This is why the command is called ‘move’.) In this case, the directory name we use is the special directory name . that we mentioned earlier.\nmv thesis/quotes.txt .\nThe effect is to move the file from the directory it was in to the current working directory. ls now shows us that thesis is empty:\nls thesis\n$\nAlternatively, we can confirm the file quotes.txt is no longer present in the thesis directory by explicitly trying to list it:\nls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nls with a filename or directory as an argument only lists the requested file or directory. If the file given as the argument doesn’t exist, the shell returns an error as we saw above. We can use this to see that quotes.txt is now present in our current directory:\nls quotes.txt\nquotes.txt\n\n\n\n\n\n\nMoving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\nls -F\n analyzed/ raw/\nls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\ncd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e. the one she forgot to put them in)\nmv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e. one above the current directory) and that . refers to the current directory."
  },
  {
    "objectID": "episodes/03-create.html#copying-files-and-directories",
    "href": "episodes/03-create.html#copying-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Copying files and directories",
    "text": "Copying files and directories\nThe cp command works very much like mv, except it copies a file instead of moving it. We can check that it did the right thing using ls with two paths as arguments — like most Unix commands, ls can be given multiple paths at once:\ncp quotes.txt thesis/quotations.txt\nls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nWe can also copy a directory and all its contents by using the recursive option -r, e.g. to back up a directory:\ncp -r thesis thesis_backup\nWe can check the result by listing the contents of both the thesis and thesis_backup directory:\nls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\nIt is important to include the -r flag. If you want to copy a directory and you omit this option you will see a message that the directory has been omitted because -r not specified.\ncp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\n\n\n\n\n\n\nRenaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo. While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\nMoving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\npwd\n/Users/jamie/data\nls\nproteins.dat\nmkdir recombined\nmv proteins.dat recombined/\ncp recombined/proteins.dat ../proteins-saved.dat\nls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‘go up a level’, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie"
  },
  {
    "objectID": "episodes/03-create.html#removing-files-and-directories",
    "href": "episodes/03-create.html#removing-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Removing files and directories",
    "text": "Removing files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory, let’s tidy up this directory by removing the quotes.txt file we created. The Unix command we’ll use for this is rm (short for ‘remove’):\nrm quotes.txt\nWe can confirm the file has gone using ls:\nls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\nDeleting Is Forever\n\n\n\nThe Unix shell doesn’t have a trash bin that we can recover deleted files from (though most graphical interfaces to Unix do). Instead, when we delete files, they are unlinked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there’s no guarantee they’ll work in any particular situation, since the computer may recycle the file’s disk space right away.\n\n\n\n\n\n\n\n\nUsing rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\nIf we try to remove the thesis directory using rm thesis, we get an error message:\nrm thesis\nrm: cannot remove 'thesis': Is a directory\nThis happens because rm by default only works on files, not directories.\nrm can remove a directory and all its contents if we use the recursive option -r, and it will do so without any confirmation prompts:\nrm -r thesis\nGiven that there is no way to retrieve files deleted using the shell, rm -r should be used with great caution (you might consider adding the interactive option rm -r -i)."
  },
  {
    "objectID": "episodes/03-create.html#operations-with-multiple-files-and-directories",
    "href": "episodes/03-create.html#operations-with-multiple-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Operations with multiple files and directories",
    "text": "Operations with multiple files and directories\nOftentimes one needs to copy or move several files at once. This can be done by providing a list of individual filenames, or specifying a naming pattern using wildcards. Wildcards are special characters that can be used to represent unknown characters or sets of characters when navigating the Unix file system.\n\n\n\n\n\n\nCopy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let’s try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\nmkdir backup\ncp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\ncd creatures\nls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\ncp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory\n\n\n\n\nUsing wildcards for accessing multiple files at once\n\n\n\n\n\n\nWildcards\n\n\n\n* is a wildcard, which represents zero or more other characters. Let’s consider the shell-lesson-data/exercise-data/alkanes directory: *.pdb represents ethane.pdb, propane.pdb, and every file that ends with ‘.pdb’. On the other hand, p*.pdb only represents pentane.pdb and propane.pdb, because the ‘p’ at the front can only represent filenames that begin with the letter ‘p’.\n? is also a wildcard, but it represents exactly one character. So ?ethane.pdb could represent methane.pdb whereas *ethane.pdb represents both ethane.pdb and methane.pdb.\nWildcards can be used in combination with each other. For example, ???ane.pdb indicates three characters followed by ane.pdb, giving cubane.pdb  ethane.pdb  octane.pdb.\nWhen the shell sees a wildcard, it expands the wildcard to create a list of matching filenames before running the preceding command. As an exception, if a wildcard expression does not match any file, Bash will pass the expression as an argument to the command as it is. For example, typing ls *.pdf in the alkanes directory (which contains only files with names ending with .pdb) results in an error message that there is no file called *.pdf. However, generally commands like wc and ls see the lists of file names matching these expressions, but not the wildcards themselves. It is the shell, not the other programs, that expands the wildcards.\n\n\n\n\n\n\n\n\nList filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn’t match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   └── datasets\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    └── all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\ncp *dataset* backup/datasets\ncp ____calibration____ backup/calibration\ncp 2015-____-____ send_to_bob/all_november_files/\ncp ____ send_to_bob/all_datasets_created_on_a_23rd/\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   │   ├── 2015-10-23-calibration.txt\n│   │   ├── 2015-10-26-calibration.txt\n│   │   └── 2015-11-23-calibration.txt\n│   └── datasets\n│       ├── 2015-10-23-dataset1.txt\n│       ├── 2015-10-23-dataset2.txt\n│       ├── 2015-10-23-dataset_overview.txt\n│       ├── 2015-10-26-dataset1.txt\n│       ├── 2015-10-26-dataset2.txt\n│       ├── 2015-10-26-dataset_overview.txt\n│       ├── 2015-11-23-dataset1.txt\n│       ├── 2015-11-23-dataset2.txt\n│       └── 2015-11-23-dataset_overview.txt\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    │   ├── 2015-10-23-dataset1.txt\n    │   ├── 2015-10-23-dataset2.txt\n    │   ├── 2015-10-23-dataset_overview.txt\n    │   ├── 2015-11-23-dataset1.txt\n    │   ├── 2015-11-23-dataset2.txt\n    │   └── 2015-11-23-dataset_overview.txt\n    └── all_november_files\n        ├── 2015-11-23-calibration.txt\n        ├── 2015-11-23-dataset1.txt\n        ├── 2015-11-23-dataset2.txt\n        └── 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncp *calibration.txt backup/calibration\ncp 2015-11-* send_to_bob/all_november_files/\ncp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\nOrganizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren’t very well organized:\nls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\nls -F\nanalyzed/   raw/\nls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‘analyzed’ directory.\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nYou’re starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n└── data\n   ├── processed\n   └── raw\nWhich of the following set of commands would achieve this objective? What would the other commands do?\nmkdir 2016-05-20\nmkdir 2016-05-20/data\nmkdir 2016-05-20/data/processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\ncd data\nmkdir raw processed\nmkdir 2016-05-20/data/raw\nmkdir 2016-05-20/data/processed\nmkdir -p 2016-05-20/data/raw\nmkdir -p 2016-05-20/data/processed\nmkdir 2016-05-20\ncd 2016-05-20\nmkdir data\nmkdir raw processed\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won’t create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‘raw’ and ‘processed’ directories at the same level as the ‘data’ directory.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\ncp [old] [new] copies a file.\nmkdir [path] creates a new directory.\nmv [old] [new] moves (renames) a file or directory.\nrm [path] removes (deletes) a file.\n* matches zero or more characters in a filename, so *.txt matches all files ending in .txt.\n? matches any single character in a filename, so ?.txt matches a.txt but not any.txt.\nUse of the Control key may be described in many ways, including Ctrl-X, Control-X, and ^X.\nThe shell does not have a trash bin: once something is deleted, it’s really gone.\nMost files’ names are something.extension. The extension isn’t required, and doesn’t guarantee anything, but is normally used to indicate the type of data in the file.\nDepending on the type of work you do, you may need a more powerful text editor than Nano.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/05-pipefilter.html",
    "href": "episodes/05-pipefilter.html",
    "title": "Pipes and Filters",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 25\nExercises: 10\nQuestions:\n\nHow can I combine existing commands to produce a desired output?\nHow can I show only part of the output?\n\nObjectives:\n\nExplain the advantage of linking commands with pipes and filters.\nCombine sequences of commands to get new output\nRedirect a command’s output to a file.\nExplain what usually happens if a program or pipeline isn’t given any input to process.\nNow that we know a few basic commands, we can finally look at the shell’s most powerful feature: the ease with which it lets us combine existing programs in new ways. We’ll start with the directory shell-lesson-data/exercise-data/alkanes that contains six files describing some simple organic molecules. The .pdb extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.\nLet’s run an example command:\nwc is the ‘word count’ command: it counts the number of lines, words, and characters in files (returning the values in that order from left to right).\nIf we run the command wc *.pdb, the * in *.pdb matches zero or more characters, so the shell turns *.pdb into a list of all .pdb files in the current directory:\nNote that wc *.pdb also shows the total number of all lines in the last line of the output.\nIf we run wc -l instead of just wc, the output shows only the number of lines per file:\nThe -m and -w options can also be used with the wc command to show only the number of characters or the number of words, respectively."
  },
  {
    "objectID": "episodes/05-pipefilter.html#capturing-output-from-commands",
    "href": "episodes/05-pipefilter.html#capturing-output-from-commands",
    "title": "Pipes and Filters",
    "section": "Capturing output from commands",
    "text": "Capturing output from commands\nWhich of these files contains the fewest lines? It’s an easy question to answer when there are only six files, but what if there were 6000? Our first step toward a solution is to run the command:\nwc -l *.pdb &gt; lengths.txt\nThe greater than symbol, &gt;, tells the shell to redirect the command’s output to a file instead of printing it to the screen. This command prints no screen output, because everything that wc would have printed has gone into the file lengths.txt instead. If the file doesn’t exist prior to issuing the command, the shell will create the file. If the file exists already, it will be silently overwritten, which may lead to data loss. Thus, redirect commands require caution.\nls lengths.txt confirms that the file exists:\nls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt. The cat command gets its name from ‘concatenate’ i.e. join together, and it prints the contents of files one after another. There’s only one file in this case, so cat just shows us what it contains:\ncat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\n\n\n\n\n\n\nOutput Page by Page\n\n\n\nWe’ll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g. less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit."
  },
  {
    "objectID": "episodes/05-pipefilter.html#filtering-output",
    "href": "episodes/05-pipefilter.html#filtering-output",
    "title": "Pipes and Filters",
    "section": "Filtering output",
    "text": "Filtering output\nNext we’ll use the sort command to sort the contents of the lengths.txt file. But first we’ll do an exercise to learn a little about the sort command:\n\n\n\n\n\n\nWhat Does sort -n Do?\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -n option specifies a numerical rather than an alphanumerical sort.\n\n\n\nWe will also use the -n option to specify that the sort is numerical instead of alphanumerical. This does not change the file; instead, it sends the sorted result to the screen:\nsort -n lengths.txt\n  9  methane.pdb\n 12  ethane.pdb\n 15  propane.pdb\n 20  cubane.pdb\n 21  pentane.pdb\n 30  octane.pdb\n107  total\nWe can put the sorted list of lines in another temporary file called sorted-lengths.txt by putting &gt; sorted-lengths.txt after the command, just as we used &gt; lengths.txt to put the output of wc into lengths.txt. Once we’ve done that, we can run another command called head to get the first few lines in sorted-lengths.txt:\nsort -n lengths.txt &gt; sorted-lengths.txt\nhead -n 1 sorted-lengths.txt\n  9  methane.pdb\nUsing -n 1 with head tells it that we only want the first line of the file; -n 20 would get the first 20, and so on. Since sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines.\n\n\n\n\n\n\nRedirecting to the same file\n\n\n\nIt’s a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\nsort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt.\n\n\n\n\n\n\n\n\nWhat Does &gt;&gt; Mean?\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We’ll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\necho The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\necho hello &gt; testfile01.txt\nand:\necho hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn the first example with &gt;, the string ‘hello’ is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‘hello’ to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e. when we run it for the second time).\n\n\n\n\n\n\n\n\n\nAppending Data\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\nhead -n 3 animals.csv &gt; animals-subset.csv\ntail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nThe first three lines of animals.csv\nThe last two lines of animals.csv\nThe first three lines and the last two lines of animals.csv\nThe second and third lines of animals.csv\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv"
  },
  {
    "objectID": "episodes/05-pipefilter.html#passing-output-to-another-command",
    "href": "episodes/05-pipefilter.html#passing-output-to-another-command",
    "title": "Pipes and Filters",
    "section": "Passing output to another command",
    "text": "Passing output to another command\nIn our example of finding the file with the fewest lines, we are using two intermediate files lengths.txt and sorted-lengths.txt to store output. This is a confusing way to work because even once you understand what wc, sort, and head do, those intermediate files make it hard to follow what’s going on. We can make it easier to understand by running sort and head together:\nsort -n lengths.txt | head -n 1\n  9  methane.pdb\nThe vertical bar, |, between the two commands is called a pipe. It tells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis has removed the need for the sorted-lengths.txt file."
  },
  {
    "objectID": "episodes/05-pipefilter.html#combining-multiple-commands",
    "href": "episodes/05-pipefilter.html#combining-multiple-commands",
    "title": "Pipes and Filters",
    "section": "Combining multiple commands",
    "text": "Combining multiple commands\nNothing prevents us from chaining pipes consecutively. We can for example send the output of wc directly to sort, and then send the resulting output to head. This removes the need for any intermediate files.\nWe’ll start by using a pipe to send the output of wc to sort:\nwc -l *.pdb | sort -n\n   9 methane.pdb\n  12 ethane.pdb\n  15 propane.pdb\n  20 cubane.pdb\n  21 pentane.pdb\n  30 octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so that the full pipeline becomes:\nwc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‘the log of three times x’. In our case, the algorithm is ‘head of sort of line count of *.pdb’.\nThe redirection and pipes used in the last few commands are illustrated below:\n\n\n\n\n\n\n\nPiping Commands Together\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!"
  },
  {
    "objectID": "episodes/05-pipefilter.html#tools-designed-to-work-together",
    "href": "episodes/05-pipefilter.html#tools-designed-to-work-together",
    "title": "Pipes and Filters",
    "section": "Tools designed to work together",
    "text": "Tools designed to work together\nThis idea of linking programs together is why Unix has been so successful. Instead of creating enormous programs that try to do many different things, Unix programmers focus on creating lots of simple tools that each do one job well, and that work well with each other. This programming model is called ‘pipes and filters’. We’ve already seen pipes; a filter is a program like wc or sort that transforms a stream of input into a stream of output. Almost all of the standard Unix tools can work this way. Unless told to do otherwise, they read from standard input, do something with what they’ve read, and write to standard output.\nThe key is that any program that reads lines of text from standard input and writes lines of text to standard output can be combined with every other program that behaves this way as well. You can and should write your programs this way so that you and other people can put those programs into pipes to multiply their power.\n\n\n\n\n\n\nPipe Reading Comprehension\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\ncat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7\n\n\n\n\n\n\n\n\n\nPipe Construction\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\ncut -d , -f 2 animals.csv\nThe cut command is used to select or ‘cut out’ certain sections of each line in the file for further processing while leaving the original file unchanged. By default, cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter.\nIn the example above we use the -d option to specify the comma as our delimiter character instead of Tab. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncut -d , -f 2 animals.csv | sort | uniq\n\n\n\n\n\n\n\n\n\nWhich Pipe?\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory)."
  },
  {
    "objectID": "episodes/05-pipefilter.html#nelles-pipeline-checking-files",
    "href": "episodes/05-pipefilter.html#nelles-pipeline-checking-files",
    "title": "Pipes and Filters",
    "section": "Nelle’s Pipeline: Checking Files",
    "text": "Nelle’s Pipeline: Checking Files\nNelle has run her samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, Nelle types:\ncd north-pacific-gyre\nwc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\nNow she types this:\nwc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others. When she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning — someone was probably in using the machine on the weekend, and she forgot to reset it. Before re-running that sample, she checks to see if any files have too much data:\nwc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\nThose numbers look good — but what’s that ‘Z’ doing there in the third-to-last line? All of her samples should be marked ‘A’ or ‘B’; by convention, her lab uses ‘Z’ to indicate samples with missing information. To find others like it, she does this:\nls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt\nSure enough, when she checks the log on her laptop, there’s no depth recorded for either of those samples. Since it’s too late to get the information any other way, she must exclude those two files from her analysis. She could delete them using rm, but there are actually some analyses she might do later where depth doesn’t matter, so instead, she’ll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.\n\n\n\n\n\n\nRemoving Unneeded Files\n\n\n\nSuppose you want to delete your processed data files, and only keep your raw files and processing script to save storage. The raw files end in .dat and the processed files end in .txt. Which of the following would remove all the processed data files, and only the processed data files?\n\nrm ?.txt\nrm *.txt\nrm * .txt\nrm *.*\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThis would remove .txt files with one-character names\nThis is the correct answer\nThe shell would expand * to match everything in the current directory, so the command would try to remove all matched files and an additional file called .txt\nThe shell expands *.* to match all filenames containing at least one ., including the processed files (.txt) and raw files (.dat)\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nwc counts lines, words, and characters in its inputs.\ncat displays the contents of its inputs.\nsort sorts its inputs.\nhead displays the first 10 lines of its input by default without additional arguments.\ntail displays the last 10 lines of its input by default without additional arguments.\ncommand &gt; [file] redirects a command’s output to a file (overwriting any existing content).\ncommand &gt;&gt; [file] appends a command’s output to a file.\n[first] | [second] is a pipeline: the output of the first command is used as the input to the second.\nThe best way to use the shell is to use pipes to combine simple single-purpose programs (filters).\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/04-permissions.html",
    "href": "episodes/04-permissions.html",
    "title": "File Permissions",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 10\nExercises: 5\nQuestions:\n\nHow do file and directory permissions work?\n\nObjectives:\n\nWhat are file and directory permissions?\nHow to view permissions?\nHow to change permissions?\nWhat are permission differences on Windows?\nUnix controls who can read, modify, and run files using permissions. We’ll discuss how Windows handles permissions at the end of the section: the concepts are similar, but the rules are different.\nLet’s start with Nelle. She has a unique user name, nnemo, and a user ID, 1404.\nUsers can belong to any number of groups, each with a name and numeric group ID. The list of who’s in what group is usually stored in the file /etc/group. (If you’re in front of a Unix machine right now, try running cat /etc/group to look at that file.)\nNow let’s look at files and directories. Every file and directory on a Unix computer belongs to one owner and one group. Along with each file’s content, the operating system stores the numeric IDs of the user and group that own it.\nThe user-and-group model means that for each file every user on the system falls into one of three categories: the owner of the file, someone in the file’s group, and everyone else.\nFor each of these three categories, the computer keeps track of whether people in that category can read the file, write to the file, or execute the file (i.e., run it if it is a program).\nFor example, if a file had the following set of permissions:\nit would mean that:\nLet’s look at this model in action. If we cd into the labs directory and run ls -F, it puts a * at the end of setup’s name. This is its way of telling us that setup is executable, i.e., that it’s (probably) something the computer can run."
  },
  {
    "objectID": "episodes/04-permissions.html#what-about-windows",
    "href": "episodes/04-permissions.html#what-about-windows",
    "title": "File Permissions",
    "section": "What about Windows?",
    "text": "What about Windows?\nThose are the basics of permissions on Unix. As we said at the outset, though, things work differently on Windows. There, permissions are defined by access control lists (ACLs). An ACL is a list of pairs, each of which combines a “who” with a “what”. For example, you could give the Mummy permission to append data to a file without giving him permission to read or delete it, and give Frankenstein permission to delete a file without being able to see what it contains.\nThis is more flexible that the Unix model, but it’s also more complex to administer and understand on small systems. (If you have a large computer system, nothing is easy to administer or understand.) Some modern variants of Unix support ACLs as well as the older read-write-execute permissions, but hardly anyone uses them.\n\n\n\n\n\n\nNote\n\n\n\nUnix uses owner/group/others with rwx triplets; Windows ACLs grant fine‑grained rights per user or group. Same ideas, different mechanisms.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIf ls -l myfile.php returns the following details:\n-rwxr-xr-- 1 caro zoo  2312  2014-10-25 18:30 myfile.php\nWhich of the following statements is true?\n\ncaro (the owner) can read, write, and execute myfile.php\ncaro (the owner) cannot write to myfile.php\nmembers of caro (a group) can read, write, and execute myfile.php\nmembers of zoo (a group) cannot execute myfile.php\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct. The mode -rwxr-xr-- gives the owner rwx, the group r-x, and others r--. Therefore the owner can read, write, and execute; group members can read and execute (not write); others can only read.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nCorrect permissions are critical for the security of a system.\nFile permissions describe who and what can read, write, modify, and access a file.\nUse ls -l to view the permissions for a specific file.\nUse chmod to change permissions on a file or directory.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/08-find.html",
    "href": "episodes/08-find.html",
    "title": "Finding Things",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 25\nExercises: 20\nQuestions:\n\nHow can I find files?\nHow can I find things in files?\n\nObjectives:\n\nUse grep to select lines from text files that match simple patterns.\nUse find to find files and directories whose names match simple patterns.\nUse the output of one command as the command-line argument(s) to another command.\nExplain what is meant by ‘text’ and ‘binary’ files, and why many common tools don’t handle the latter well.\n\n\n\n\nIn the same way that many of us now use ‘Google’ as a verb meaning ‘to find’, Unix programmers often use the word ‘grep’. ‘grep’ is a contraction of ‘global/regular expression/print’, a common sequence of operations in early Unix text editors. It is also the name of a very useful command-line program.\ngrep finds and prints lines in files that match a pattern. For our examples, we will use a file that contains three haiku taken from a 1998 competition in Salon magazine (Credit to authors Bill Torcaso, Howard Korder, and Margaret Segall, respectively. See Haiku Error Messages archived Page 1 and Page 2 .). For this set of examples, we’re going to be working in the writing subdirectory:\ncd\ncd Desktop/shell-lesson-data/exercise-data/writing\ncat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that.\nLet’s find lines that contain the word ‘not’:\ngrep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nHere, not is the pattern we’re searching for. The grep command searches through the file, looking for matches to the pattern specified. To use it type grep, then the pattern we’re searching for and finally the name of the file (or files) we’re searching in.\nThe output is the three lines in the file that contain the letters ‘not’.\nBy default, grep searches for a pattern in a case-sensitive way. In addition, the search pattern we have selected does not have to form a complete word, as we will see in the next example.\nLet’s search for the pattern: ‘The’.\ngrep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\nThis time, two lines that include the letters ‘The’ are outputted, one of which contained our search pattern within a larger word, ‘Thesis’.\nTo restrict matches to lines containing the word ‘The’ on its own, we can give grep the -w option. This will limit matches to word boundaries.\nLater in this lesson, we will also see how we can change the search behavior of grep with respect to its case sensitivity.\ngrep -w The haiku.txt\nThe Tao that is seen\nNote that a ‘word boundary’ includes the start and end of a line, so not just letters surrounded by spaces. Sometimes we don’t want to search for a single word, but a phrase. We can also do this with grep by putting the phrase in quotes.\ngrep -w \"is not\" haiku.txt\nToday it is not working\nWe’ve now seen that you don’t have to have quotes around single words, but it is useful to use quotes when searching for multiple words. It also helps to make it easier to distinguish between the search term or phrase and the file being searched. We will use quotes in the remaining examples.\nAnother useful option is -n, which numbers the lines that match:\ngrep -n \"it\" haiku.txt\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\nHere, we can see that lines 5, 9, and 10 contain the letters ‘it’.\nWe can combine options (i.e. flags) as we do with other Unix commands. For example, let’s find the lines that contain the word ‘the’. We can combine the option -w to find the lines that contain the word ‘the’ and -n to number the lines that match:\ngrep -n -w \"the\" haiku.txt\n2:Is not the true Tao, until\n6:and the presence of absence:\nNow we want to use the option -i to make our search case-insensitive:\ngrep -n -w -i \"the\" haiku.txt\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:\nNow, we want to use the option -v to invert our search, i.e., we want to output the lines that do not contain the word ‘the’.\ngrep -n -w -v \"the\" haiku.txt\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\nIf we use the -r (recursive) option, grep can search for a pattern recursively through a set of files in subdirectories.\nLet’s search recursively for Yesterday in the shell-lesson-data/exercise-data/writing directory:\ngrep -r Yesterday .\n./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n./haiku.txt:Yesterday it worked\ngrep has lots of other options. To find out what they are, we can type:\ngrep --help\nUsage: grep [OPTION]... PATTERN [FILE]...\nSearch for PATTERN in each FILE or standard input.\nPATTERN is, by default, a basic regular expression (BRE).\nExample: grep -i 'hello world' menu.h main.c\n\nRegexp selection and interpretation:\n  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n\nMiscellaneous:\n...        ...        ...\n\n\n\n\n\n\nUsing grep\n\n\n\nWhich command would result in the following output:\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 3, because the -w option looks only for whole-word matches. The other options will also match ‘of’ when part of another word.\n\n\n\n\n\n\n\n\n\nWildcards\n\n\n\ngrep‘s real power doesn’t come from its options, though; it comes from the fact that patterns can include wildcards. (The technical name for these is regular expressions, which is what the ’re’ in ‘grep’ stands for.) Regular expressions are both complex and powerful; if you want to do complex searches, please look at the lesson on our website. As a taster, we can find lines that have an ‘o’ in the second position like this:\ngrep -E \"^.o\" haiku.txt\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\nWe use the -E option and put the pattern in quotes to prevent the shell from trying to interpret it. (If the pattern contained a *, for example, the shell would try to expand it before running grep.) The ^ in the pattern anchors the match to the start of the line. The . matches a single character (just like ? in the shell), while the o matches an actual ‘o’.\n\n\n\nFinding by Permissions\nfind can filter by file permissions using -perm. This is handy for locating executables or overly open files.\nFind regular files the owner can execute:\nfind . -type f -perm -u=x\nFind files writable by the group or readable by others:\nfind . -type f -perm -g=w      # group has write\nfind . -type f -perm -o=r      # others have read\nThe leading - before each mode (e.g., -u=x) means “match if these bits are set”, not exactly equal to the mode.\n\n\n\n\n\n\nTracking a Species\n\n\n\nLeah has several hundred data files saved in one directory, each of which is formatted like this:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nShe wants to write a shell script that takes a species as the first command-line argument and a directory as the second argument. The script should return one file called &lt;species&gt;.txt containing a list of dates and the number of that species seen on each date. For example using the data shown above, rabbit.txt would contain:\n2012-11-05,22\n2012-11-06,19\n2012-11-07,16\nBelow, each line contains an individual command, or pipe. Arrange their sequence in one command in order to achieve Leah’s goal:\ncut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\nHint: use man grep to look for how to grep text recursively in a directory and man cut to select more than one field in a line.\nAn example of such a file is provided in shell-lesson-data/exercise-data/animal-counts/animals.csv\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ngrep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\nActually, you can swap the order of the two cut commands and it still works. At the command line, try changing the order of the cut commands, and have a look at the output from each step to see why this is the case.\nYou would call the script above like this:\nbash count-species.sh bear .\n\n\n\n\n\n\n\n\n\nLittle Women\n\n\n\nYou and your friend, having just finished reading Little Women by Louisa May Alcott, are in an argument. Of the four sisters in the book, Jo, Meg, Beth, and Amy, your friend thinks that Jo was the most mentioned. You, however, are certain it was Amy. Luckily, you have a file LittleWomen.txt containing the full text of the novel (shell-lesson-data/exercise-data/writing/LittleWomen.txt). Using a for loop, how would you tabulate the number of times each of the four sisters is mentioned?\nHint: one solution might employ the commands grep and wc and a |, while another might utilize grep options. There is often more than one way to solve a programming task, so a particular solution is usually chosen based on a combination of yielding the correct result, elegance, readability, and speed.\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nfor sis in Jo Meg Beth Amy\ndo\n    echo $sis:\n    grep -ow $sis LittleWomen.txt | wc -l\ndone\nAlternative, slightly inferior solution:\nfor sis in Jo Meg Beth Amy\ndo\n    echo $sis:\n    grep -ocw $sis LittleWomen.txt\ndone\nThis solution is inferior because grep -c only reports the number of lines matched. The total number of matches reported by this method will be lower if there is more than one match per line.\nPerceptive observers may have noticed that character names sometimes appear in all-uppercase in chapter titles (e.g. ‘MEG GOES TO VANITY FAIR’). If you wanted to count these as well, you could add the -i option for case-insensitivity (though in this case, it doesn’t affect the answer to which sister is mentioned most frequently).\n\n\n\nWhile grep finds lines in files, the find command finds files themselves. Again, it has a lot of options; to show how the simplest ones work, we’ll use the shell-lesson-data/exercise-data directory tree shown below.\n.\n├── animal-counts/\n│   └── animals.csv\n├── creatures/\n│   ├── basilisk.dat\n│   ├── minotaur.dat\n│   └── unicorn.dat\n├── numbers.txt\n├── alkanes/\n│   ├── cubane.pdb\n│   ├── ethane.pdb\n│   ├── methane.pdb\n│   ├── octane.pdb\n│   ├── pentane.pdb\n│   └── propane.pdb\n└── writing/\n    ├── haiku.txt\n    └── LittleWomen.txt\nThe exercise-data directory contains one file, numbers.txt and four directories: animal-counts, creatures, alkanes and writing containing various files.\nFor our first command, let’s run find . (remember to run this command from the shell-lesson-data/exercise-data folder).\nfind .\n.\n./writing\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./creatures\n./creatures/basilisk.dat\n./creatures/unicorn.dat\n./creatures/minotaur.dat\n./animal-counts\n./animal-counts/animals.csv\n./numbers.txt\n./alkanes\n./alkanes/ethane.pdb\n./alkanes/propane.pdb\n./alkanes/octane.pdb\n./alkanes/pentane.pdb\n./alkanes/methane.pdb\n./alkanes/cubane.pdb\nAs always, the . on its own means the current working directory, which is where we want our search to start. find’s output is the names of every file and directory under the current working directory. This can seem useless at first but find has many options to filter the output and in this lesson we will discover some of them.\nThe first option in our list is -type d that means ‘things that are directories’. Sure enough, find’s output is the names of the five directories (including .):\nfind . -type d\n.\n./writing\n./creatures\n./animal-counts\n./alkanes\nNotice that the objects find finds are not listed in any particular order. If we change -type d to -type f, we get a listing of all the files instead:\nfind . -type f\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./creatures/basilisk.dat\n./creatures/unicorn.dat\n./creatures/minotaur.dat\n./animal-counts/animals.csv\n./numbers.txt\n./alkanes/ethane.pdb\n./alkanes/propane.pdb\n./alkanes/octane.pdb\n./alkanes/pentane.pdb\n./alkanes/methane.pdb\n./alkanes/cubane.pdb\nNow let’s try matching by name:\nfind . -name *.txt\n./numbers.txt\nWe expected it to find all the text files, but it only prints out ./numbers.txt. The problem is that the shell expands wildcard characters like * before commands run. Since *.txt in the current directory expands to ./numbers.txt, the command we actually ran was:\nfind . -name numbers.txt\nfind did what we asked; we just asked for the wrong thing.\nTo get what we want, let’s do what we did with grep: put *.txt in quotes to prevent the shell from expanding the * wildcard. This way, find actually gets the pattern *.txt, not the expanded filename numbers.txt:\nfind . -name \"*.txt\"\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./numbers.txt\n\n\n\n\n\n\nListing vs. Finding\n\n\n\nls and find can be made to do similar things given the right options, but under normal circumstances, ls lists everything it can, while find searches for things with certain properties and shows them.\n\n\nAs we said earlier, the command line’s power lies in combining tools. We’ve seen how to do that with pipes; let’s look at another technique. As we just saw, find . -name \"*.txt\" gives us a list of all text files in or below the current directory. How can we combine that with wc -l to count the lines in all those files?\nThe simplest way is to put the find command inside $():\nwc -l $(find . -name \"*.txt\")\n  21022 ./writing/LittleWomen.txt\n     11 ./writing/haiku.txt\n      5 ./numbers.txt\n  21038 total\nWhen the shell executes this command, the first thing it does is run whatever is inside the $(). It then replaces the $() expression with that command’s output. Since the output of find is the three filenames ./writing/LittleWomen.txt, ./writing/haiku.txt, and ./numbers.txt, the shell constructs the command:\nwc -l ./writing/LittleWomen.txt ./writing/haiku.txt ./numbers.txt\nwhich is what we wanted. This expansion is exactly what the shell does when it expands wildcards like * and ?, but lets us use any command we want as our own ‘wildcard’.\nIt’s very common to use find and grep together. The first finds files that match a pattern; the second looks for lines inside those files that match another pattern. Here, for example, we can find txt files that contain the word “searching” by looking for the string ‘searching’ in all the .txt files in the current directory:\ngrep \"searching\" $(find . -name \"*.txt\")\n./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was\n./writing/haiku.txt:With searching comes loss\n\n\n\n\n\n\nMatching and Subtracting\n\n\n\nThe -v option to grep inverts pattern matching, so that only lines which do not match the pattern are printed. Given that, which of the following commands will find all .dat files in creatures except unicorn.dat? Once you have thought about your answer, you can test the commands in the shell-lesson-data/exercise-data directory.\n\nfind creatures -name \"*.dat\" | grep -v unicorn\nfind creatures -name *.dat | grep -v unicorn\ngrep -v \"unicorn\" $(find creatures -name \"*.dat\")\nNone of the above.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct. Putting the match expression in quotes prevents the shell expanding it, so it gets passed to the find command.\nOption 2 also works in this instance because the shell tries to expand *.dat but there are no *.dat files in the current directory, so the wildcard expression gets passed to find. We first encountered this in episode 3.\nOption 3 is incorrect because it searches the contents of the files for lines which do not match ‘unicorn’, rather than searching the file names.\n\n\n\n\n\n\n\n\n\nBinary Files\n\n\n\nWe have focused exclusively on finding patterns in text files. What if your data is stored as images, in databases, or in some other format?\nA handful of tools extend grep to handle a few non text formats. But a more generalizable approach is to convert the data to text, or extract the text-like elements from the data. On the one hand, it makes simple things easy to do. On the other hand, complex things are usually impossible. For example, it’s easy enough to write a program that will extract X and Y dimensions from image files for grep to play with, but how would you write something to find values in a spreadsheet whose cells contained formulas?\nA last option is to recognize that the shell and text processing have their limits, and to use another programming language. When the time comes to do this, don’t be too hard on the shell. Many modern programming languages have borrowed a lot of ideas from it, and imitation is also the sincerest form of praise.\n\n\nThe Unix shell is older than most of the people who use it. It has survived so long because it is one of the most productive programming environments ever created — maybe even the most productive. Its syntax may be cryptic, but people who have mastered it can experiment with different commands interactively, then use what they have learned to automate their work. Graphical user interfaces may be easier to use at first, but once learned, the productivity in the shell is unbeatable. And as Alfred North Whitehead wrote in 1911, ‘Civilization advances by extending the number of important operations which we can perform without thinking about them.’\n\n\n\n\n\n\nfind Pipeline Reading Comprehension\n\n\n\nWrite a short explanatory comment for the following shell script:\nwc -l $(find . -name \"*.dat\") | sort -n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nFind all files with a .dat extension recursively from the current directory\nCount the number of lines each of these files contains\nSort the output from step 2. numerically\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nfind finds files with specific properties that match patterns.\ngrep selects lines in files that match patterns.\n--help is an option supported by many bash commands, and programs that can be run from within Bash, to display more information on how to use these commands or programs.\nman [command] displays the manual page for a given command.\n$([command]) inserts a command’s output in place.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/01-intro.html",
    "href": "episodes/01-intro.html",
    "title": "Introducing the Shell",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 5\nExercises: 0\nQuestions:\n\nWhat is a command shell and why would I use one?\n\nObjectives:\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users’ programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces."
  },
  {
    "objectID": "episodes/01-intro.html#nelles-pipeline-a-typical-problem",
    "href": "episodes/01-intro.html#nelles-pipeline-a-typical-problem",
    "title": "Introducing the Shell",
    "section": "Nelle’s Pipeline: A Typical Problem",
    "text": "Nelle’s Pipeline: A Typical Problem\nNelle Nemo, a marine biologist, has just returned from a six-month survey of the North Pacific Gyre, where she has been sampling gelatinous marine life in the Great Pacific Garbage Patch. She has 1520 samples that she’s run through an assay machine to measure the relative abundance of 300 proteins. She needs to run these 1520 files through an imaginary program called goostats.sh. In addition to this huge task, she has to write up results by the end of the month, so her paper can appear in a special issue of Aquatic Goo Letters.\nIf Nelle chooses to run goostats.sh by hand using a GUI, she’ll have to select and open a file 1520 times. If goostats.sh takes 30 seconds to run each file, the whole process will take more than 12 hours of Nelle’s attention. With the shell, Nelle can instead assign her computer this mundane task while she focuses her attention on writing her paper.\nThe next few lessons will explore the ways Nelle can achieve this. More specifically, the lessons explain how she can use a command shell to run the goostats.sh program, using loops to automate the repetitive steps of entering file names, so that her computer can work while she writes her paper.\nAs a bonus, once she has put a processing pipeline together, she will be able to use it again whenever she collects more data.\nIn order to achieve her task, Nelle needs to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing her pipeline\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.\n\n\n\n\n\n\n \n\n\nNext →"
  },
  {
    "objectID": "episodes/06-loop.html",
    "href": "episodes/06-loop.html",
    "title": "Loops",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 40\nExercises: 10\nQuestions:\n\nHow can I perform the same actions on many different files?\n\nObjectives:\n\nWrite a loop that applies one or more commands separately to each file in a set of files.\nTrace the values taken on by a loop variable during execution of the loop.\nExplain the difference between a variable’s name and its value.\nExplain why spaces and some punctuation characters shouldn’t be used in file names.\nDemonstrate how to see what commands have recently been executed.\nRe-run recently executed commands without retyping them.\nLoops are a programming construct which allow us to repeat a command or set of commands for each item in a list. As such they are key to productivity improvements through automation. Similar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes).\nSuppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat. For this example, we’ll use the exercise-data/creatures directory which only has three example files, but the principles can be applied to many many more files at once.\nThe structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines. Let’s look at the files:\nWe would like to print out the classification for each species, which is given on the second line of each file. For each file, we would need to execute the command head -n 2 and pipe this to tail -n 1. We’ll use a loop to solve this problem, but first let’s look at the general form of a loop, using the pseudo-code below:\nand we can apply this to our example like this:\nWhen the shell sees the keyword for, it knows to repeat a command (or group of commands) once for each item in a list. Each time the loop runs (called an iteration), an item in the list is assigned in sequence to the variable, and the commands inside the loop are executed, before moving on to the next item in the list. Inside the loop, we call for the variable’s value by putting $ in front of it. The $ tells the shell interpreter to treat the variable as a variable name and substitute its value in its place, rather than treat it as text or an external command.\nIn this example, the list is three filenames: basilisk.dat, minotaur.dat, and unicorn.dat. Each time the loop iterates, we first use echo to print the value that the variable $filename currently holds. This is not necessary for the result, but beneficial for us here to have an easier time to follow along. Next, we will run the head command on the file currently referred to by $filename. The first time through the loop, $filename is basilisk.dat. The interpreter runs the command head on basilisk.dat and pipes the first two lines to the tail command, which then prints the second line of basilisk.dat. For the second iteration, $filename becomes minotaur.dat. This time, the shell runs head on minotaur.dat and pipes the first two lines to the tail command, which then prints the second line of minotaur.dat. For the third iteration, $filename becomes unicorn.dat, so the shell runs the head command on that file, and tail on the output of that. Since the list was only three items, the shell exits the for loop.\nWhen using variables it is also possible to put the names into curly braces to clearly delimit the variable name: $filename is equivalent to ${filename}, but is different from ${file}name. You may find this notation in other people’s programs.\nWe have called the variable in this loop filename in order to make its purpose clearer to human readers. The shell itself doesn’t care what the variable is called; if we wrote this loop as:\nor:\nit would work exactly the same way. Don’t do this. Programs are only useful if people can understand them, so meaningless names (like x) or misleading names (like temperature) increase the odds that the program won’t do what its readers think it does.\nIn the above examples, the variables (thing, filename, x and temperature) could have been given any other name, as long as it is meaningful to both the person writing the code and the person reading it.\nNote also that loops can be used for other things than filenames, like a list of numbers or a subset of data.\nLet’s continue with our example in the shell-lesson-data/exercise-data/creatures directory. Here’s another example:\nThe shell starts by expanding *.dat to create the list of files it will process. The loop body then executes two commands for each of those files. In the first command, $filename is expanded to the name of the file, so echo $filename prints the name of the file. Then, the head and tail combination selects lines 81-100 from whatever file is being processed (assuming the file has at least 100 lines).\nWe would like to modify each of the files in shell-lesson-data/exercise-data/creatures, but also save a version of the original files. We want to copy the original files to new files named original-basilisk.dat and original-unicorn.dat, for example. We can’t use:\nbecause that would expand to:\nThis wouldn’t back up our files, instead we get an error:\nThis problem arises when cp receives more than two inputs. When this happens, it expects the last input to be a directory where it can copy all the files it was passed. Since there is no directory named original-*.dat in the creatures directory, we get an error.\nInstead, we can use a loop:\nThis loop runs the cp command once for each filename. The first time, when $filename expands to basilisk.dat, the shell executes:\nThe second time, the command is:\nThe third and last time, the command is:\nSince the cp command does not normally produce any output, it’s hard to check that the loop is working correctly. However, we learned earlier how to print strings using echo, and we can modify the loop to use echo to print our commands without actually executing them. As such we can check what commands would be run in the unmodified loop.\nThe following diagram shows what happens when the modified loop is executed and demonstrates how the judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "episodes/06-loop.html#nelles-pipeline-processing-files",
    "href": "episodes/06-loop.html#nelles-pipeline-processing-files",
    "title": "Loops",
    "section": "Nelle’s Pipeline: Processing Files",
    "text": "Nelle’s Pipeline: Processing Files\nNelle is now ready to process her data files using goostats.sh — a shell script written by her supervisor. This calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince she’s still learning how to use the shell, she decides to build up the required commands in stages. Her first step is to make sure that she can select the right input files — remember, these are ones whose names end in ‘A’ or ‘B’, rather than ‘Z’. Moving to the north-pacific-gyre directory, Nelle types:\ncd\ncd Desktop/shell-lesson-data/north-pacific-gyre\nfor datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile\n&gt; done\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n\n...\nNENE02040B.txt\nNENE02043B.txt\nHer next step is to decide what to call the files that the goostats.sh analysis program will create. Prefixing each input file’s name with ‘stats’ seems simple, so she modifies her loop to do that:\nfor datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile stats-$datafile\n&gt; done\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01729A.txt\nNENE01751A.txt stats-NENE01729A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nShe hasn’t actually run goostats.sh yet, but now she’s sure she can select the right files and generate the right output filenames.\nTyping in commands over and over again is becoming tedious, though, and Nelle is worried about making mistakes, so instead of re-entering her loop, she presses ↑. In response, the shell redisplays the whole loop on one line (using semi-colons to separate the pieces):\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nUsing the ←, Nelle navigates to the echo command and changes it to bash goostats.sh:\nfor datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\nWhen she presses Enter, the shell runs the modified command. However, nothing appears to happen — there is no output. After a moment, Nelle realizes that since her script doesn’t print anything to the screen any longer, she has no idea whether it is running, much less how quickly. She kills the running command by typing Ctrl+C, uses ↑ to repeat the command, and edits it to read:\nfor datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\nbash goostats.sh $datafile stats-$datafile; done\n\n\n\n\n\n\nBeginning and End\n\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E.\n\n\nWhen she runs her program now, it produces one line of output every five seconds or so:\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\n1518 times 5 seconds, divided by 60, tells her that her script will take about two hours to run. As a final check, she opens another terminal window, goes into north-pacific-gyre, and uses cat stats-NENE01729B.txt to examine one of the output files. It looks good, so she decides to get some coffee and catch up on her reading.\n\n\n\n\n\n\nThose Who Know History Can Choose to Repeat It\n\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where ‘123’ is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:\nhistory | tail -n 5\n456  for datafile in NENE*A.txt NENE*B.txt; do   echo $datafile stats-$datafile; done\n457  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n458  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n459  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; bash goostats.sh $datafile\nstats-$datafile; done\n460  history | tail -n 5\nthen she can re-run goostats.sh on the files simply by typing !459.\n\n\n\n\n\n\n\n\nOther History Commands\n\n\n\nThere are a number of other shortcut commands for getting at the history.\n\nCtrl+R enters a history search mode ‘reverse-i-search’ and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ↑)\n!$ retrieves the last word of the last command. That’s useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ↑ and editing the command-line.\n\n\n\n\n\n\n\n\n\nDoing a Dry Run\n\n\n\nA loop is a way to do many things at once — or to make many mistakes at once if it does the wrong thing. One way to check what a loop would do is to echo the commands it would run instead of actually running them.\nSuppose we want to preview the commands the following loop will execute without actually running those commands:\nfor datafile in *.pdb\n&gt; do\n&gt;     cat $datafile &gt;&gt; all.pdb\n&gt; done\nWhat is the difference between the two loops below, and which one would we want to run?\n# Version 1\nfor datafile in *.pdb\n&gt; do\n&gt;     echo cat $datafile &gt;&gt; all.pdb\n&gt; done\n# Version 2\nfor datafile in *.pdb\n&gt; do\n&gt;     echo \"cat $datafile &gt;&gt; all.pdb\"\n&gt; done\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also does not modify nor create the file all.pdb, as the &gt;&gt; is treated literally as part of a string rather than as a redirection instruction.\nThe first version appends the output from the command echo cat $datafile to the file, all.pdb. This file will just contain the list; cat cubane.pdb, cat ethane.pdb, cat methane.pdb etc.\nTry both versions for yourself to see the output! Be sure to open the all.pdb file to view its contents.\n\n\n\n\n\n\n\n\n\nNested Loops\n\n\n\nSuppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds and different temperatures. What would be the result of the following code:\nfor species in cubane ethane methane\n&gt; do\n&gt;     for temperature in 25 30 37 40\n&gt;     do\n&gt;         mkdir $species-$temperature\n&gt;     done\n&gt; done\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe have a nested loop, i.e. contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.\nTry running the code for yourself to see which directories are created!\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA for loop repeats commands once for every thing in a list.\nEvery for loop needs a variable to refer to the thing it is currently operating on.\nUse $name to expand a variable (i.e., get its value). ${name} can also be used.\nDo not use spaces, quotes, or wildcard characters such as ’*’ or ‘?’ in filenames, as it complicates variable expansion.\nGive files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.\nUse the up-arrow key to scroll up through previous commands to edit and repeat them.\nUse Ctrl+R to search through the previously entered commands.\nUse history to display recent commands, and ![number] to repeat a command by number.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/07-script.html",
    "href": "episodes/07-script.html",
    "title": "Shell Scripts",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 15\nQuestions:\n\nHow can I save and re-use commands?\n\nObjectives:\n\nWrite a shell script that runs a command or series of commands for a fixed set of files.\nRun a shell script from the command line.\nWrite a shell script that operates on a set of files defined by the user on the command line.\nCreate pipelines that include shell scripts you, and others, have written.\nWe are finally ready to see what makes the shell such a powerful programming environment. We are going to take the commands we repeat frequently and save them in files so that we can re-run all those operations again later by typing a single command. For historical reasons, a bunch of commands saved in a file is usually called a shell script, but make no mistake — these are actually small programs.\nNot only will writing shell scripts make your work faster, but also you won’t have to retype the same commands over and over again. It will also make it more accurate (fewer chances for typos) and more reproducible. If you come back to your work later (or if someone else finds your work and wants to build on it), you will be able to reproduce the same results simply by running your script, rather than having to remember or retype a long list of commands.\nLet’s start by going back to alkanes/ and creating a new file, middle.sh which will become our shell script:\nThe command nano middle.sh opens the file middle.sh within the text editor ‘nano’ (which runs within the shell). If the file does not exist, it will be created. We can use the text editor to directly edit the file by inserting the following line:\nThis is a variation on the pipe we constructed earlier, which selects lines 11-15 of the file octane.pdb. Remember, we are not running it as a command just yet; we are only incorporating the commands in a file.\nThen we save the file (Ctrl-O in nano) and exit the text editor (Ctrl-X in nano). Check that the directory alkanes now contains a file called middle.sh.\nOnce we have saved the file, we can ask the shell to execute the commands it contains. Our shell is called bash, so we run the following command:\nSure enough, our script’s output is exactly what we would get if we ran that pipeline directly.\nWhat if we want to select lines from an arbitrary file? We could edit middle.sh each time to change the filename, but that would probably take longer than typing the command out again in the shell and executing it with a new file name. Instead, let’s edit middle.sh and make it more versatile:\nNow, within “nano”, replace the text octane.pdb with the special variable called $1:\nInside a shell script, $1 means ‘the first filename (or other argument) on the command line’. We can now run our script like this:\nor on a different file like this:\nCurrently, we need to edit middle.sh each time we want to adjust the range of lines that is returned. Let’s fix that by configuring our script to instead use three command-line arguments. After the first command-line argument ($1), each additional argument that we provide will be accessible via the special variables $1, $2, $3, which refer to the first, second, third command-line arguments, respectively.\nKnowing this, we can use additional arguments to define the range of lines to be passed to head and tail respectively:\nWe can now run:\nBy changing the arguments to our command, we can change our script’s behaviour:\nThis works, but it may take the next person who reads middle.sh a moment to figure out what it does. We can improve our script by adding some comments at the top:\nA comment starts with a # character and runs to the end of the line. The computer ignores comments, but they’re invaluable for helping people (including your future self) understand and use scripts. The only caveat is that each time you modify the script, you should check that the comment is still accurate. An explanation that sends the reader in the wrong direction is worse than none at all.\nWhat if we want to process many files in a single pipeline? For example, if we want to sort our .pdb files by length, we would type:\nbecause wc -l lists the number of lines in the files (recall that wc stands for ‘word count’, adding the -l option means ‘count lines’ instead) and sort -n sorts things numerically. We could put this in a file, but then it would only ever sort a list of .pdb files in the current directory. If we want to be able to get a sorted list of other kinds of files, we need a way to get all those names into the script. We can’t use $1, $2, and so on because we don’t know how many files there are. Instead, we use the special variable $@, which means, ‘All of the command-line arguments to the shell script’. We also should put $@ inside double-quotes to handle the case of arguments containing spaces (\"$@\" is special syntax and is equivalent to \"$1\" \"$2\" …).\nHere’s an example:\nSuppose we have just run a series of commands that did something useful — for example, creating a graph we’d like to use in a paper. We’d like to be able to re-create the graph later if we need to, so we want to save the commands in a file. Instead of typing them in again (and potentially getting them wrong) we can do this:\nThe file redo-figure-3.sh now contains:\nAfter a moment’s work in an editor to remove the serial numbers on the commands, and to remove the final line where we called the history command, we have a completely accurate record of how we created that figure.\nIn practice, most people develop shell scripts by running commands at the shell prompt a few times to make sure they’re doing the right thing, then saving them in a file for re-use. This style of work allows people to recycle what they discover about their data and their workflow with one call to history and a bit of editing to clean up the output and save it as a shell script."
  },
  {
    "objectID": "episodes/07-script.html#nelles-pipeline-creating-a-script",
    "href": "episodes/07-script.html#nelles-pipeline-creating-a-script",
    "title": "Shell Scripts",
    "section": "Nelle’s Pipeline: Creating a Script",
    "text": "Nelle’s Pipeline: Creating a Script\nNelle’s supervisor insisted that all her analytics must be reproducible. The easiest way to capture all the steps is in a script.\nFirst we return to Nelle’s project directory:\ncd ../../north-pacific-gyre/\nShe creates a file using nano …\nnano do-stats.sh\n…which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nShe saves this in a file called do-stats.sh so that she can now re-do the first stage of her analysis by typing:\nbash do-stats.sh NENE*A.txt NENE*B.txt\nShe can also do this:\nbash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed.\nOne thing to note about Nelle’s script is that it lets the person running it decide what files to process. She could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nThe advantage is that this always selects the right files: she doesn’t have to remember to exclude the ‘Z’ files. The disadvantage is that it always selects just those files — she can’t run it on all files (including the ‘Z’ files), or on the ‘G’ or ‘H’ files her colleagues in Antarctica are producing, without editing the script. If she wanted to be more adventurous, she could modify her script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided. Of course, this introduces another tradeoff between flexibility and complexity.\n\n\n\n\n\n\nVariables in Shell Scripts\n\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\nbash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\nhead -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\ntail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks. As such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail.\n\n\n\n\n\n\n\n\n\nFind the Longest File With a Given Extension\n\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension. For example:\nbash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\nbash longest.sh shell-lesson-data/exercise-data/writing txt\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last). When there’s more than one file, wc also outputs a final summary line, giving the total number of lines across all files. We use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we’ll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output.\n\n\n\n\n\n\n\n\n\nScript Reading Comprehension\n\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created. Explain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\n# Script 1\necho *.*\n# Script 2\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\n# Script 3\necho $@.pdb\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e. all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n\n\n\n\n\n\n\n\n\nDebugging Scripts\n\n\n\nSuppose you have saved the following script in a file called do-errors.sh in Nelle’s north-pacific-gyre directory:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats.sh $datafile stats-$datafile\ndone\nWhen you run it from the north-pacific-gyre directory:\nbash do-errors.sh NENE*A.txt NENE*B.txt\nthe output is blank. To figure out why, re-run the script using the -x option:\nbash -x do-errors.sh NENE*A.txt NENE*B.txt\nWhat is the output showing you? Which line is responsible for the error?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -x option causes bash to run in debug mode. This prints out each command as it is run, which will help you to locate errors. In this example, we can see that echo isn’t printing anything. We have made a typo in the loop variable name, and the variable datfile doesn’t exist, hence returning an empty string.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nSave commands in files (usually called shell scripts) for re-use.\nbash [filename] runs the commands saved in a file.\n$@ refers to all of a shell script’s command-line arguments.\n$1, $2, etc., refer to the first command-line argument, the second command-line argument, etc.\nPlace variables in quotes if the values might have spaces in them.\nLetting users decide what files to process is more flexible and more consistent with built-in Unix commands.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/09-awk.html",
    "href": "episodes/09-awk.html",
    "title": "AWK for Text Processing",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 20\nExercises: 5\nQuestions:\n\nHow do I print specific columns from a text table?\nHow can I use patterns to select only certain lines in a file?\nHow do I count lines or matched lines in a file?\n\nObjectives:\n\nSelect and print fields with $0, $1, $2, $NF, and NF.\nUse a field separator with -F to handle CSV input.\nMatch lines using simple regex like /^ATOM/.\nCount total or matching lines with a counter and the END block.\nExplain the difference between wc -l and awk 'END {print NR}' for line counting.\nIf we need to count the number of lines in a file, we can use the previously showed command for word counting wc\nAs you probably remember, -l is an option that asks for the number of lines only.\nHowever, wc counts the number of newlines in the file, if the last line does not contain a carriage return (i.e. there is no emptyline at the end of the file), the result is going be the actual number of lines minus one.\nA workaround is to use awk. awk is command line program that takes as input a set of instructions and one or more files. The instructions are executed on each line of the input file(s).\nThe instructions are enclosed in single quotes or they can be read from a file.\nExample:\nThis command has the same output of cat: it prints each line from the example.txt file.\nThe structure of the instruction is the following: - curly braces surround the set of instructions - print is the instruction that sends its arguments to the terminal - $0 is a variable, it means “the content of the current line”\nAs you can see, the file contains a table.\nAwk automatically splits the processed line by looking at spaces: in our case it has knowledge of the different columns in the table.\nEach column value for the current line is stored into a variable: $1 for the first column, $2 for the second and so on.\nSo, if we like to print only the second column from the table, we execute\nWe can also print more than one value, or add text to the printed line:\nThe comma puts a space between the printed values. Strings of text should be enclosed in double quotes. In this case we are printing the text “chr”, the second and the fourth column for each row in the table.\nSo, $0 is the whole line, $1 the first field, $2 the second and so on. What if we want to print the last column, but we don’t know its number? Maybe it is a huge table, or maybe different lines have a different number of columns.\nAwk helps us thanks to the variable NF. NF stores the number of fields (our columns) in the row. Let’s see for our table:\nWe can see that some lines contain 6 fields while others contain 7 of them. Since NF is the number of the last field, $NF contains its value.\nTo specify the field separator, we should provide it at command line like:\nIn this case, we are printing the second field in each line, using comma as separator. Please notice that the character space is now part of the field value, since it is no longer the separator."
  },
  {
    "objectID": "episodes/09-awk.html#pattern-action-model",
    "href": "episodes/09-awk.html#pattern-action-model",
    "title": "AWK for Text Processing",
    "section": "Pattern-Action Model",
    "text": "Pattern-Action Model\nAWK reads a file line by line, splits each line into fields, and then applies pattern { action } rules.\nMaybe we would like to perform different instruction on different lines. Awk allows you to specify a matching pattern, like the command grep does.\nLet’s look at the file content\nawk '{print $0}' example.pdb\nIt seems an abriged PDB file. If we would like to print only lines starting with the word “ATOM”, we type:\nawk '/^ATOM/ {print $0}' example.pdb\nIn this case, we specify the pattern before the instructions: only lines starting with the text “ATOM”. As you remember, ^ means “at the beginning of the line”.\nWe can specify more that one pattern:\nawk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb\nIn this case, we are printing the spatial coordinates of each atom.\nThe special block END { ... } runs after all lines are processed. It’s ideal for printing totals collected while scanning.\nNR is the current line number. After the last line, NR equals the number of lines read:\nawk 'END { print NR }' example.txt\nThis avoids the missing final newline issue that can affect wc -l (if the last line lacks a trailing newline, wc -l may under‑count by 1).\nTo Count only matching lines, increment a counter inside the pattern, then report it in END:\nawk '/^ATOM/ { count++ } END { print \"ATOM lines:\", count+0 }' example.pdb\n\n/^ATOM/ matches lines that begin with ATOM.\ncount++ adds 1 for each match.\nIn END, we print the total. count+0 safely prints 0 if there were no matches.\n\n\n\n\n\n\n\nChallenge: Counting and Selecting (Simple)\n\n\n\nUsing only the ideas covered above (field selection, patterns, NF, and END):\n\nWrite an awk command that prints the number of lines in example.txt.\nWrite an awk command that prints the number of lines in example.pdb that start with ATOM.\nWrite an awk command that prints the last field of each ATOM line in example.pdb (just the values, one per line).\n\nBonus (optional): Print both the count of ATOM lines and, at the end, the total number of characters across all those last fields.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nTotal lines (robust):\n\nawk 'END { print NR }' example.txt\n\nCount lines starting with ATOM:\n\nawk '/^ATOM/ { c++ } END { print c+0 }' example.pdb\n\nLast field of each ATOM line:\n\nawk '/^ATOM/ { print $NF }' example.pdb\nBonus (count and accumulate character lengths of last field):\nawk '/^ATOM/ { c++; total += length($NF) } END { print \"ATOM lines:\", c+0; print \"Total chars in last field:\", total+0 }' example.pdb\nExplanation: - NR gives total lines after reading the file. - /^ATOM/ pattern restricts actions to lines starting with ATOM. - $NF is the last field; length($NF) measures its size. - Counters (c, total) are printed in END.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\n$0 is the whole line; $1..$NF are its fields; NF is the count of fields.\n-F sets the field separator (comma, tab, etc.).\nUse /pattern/ { action } to run code only on matching lines.\nIncrement a variable inside the action and print totals in END {}.\nNR gives total lines read; wc -l can undercount if last newline is missing.\n\n\n\n\n\n\n← Previous"
  },
  {
    "objectID": "slides/08-find.html#two-types-of-searching",
    "href": "slides/08-find.html#two-types-of-searching",
    "title": "Episode 8: Finding Things",
    "section": "Two Types of Searching",
    "text": "Two Types of Searching\n1. Find files: by name, type, size, date\n2. Find text: search inside file contents\nWe’ll use find and grep respectively."
  },
  {
    "objectID": "slides/08-find.html#sample-data",
    "href": "slides/08-find.html#sample-data",
    "title": "Episode 8: Finding Things",
    "section": "Sample Data",
    "text": "Sample Data\nWe have haiku files:\n$ cat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that."
  },
  {
    "objectID": "slides/08-find.html#command-1-grep---search-text",
    "href": "slides/08-find.html#command-1-grep---search-text",
    "title": "Episode 8: Finding Things",
    "section": "Command 1: grep - Search Text",
    "text": "Command 1: grep - Search Text\nFind lines matching a pattern\n$ grep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nThe output shows all lines containing “not”."
  },
  {
    "objectID": "slides/08-find.html#grep-is-case-sensitive",
    "href": "slides/08-find.html#grep-is-case-sensitive",
    "title": "Episode 8: Finding Things",
    "section": "grep is Case-Sensitive",
    "text": "grep is Case-Sensitive\nSearch for “The”:\n$ grep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\n“Thesis” contains “The” but with different case!"
  },
  {
    "objectID": "slides/08-find.html#grep-with--i-flag",
    "href": "slides/08-find.html#grep-with--i-flag",
    "title": "Episode 8: Finding Things",
    "section": "grep with -i Flag",
    "text": "grep with -i Flag\nIgnore case:\n$ grep -i the haiku.txt\nNow matches: “The”, “the”, “THE”, etc."
  },
  {
    "objectID": "slides/08-find.html#whole-word-matching--w",
    "href": "slides/08-find.html#whole-word-matching--w",
    "title": "Episode 8: Finding Things",
    "section": "Whole Word Matching: -w",
    "text": "Whole Word Matching: -w\nMatch whole word only\nFind “Thesis”:\n$ grep -w Thesis haiku.txt\n\"My Thesis\" not found.\nDoesn’t match if “Thesis” is part of another word."
  },
  {
    "objectID": "slides/08-find.html#negation--v",
    "href": "slides/08-find.html#negation--v",
    "title": "Episode 8: Finding Things",
    "section": "Negation: -v",
    "text": "Negation: -v\nShow lines that DON’T match:\n$ grep -v not haiku.txt\nThe Tao that is seen\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\nYesterday it worked\nSoftware is like that."
  },
  {
    "objectID": "slides/08-find.html#regular-expressions",
    "href": "slides/08-find.html#regular-expressions",
    "title": "Episode 8: Finding Things",
    "section": "Regular Expressions",
    "text": "Regular Expressions\nPatterns beyond simple text\n\n\n\nPattern\nMatches\n\n\n\n\n^word\nword at start of line\n\n\nword$\nword at end of line\n\n\n.\nany single character\n\n\n.*\nany characters"
  },
  {
    "objectID": "slides/08-find.html#finding-lines-starting-with-text",
    "href": "slides/08-find.html#finding-lines-starting-with-text",
    "title": "Episode 8: Finding Things",
    "section": "Finding Lines Starting with Text",
    "text": "Finding Lines Starting with Text\n$ grep ^The haiku.txt\nThe Tao that is seen\nThe ^ means “start of line”."
  },
  {
    "objectID": "slides/08-find.html#finding-lines-ending-with-text",
    "href": "slides/08-find.html#finding-lines-ending-with-text",
    "title": "Episode 8: Finding Things",
    "section": "Finding Lines Ending with Text",
    "text": "Finding Lines Ending with Text\n$ grep working$ haiku.txt\nToday it is not working\nThe $ means “end of line”."
  },
  {
    "objectID": "slides/08-find.html#counting-matches--c",
    "href": "slides/08-find.html#counting-matches--c",
    "title": "Episode 8: Finding Things",
    "section": "Counting Matches: -c",
    "text": "Counting Matches: -c\nCount matching lines instead of showing them:\n$ grep -c \"not\" haiku.txt\n3\nThree lines contain “not”."
  },
  {
    "objectID": "slides/08-find.html#finding-files-command-1---find",
    "href": "slides/08-find.html#finding-files-command-1---find",
    "title": "Episode 8: Finding Things",
    "section": "Finding Files: Command 1 - find",
    "text": "Finding Files: Command 1 - find\nSearch for files by various properties\n$ find . -type f -name \"*.txt\"\nShows all .txt files in current directory and below."
  },
  {
    "objectID": "slides/08-find.html#find-options",
    "href": "slides/08-find.html#find-options",
    "title": "Episode 8: Finding Things",
    "section": "find Options",
    "text": "find Options\n\n\n\nOption\nMeaning\n\n\n\n\n-type f\nRegular files\n\n\n-type d\nDirectories\n\n\n-name \"*.txt\"\nMatching filename\n\n\n-size +1M\nLarger than 1 megabyte\n\n\n-mtime -7\nModified in last 7 days"
  },
  {
    "objectID": "slides/08-find.html#finding-by-name",
    "href": "slides/08-find.html#finding-by-name",
    "title": "Episode 8: Finding Things",
    "section": "Finding by Name",
    "text": "Finding by Name\n$ find . -name \"*.pdb\"\nAll .pdb files anywhere under current directory.\n$ find . -name \"haiku*\"\nAll files starting with “haiku”."
  },
  {
    "objectID": "slides/08-find.html#finding-by-type",
    "href": "slides/08-find.html#finding-by-type",
    "title": "Episode 8: Finding Things",
    "section": "Finding by Type",
    "text": "Finding by Type\nAll directories:\n$ find . -type d\nAll regular files:\n$ find . -type f"
  },
  {
    "objectID": "slides/08-find.html#finding-large-files",
    "href": "slides/08-find.html#finding-large-files",
    "title": "Episode 8: Finding Things",
    "section": "Finding Large Files",
    "text": "Finding Large Files\nLarger than 1 megabyte:\n$ find . -type f -size +1M\nSmaller than 100 kilobytes:\n$ find . -type f -size -100k"
  },
  {
    "objectID": "slides/08-find.html#finding-recently-modified",
    "href": "slides/08-find.html#finding-recently-modified",
    "title": "Episode 8: Finding Things",
    "section": "Finding Recently Modified",
    "text": "Finding Recently Modified\nModified in last 7 days:\n$ find . -type f -mtime -7\nModified in last 24 hours:\n$ find . -type f -mtime -1"
  },
  {
    "objectID": "slides/08-find.html#combining-grep-and-find",
    "href": "slides/08-find.html#combining-grep-and-find",
    "title": "Episode 8: Finding Things",
    "section": "Combining grep and find",
    "text": "Combining grep and find\nFind files, then search inside them\nFind all .pdb files containing “ATOM”:\n$ find . -name \"*.pdb\" -exec grep -l \"ATOM\" {} \\;\nBreaking it down: - find . -name \"*.pdb\" = find all .pdb files - -exec command {} \\; = run command on each - grep -l = show filenames with matches - {} = the found file - \\; = end of exec"
  },
  {
    "objectID": "slides/08-find.html#command-substitution",
    "href": "slides/08-find.html#command-substitution",
    "title": "Episode 8: Finding Things",
    "section": "Command Substitution: $()",
    "text": "Command Substitution: $()\nUse output of one command as input to another\n$ echo \"Files found: $(find . -name \"*.txt\")\"\nOutput:\nFiles found: haiku.txt notes.txt"
  },
  {
    "objectID": "slides/08-find.html#practical-example",
    "href": "slides/08-find.html#practical-example",
    "title": "Episode 8: Finding Things",
    "section": "Practical Example",
    "text": "Practical Example\nCount all ATOM lines in all PDB files:\n$ grep -c \"^ATOM\" $(find . -name \"*.pdb\")\nOr more safely:\n$ find . -name \"*.pdb\" -exec grep -c \"^ATOM\" {} \\;"
  },
  {
    "objectID": "slides/08-find.html#text-vs-binary-files",
    "href": "slides/08-find.html#text-vs-binary-files",
    "title": "Episode 8: Finding Things",
    "section": "Text vs Binary Files",
    "text": "Text vs Binary Files\nText files: human-readable (.txt, .csv, .py)\nBinary files: encoded (.pdf, .jpg, .exe)\nWhy it matters: grep works on text, not binary!\n$ grep pattern document.pdf\nWon’t work well - PDF is binary."
  },
  {
    "objectID": "slides/08-find.html#grep-on-binary-files",
    "href": "slides/08-find.html#grep-on-binary-files",
    "title": "Episode 8: Finding Things",
    "section": "grep on Binary Files",
    "text": "grep on Binary Files\nBy default, grep warns about binary:\n$ grep text image.jpg\ngrep: image.jpg: binary file matches\nTo search anyway:\n$ grep -a text image.jpg\nBut results are usually gibberish!"
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---question-1",
    "href": "slides/08-find.html#try-it-yourself---question-1",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Question 1",
    "text": "Try It Yourself - Question 1\nSearch haiku.txt for lines containing “it”\n\nJust find them\nCount them\nShow only lines that DON’T contain “it”"
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---solution-1",
    "href": "slides/08-find.html#try-it-yourself---solution-1",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Solution 1",
    "text": "Try It Yourself - Solution 1\nFind lines with “it”:\n$ grep \"it\" haiku.txt\nCount them:\n$ grep -c \"it\" haiku.txt\n3\nLines without “it”:\n$ grep -v \"it\" haiku.txt"
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---question-2",
    "href": "slides/08-find.html#try-it-yourself---question-2",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Question 2",
    "text": "Try It Yourself - Question 2\nFind all files modified in the last 3 days\nWhere should you search? Try your current directory."
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---solution-2",
    "href": "slides/08-find.html#try-it-yourself---solution-2",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Solution 2",
    "text": "Try It Yourself - Solution 2\nFiles modified in last 3 days:\n$ find . -type f -mtime -3\nOr more recently (last 24 hours):\n$ find . -type f -mtime -1"
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---question-3",
    "href": "slides/08-find.html#try-it-yourself---question-3",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Question 3",
    "text": "Try It Yourself - Question 3\nFind all Python files that contain “import”\n(Assume they’re somewhere under current directory)"
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---solution-3",
    "href": "slides/08-find.html#try-it-yourself---solution-3",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Solution 3",
    "text": "Try It Yourself - Solution 3\nUsing find and grep:\n$ find . -name \"*.py\" -exec grep -l \"import\" {} \\;\nOr using command substitution:\n$ grep -l \"import\" $(find . -name \"*.py\")\nWhat -l does: show just the filename, not the matching lines."
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---question-4",
    "href": "slides/08-find.html#try-it-yourself---question-4",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Question 4",
    "text": "Try It Yourself - Question 4\nYou want to find all .log files containing “ERROR”\nAnd show both the filename and the error lines."
  },
  {
    "objectID": "slides/08-find.html#try-it-yourself---solution-4",
    "href": "slides/08-find.html#try-it-yourself---solution-4",
    "title": "Episode 8: Finding Things",
    "section": "Try It Yourself - Solution 4",
    "text": "Try It Yourself - Solution 4\nShow filename and lines with errors:\n$ grep -n \"ERROR\" *.log\nOr to search subdirectories:\n$ find . -name \"*.log\" -exec grep \"ERROR\" {} +\nWhat -n does: shows line numbers."
  },
  {
    "objectID": "slides/08-find.html#advanced--e-for-extended-regex",
    "href": "slides/08-find.html#advanced--e-for-extended-regex",
    "title": "Episode 8: Finding Things",
    "section": "Advanced: -E for Extended Regex",
    "text": "Advanced: -E for Extended Regex\nRegular expressions with -E:\n$ grep -E \"^(A|B|C)\" haiku.txt\nFind lines starting with A, B, or C.\n$ grep -E \"[0-9]{3}\" data.txt\nFind lines with 3 consecutive digits."
  },
  {
    "objectID": "slides/08-find.html#useful-combinations",
    "href": "slides/08-find.html#useful-combinations",
    "title": "Episode 8: Finding Things",
    "section": "Useful Combinations",
    "text": "Useful Combinations\nFind and process files:\n$ find . -name \"*.bak\" -delete\nDelete all .bak files!\n$ find . -name \"*.txt\" -exec wc -l {} +\nCount lines in all text files."
  },
  {
    "objectID": "slides/08-find.html#key-points",
    "href": "slides/08-find.html#key-points",
    "title": "Episode 8: Finding Things",
    "section": "Key Points",
    "text": "Key Points\n\ngrep searches inside files\n\n\nfind searches for files\n\n\ngrep -v shows non-matching lines\n\n\ngrep -c counts matches\n\n\nRegular expressions provide powerful patterns\n\n\n$(command) substitutes command output\n\n\nCombine tools to solve complex problems"
  },
  {
    "objectID": "slides/01-intro.html",
    "href": "slides/01-intro.html",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Questions\n\n\n\n\nWhat is a command shell and why would I use one?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users’ programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces.\n\n\n\n\n\n\n\nImagine: Copy the 3rd line from 1,000 text files across 1,000 folders into one file.\n\nUsing a GUI:\n\nHours of clicking\nHigh chance of error\nRepetitive and tedious\n\n\n\nUsing the Shell:\n\nA few commands\nRepeatable\nFast and accurate (seconds!)\n\n\n\n\n\n\n\n\nA program that reads commands you type\nA command-line interface (CLI) - text-based\nAlso a scripting language for automation\nAllows combining simple programs into powerful workflows\nThe default way to interact with servers and supercomputers\n\n\n\n\n\nBash = Bourne Again SHell\n\n\nMost popular Unix shell\nDefault on macOS, Linux, and Windows (via Git Bash)\nThe standard for shell scripting\nSmall number of “words” (commands) gets you far!\n\n\n\n\n\nWhen you open the shell, you see:\n$\nThe prompt indicates the shell is waiting for input.\n\n\n\n\n\n\nNote\n\n\n\nYour prompt might look different:\nnelle@localhost $\nor even:\nuser@computer:~$\nThis shows your username and computer name.\n\n\n\n\n\n\n\nType a command after the $\nPress Enter to execute\nResults appear below\nNever type the $ - it’s just the prompt!\n\n\n\n\n\n\n\nls is short for listing.\nThis command will list the contents of the current directory:\n\n\nls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can’t find a program whose name is the command you typed, it will print an error message such as:\nks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n\n\n\n\n\n\n\nNelle Nemo, a marine biologist, has:\n\n🌊 Returned from a 6-month North Pacific Gyre survey\n🧫 Collected 1520 samples\n🧬 Measured 300 proteins per sample\n💻 Needs to process all files using goostats.sh\n📝 Must submit her paper by the end of the month\n\n\n\n\n\n\n\nIf Nelle runs goostats.sh manually (GUI):\n\nOpen & process 1520 files\n⏱ 30 seconds per file\n🕒 12+ hours of manual work\n❌ Time lost that could be spent writing her paper\n\n\n\n\n\n\n\nWith a command shell, Nelle can:\n\nAutomate repetitive processing\nUse loops to iterate over files\nRun the pipeline once and reuse it\nLet the computer work while she writes\n\n\n\n\n\n\n\nTo build her pipeline, she must know how to:\n\nNavigate to a file/directory\nCreate a file/directory\nCheck the length of a file\nChain commands together\nRetrieve a set of files\nIterate over files\nRun a shell script containing her pipeline"
  },
  {
    "objectID": "slides/01-intro.html#why-use-the-shell",
    "href": "slides/01-intro.html#why-use-the-shell",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Imagine: Copy the 3rd line from 1,000 text files across 1,000 folders into one file.\n\nUsing a GUI:\n\nHours of clicking\nHigh chance of error\nRepetitive and tedious\n\n\n\nUsing the Shell:\n\nA few commands\nRepeatable\nFast and accurate (seconds!)"
  },
  {
    "objectID": "slides/01-intro.html#what-is-the-shell",
    "href": "slides/01-intro.html#what-is-the-shell",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "A program that reads commands you type\nA command-line interface (CLI) - text-based\nAlso a scripting language for automation\nAllows combining simple programs into powerful workflows\nThe default way to interact with servers and supercomputers"
  },
  {
    "objectID": "slides/01-intro.html#bash-the-shell-were-using",
    "href": "slides/01-intro.html#bash-the-shell-were-using",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Bash = Bourne Again SHell\n\n\nMost popular Unix shell\nDefault on macOS, Linux, and Windows (via Git Bash)\nThe standard for shell scripting\nSmall number of “words” (commands) gets you far!"
  },
  {
    "objectID": "slides/01-intro.html#the-prompt",
    "href": "slides/01-intro.html#the-prompt",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "When you open the shell, you see:\n$\nThe prompt indicates the shell is waiting for input.\n\n\n\n\n\n\nNote\n\n\n\nYour prompt might look different:\nnelle@localhost $\nor even:\nuser@computer:~$\nThis shows your username and computer name."
  },
  {
    "objectID": "slides/01-intro.html#typing-commands",
    "href": "slides/01-intro.html#typing-commands",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Type a command after the $\nPress Enter to execute\nResults appear below\nNever type the $ - it’s just the prompt!"
  },
  {
    "objectID": "slides/01-intro.html#example-your-first-command",
    "href": "slides/01-intro.html#example-your-first-command",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "ls is short for listing.\nThis command will list the contents of the current directory:\n\n\nls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can’t find a program whose name is the command you typed, it will print an error message such as:\nks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed."
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "Nelle Nemo, a marine biologist, has:\n\n🌊 Returned from a 6-month North Pacific Gyre survey\n🧫 Collected 1520 samples\n🧬 Measured 300 proteins per sample\n💻 Needs to process all files using goostats.sh\n📝 Must submit her paper by the end of the month"
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem-1",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem-1",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "If Nelle runs goostats.sh manually (GUI):\n\nOpen & process 1520 files\n⏱ 30 seconds per file\n🕒 12+ hours of manual work\n❌ Time lost that could be spent writing her paper"
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem-2",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem-2",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "With a command shell, Nelle can:\n\nAutomate repetitive processing\nUse loops to iterate over files\nRun the pipeline once and reuse it\nLet the computer work while she writes"
  },
  {
    "objectID": "slides/01-intro.html#nelles-pipeline-a-typical-problem-3",
    "href": "slides/01-intro.html#nelles-pipeline-a-typical-problem-3",
    "title": "Episode 1: Introducing the Shell",
    "section": "",
    "text": "To build her pipeline, she must know how to:\n\nNavigate to a file/directory\nCreate a file/directory\nCheck the length of a file\nChain commands together\nRetrieve a set of files\nIterate over files\nRun a shell script containing her pipeline"
  },
  {
    "objectID": "slides/06-loop.html#why-loops-matter",
    "href": "slides/06-loop.html#why-loops-matter",
    "title": "Episode 6: Loops",
    "section": "Why Loops Matter",
    "text": "Why Loops Matter\nAutomation saves time and prevents errors!\nImagine processing 300 files:\n\nWithout loops: type the command 300 times\nWith loops: write once, runs 300 times\n\nPerfect for repetitive tasks."
  },
  {
    "objectID": "slides/06-loop.html#the-for-loop-structure",
    "href": "slides/06-loop.html#the-for-loop-structure",
    "title": "Episode 6: Loops",
    "section": "The for Loop Structure",
    "text": "The for Loop Structure\nfor thing in list_of_things\ndo\n    operation_using/command $thing\ndone\nThree keywords: - for = start the loop - do = begin the action - done = end the loop"
  },
  {
    "objectID": "slides/06-loop.html#simple-loop-example",
    "href": "slides/06-loop.html#simple-loop-example",
    "title": "Episode 6: Loops",
    "section": "Simple Loop Example",
    "text": "Simple Loop Example\nDisplay three filenames:\n$ for filename in basilisk.dat minotaur.dat unicorn.dat\n&gt; do\n&gt;     echo $filename\n&gt; done\nbasilisk.dat\nminotaur.dat\nunicorn.dat\nNotice the &gt; prompt changes to &gt; while typing the loop."
  },
  {
    "objectID": "slides/06-loop.html#using-variables-in-loops",
    "href": "slides/06-loop.html#using-variables-in-loops",
    "title": "Episode 6: Loops",
    "section": "Using Variables in Loops",
    "text": "Using Variables in Loops\nThe variable holds each value in turn:\n\nFirst iteration: $filename = basilisk.dat\nSecond iteration: $filename = minotaur.dat\nThird iteration: $filename = unicorn.dat"
  },
  {
    "objectID": "slides/06-loop.html#real-practical-loop",
    "href": "slides/06-loop.html#real-practical-loop",
    "title": "Episode 6: Loops",
    "section": "Real Practical Loop",
    "text": "Real Practical Loop\nGet the classification from creature files:\n$ for filename in basilisk.dat minotaur.dat unicorn.dat\n&gt; do\n&gt;     echo $filename\n&gt;     head -n 2 $filename | tail -n 1\n&gt; done\nbasilisk.dat\nCLASSIFICATION: basiliscus vulgaris\nminotaur.dat\nCLASSIFICATION: bos hominus\nunicorn.dat\nCLASSIFICATION: equus monoceros"
  },
  {
    "objectID": "slides/06-loop.html#expanding-wildcards-in-loops",
    "href": "slides/06-loop.html#expanding-wildcards-in-loops",
    "title": "Episode 6: Loops",
    "section": "Expanding Wildcards in Loops",
    "text": "Expanding Wildcards in Loops\nInstead of listing every file:\n$ for filename in *.dat\n&gt; do\n&gt;     echo $filename\n&gt; done\nThe shell expands *.dat to all matching files!"
  },
  {
    "objectID": "slides/06-loop.html#variable-syntax",
    "href": "slides/06-loop.html#variable-syntax",
    "title": "Episode 6: Loops",
    "section": "Variable Syntax",
    "text": "Variable Syntax\nTwo ways to use variables:\n$ echo $filename      # Simple\n$ echo ${filename}    # With braces\nThe braces are useful when the variable is next to text:\n$ echo ${filename}.bak\nWithout braces, $filename.bak looks for variable filename.bak!"
  },
  {
    "objectID": "slides/06-loop.html#good-vs-bad-filenames",
    "href": "slides/06-loop.html#good-vs-bad-filenames",
    "title": "Episode 6: Loops",
    "section": "Good vs Bad Filenames",
    "text": "Good vs Bad Filenames\nFiles that work fine:\n\ndata_2024.txt\nresults-v1.csv\nfile1.dat\n\nFiles that break loops:\n\nmy file.txt (space breaks it!)\ndata (2024).csv (parentheses)\nfile@#.txt (special characters)"
  },
  {
    "objectID": "slides/06-loop.html#why-spaces-break-things",
    "href": "slides/06-loop.html#why-spaces-break-things",
    "title": "Episode 6: Loops",
    "section": "Why Spaces Break Things",
    "text": "Why Spaces Break Things\nShell interprets spaces as separators!\n$ for filename in my file.txt\n&gt; do ...\nThe shell sees THREE items: my, file.txt!\nBest practice: use - or _ instead of spaces."
  },
  {
    "objectID": "slides/06-loop.html#quoting-variables",
    "href": "slides/06-loop.html#quoting-variables",
    "title": "Episode 6: Loops",
    "section": "Quoting Variables",
    "text": "Quoting Variables\nTo safely handle filenames with spaces:\n$ for filename in \"my file.txt\" \"another file.txt\"\n&gt; do\n&gt;     echo \"$filename\"\n&gt; done\nAlways quote variables to be safe!"
  },
  {
    "objectID": "slides/06-loop.html#command-history",
    "href": "slides/06-loop.html#command-history",
    "title": "Episode 6: Loops",
    "section": "Command History",
    "text": "Command History\nRe-run previous commands:\nPress Up arrow to see last command.\nPress Up arrow multiple times to go back further.\nPress Down arrow to go forward."
  },
  {
    "objectID": "slides/06-loop.html#history-shortcuts",
    "href": "slides/06-loop.html#history-shortcuts",
    "title": "Episode 6: Loops",
    "section": "History Shortcuts",
    "text": "History Shortcuts\n\n\n\nShortcut\nWhat it does\n\n\n\n\n↑ / ↓\nPrevious/next command\n\n\nCtrl-R\nSearch command history\n\n\nhistory\nShow all previous commands\n\n\n!number\nRun command #123 from history"
  },
  {
    "objectID": "slides/06-loop.html#search-history-with-ctrl-r",
    "href": "slides/06-loop.html#search-history-with-ctrl-r",
    "title": "Episode 6: Loops",
    "section": "Search History with Ctrl-R",
    "text": "Search History with Ctrl-R\nPress Ctrl-R:\n(reverse-i-search)`':\nType part of a command:\n(reverse-i-search)`for': for filename in *.dat\nPress Enter to run it!"
  },
  {
    "objectID": "slides/06-loop.html#executing-commands-from-history",
    "href": "slides/06-loop.html#executing-commands-from-history",
    "title": "Episode 6: Loops",
    "section": "Executing Commands from History",
    "text": "Executing Commands from History\nView history:\n$ history\nShows numbered list of commands.\nRun command #42:\n$ !42"
  },
  {
    "objectID": "slides/06-loop.html#loop-execution-trace",
    "href": "slides/06-loop.html#loop-execution-trace",
    "title": "Episode 6: Loops",
    "section": "Loop Execution Trace",
    "text": "Loop Execution Trace\nUnderstanding what happens step-by-step:\nfor file in a.txt b.txt c.txt\ndo\n    echo $file\ndone\n\n\n\nIteration\nValue of $file\nOutput\n\n\n\n\n1\na.txt\na.txt\n\n\n2\nb.txt\nb.txt\n\n\n3\nc.txt\nc.txt"
  },
  {
    "objectID": "slides/06-loop.html#nested-information-in-loops",
    "href": "slides/06-loop.html#nested-information-in-loops",
    "title": "Episode 6: Loops",
    "section": "Nested Information in Loops",
    "text": "Nested Information in Loops\nUse multiple variables:\n$ for file in *.pdb\n&gt; do\n&gt;     echo \"Processing $file\"\n&gt;     wc -l \"$file\"\n&gt; done\nProcessing cubane.pdb\n  20 cubane.pdb\nProcessing ethane.pdb\n  12 ethane.pdb\n..."
  },
  {
    "objectID": "slides/06-loop.html#one-liner-loop",
    "href": "slides/06-loop.html#one-liner-loop",
    "title": "Episode 6: Loops",
    "section": "One-liner Loop",
    "text": "One-liner Loop\nPut loop on one line using semicolon:\n$ for file in *.dat; do echo $file; done\nSame as:\nfor file in *.dat\ndo\n    echo $file\ndone"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---question-1",
    "href": "slides/06-loop.html#try-it-yourself---question-1",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Question 1",
    "text": "Try It Yourself - Question 1\nTrace execution of this loop:\nfor num in 1 2 3\ndo\n    echo \"Number is $num\"\ndone\nWhat will be printed?"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---solution-1",
    "href": "slides/06-loop.html#try-it-yourself---solution-1",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Solution 1",
    "text": "Try It Yourself - Solution 1\nOutput:\nNumber is 1\nNumber is 2\nNumber is 3\nThe loop runs 3 times: - First: $num = 1 - Second: $num = 2 - Third: $num = 3"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---question-2",
    "href": "slides/06-loop.html#try-it-yourself---question-2",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Question 2",
    "text": "Try It Yourself - Question 2\nWrite a loop that:\n\nProcesses all .txt files\nPrints the filename\nCounts lines in each"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---solution-2",
    "href": "slides/06-loop.html#try-it-yourself---solution-2",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Solution 2",
    "text": "Try It Yourself - Solution 2\nSolution:\n$ for file in *.txt\n&gt; do\n&gt;     echo \"File: $file\"\n&gt;     wc -l \"$file\"\n&gt; done\nWhy the quotes? To handle filenames with spaces safely!"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---question-3",
    "href": "slides/06-loop.html#try-it-yourself---question-3",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Question 3",
    "text": "Try It Yourself - Question 3\nYou have 100 data files: data_1.csv to data_100.csv\nWrite a command to process all of them.\n(Hint: use wildcards!)"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---solution-3",
    "href": "slides/06-loop.html#try-it-yourself---solution-3",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Solution 3",
    "text": "Try It Yourself - Solution 3\nSimple with wildcards:\n$ for file in data_*.csv\n&gt; do\n&gt;     # Your commands here\n&gt;     echo \"Processing $file\"\n&gt; done\nThe shell expands data_*.csv to all matching files!"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---question-4",
    "href": "slides/06-loop.html#try-it-yourself---question-4",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Question 4",
    "text": "Try It Yourself - Question 4\nUse the up arrow or history to:\n\nFind a for loop you ran before\nModify it slightly\nRun the new version\n\n(This is how professionals work!)"
  },
  {
    "objectID": "slides/06-loop.html#try-it-yourself---solution-4",
    "href": "slides/06-loop.html#try-it-yourself---solution-4",
    "title": "Episode 6: Loops",
    "section": "Try It Yourself - Solution 4",
    "text": "Try It Yourself - Solution 4\nSteps:\n\nPress Ctrl-R to search\nType part of the loop: for file\nPress Enter to bring it back\nEdit it as needed\nPress Enter to run\n\nMuch faster than retyping!"
  },
  {
    "objectID": "slides/06-loop.html#important-tips-for-loops",
    "href": "slides/06-loop.html#important-tips-for-loops",
    "title": "Episode 6: Loops",
    "section": "Important Tips for Loops",
    "text": "Important Tips for Loops\n\n\nQuote your variables: \"$filename\"\nUse sensible names: filename not x\nTest on a few files first, not all 300\nSave loop commands in scripts for reuse\nComments help: # This processes all .txt files"
  },
  {
    "objectID": "slides/06-loop.html#key-points",
    "href": "slides/06-loop.html#key-points",
    "title": "Episode 6: Loops",
    "section": "Key Points",
    "text": "Key Points\n\nfor loops repeat commands on lists\n\n\nLoop variable holds each value in turn\n\n\nUse $ to access variable value\n\n\nWildcards expand to multiple files\n\n\nQuote variables to handle spaces safely\n\n\nUse history to reuse and modify commands\n\n\nLoops enable powerful automation"
  },
  {
    "objectID": "slides/07-script.html#what-is-a-shell-script",
    "href": "slides/07-script.html#what-is-a-shell-script",
    "title": "Episode 7: Shell Scripts",
    "section": "What is a Shell Script?",
    "text": "What is a Shell Script?\nA file containing shell commands\n\nRun the same commands repeatedly\nNo need to retype\nMore reliable (fewer typos)\nCan be shared with others\nEssential for automation"
  },
  {
    "objectID": "slides/07-script.html#creating-your-first-script",
    "href": "slides/07-script.html#creating-your-first-script",
    "title": "Episode 7: Shell Scripts",
    "section": "Creating Your First Script",
    "text": "Creating Your First Script\nCreate a file called middle.sh:\n$ nano middle.sh\nIn the editor, type:\nhead -n 15 octane.pdb | tail -n 5\nSave (Ctrl-O, Enter, Ctrl-X)."
  },
  {
    "objectID": "slides/07-script.html#running-your-script",
    "href": "slides/07-script.html#running-your-script",
    "title": "Episode 7: Shell Scripts",
    "section": "Running Your Script",
    "text": "Running Your Script\nExecute the script:\n$ bash middle.sh\nATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\nATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\nATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\nATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\nATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\nOutput is exactly what we’d get from running manually!"
  },
  {
    "objectID": "slides/07-script.html#problem-not-reusable",
    "href": "slides/07-script.html#problem-not-reusable",
    "title": "Episode 7: Shell Scripts",
    "section": "Problem: Not Reusable",
    "text": "Problem: Not Reusable\nOur script only works on octane.pdb.\nWhat if we want to use it on other files?\nSolution: Use command-line arguments!"
  },
  {
    "objectID": "slides/07-script.html#making-scripts-flexible",
    "href": "slides/07-script.html#making-scripts-flexible",
    "title": "Episode 7: Shell Scripts",
    "section": "Making Scripts Flexible",
    "text": "Making Scripts Flexible\nEdit middle.sh:\nhead -n 15 \"$1\" | tail -n 5\n\n$1 = first argument provided by user"
  },
  {
    "objectID": "slides/07-script.html#using-arguments",
    "href": "slides/07-script.html#using-arguments",
    "title": "Episode 7: Shell Scripts",
    "section": "Using Arguments",
    "text": "Using Arguments\nNow run with different files:\n$ bash middle.sh octane.pdb\n$ bash middle.sh ethane.pdb\n$ bash middle.sh methane.pdb\nEach uses the argument you provide!"
  },
  {
    "objectID": "slides/07-script.html#argument-variables",
    "href": "slides/07-script.html#argument-variables",
    "title": "Episode 7: Shell Scripts",
    "section": "Argument Variables",
    "text": "Argument Variables\n\n\n\nVariable\nMeaning\n\n\n\n\n$1\nFirst argument\n\n\n$2\nSecond argument\n\n\n$3\nThird argument\n\n\n$@\nAll arguments\n\n\n$#\nNumber of arguments"
  },
  {
    "objectID": "slides/07-script.html#multiple-arguments-example",
    "href": "slides/07-script.html#multiple-arguments-example",
    "title": "Episode 7: Shell Scripts",
    "section": "Multiple Arguments Example",
    "text": "Multiple Arguments Example\nScript: combine.sh\ncat \"$1\" \"$2\" &gt; \"$3\"\nUsage:\n$ bash combine.sh file1.txt file2.txt combined.txt\nThis combines two files into a third!"
  },
  {
    "objectID": "slides/07-script.html#all-arguments",
    "href": "slides/07-script.html#all-arguments",
    "title": "Episode 7: Shell Scripts",
    "section": "All Arguments: $@",
    "text": "All Arguments: $@\nScript: process-all.sh\nfor file in \"$@\"\ndo\n    echo \"Processing $file\"\n    wc -l \"$file\"\ndone\nUsage:\n$ bash process-all.sh *.pdb\nProcesses all files passed in!"
  },
  {
    "objectID": "slides/07-script.html#quoting-arguments",
    "href": "slides/07-script.html#quoting-arguments",
    "title": "Episode 7: Shell Scripts",
    "section": "Quoting Arguments",
    "text": "Quoting Arguments\nAlways quote your variables!\nSafe:\nhead -n 15 \"$1\" | tail -n 5\nUnsafe (breaks with spaces in filenames):\nhead -n 15 $1 | tail -n 5"
  },
  {
    "objectID": "slides/07-script.html#comments-in-scripts",
    "href": "slides/07-script.html#comments-in-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "Comments in Scripts",
    "text": "Comments in Scripts\nAdd comments with #:\n#!/bin/bash\n# This script extracts the middle 5 lines\n# of a PDB file (lines 11-15)\n# Usage: bash middle.sh filename\n\nhead -n 15 \"$1\" | tail -n 5\nComments document your script for future use."
  },
  {
    "objectID": "slides/07-script.html#the-shebang-line",
    "href": "slides/07-script.html#the-shebang-line",
    "title": "Episode 7: Shell Scripts",
    "section": "The Shebang Line",
    "text": "The Shebang Line\nFirst line of many scripts:\n#!/bin/bash\nThis tells the system: Use bash to run this script\nAllows you to run:\n$ ./middle.sh octane.pdb\nInstead of:\n$ bash middle.sh octane.pdb"
  },
  {
    "objectID": "slides/07-script.html#making-scripts-executable",
    "href": "slides/07-script.html#making-scripts-executable",
    "title": "Episode 7: Shell Scripts",
    "section": "Making Scripts Executable",
    "text": "Making Scripts Executable\nTo use ./script.sh directly:\n$ chmod u+x middle.sh\n$ ./middle.sh octane.pdb\nNow the script is executable by you!"
  },
  {
    "objectID": "slides/07-script.html#practical-example-batch-processing",
    "href": "slides/07-script.html#practical-example-batch-processing",
    "title": "Episode 7: Shell Scripts",
    "section": "Practical Example: Batch Processing",
    "text": "Practical Example: Batch Processing\nScript: count-atoms.sh\n#!/bin/bash\n# Count ATOM lines in PDB files\n\nfor file in \"$@\"\ndo\n    count=$(grep -c \"^ATOM\" \"$file\")\n    echo \"$file: $count atoms\"\ndone\nUsage:\n$ bash count-atoms.sh *.pdb\ncubane.pdb: 10 atoms\nethane.pdb: 8 atoms\n..."
  },
  {
    "objectID": "slides/07-script.html#variable-assignment",
    "href": "slides/07-script.html#variable-assignment",
    "title": "Episode 7: Shell Scripts",
    "section": "Variable Assignment",
    "text": "Variable Assignment\nCreate variables with = (no spaces!):\ncount=$(grep -c \"^ATOM\" \"$file\")\nUse command output as a variable!\nfilename=$(basename \"$1\")\ndirectory=$(dirname \"$1\")"
  },
  {
    "objectID": "slides/07-script.html#common-pitfalls",
    "href": "slides/07-script.html#common-pitfalls",
    "title": "Episode 7: Shell Scripts",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n❌ Space around =:\ncount = 5  # WRONG!\n✅ No spaces:\ncount=5    # Correct\n❌ Missing quotes:\nhead \"$1\"  # What if $1 has spaces?\n✅ Always quote:\nhead \"$1\"  # Safe!"
  },
  {
    "objectID": "slides/07-script.html#script-debugging",
    "href": "slides/07-script.html#script-debugging",
    "title": "Episode 7: Shell Scripts",
    "section": "Script Debugging",
    "text": "Script Debugging\nPrint what’s happening:\n#!/bin/bash\necho \"Processing $1\"\nhead -n 15 \"$1\" | tail -n 5\necho \"Done!\""
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---question-1",
    "href": "slides/07-script.html#try-it-yourself---question-1",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Question 1",
    "text": "Try It Yourself - Question 1\nWrite a script called show-lines.sh that:\n\nTakes a filename as argument\nShows the number of lines\nDisplays the first 5 lines\n\nHint: Use wc -l and head"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---solution-1",
    "href": "slides/07-script.html#try-it-yourself---solution-1",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Solution 1",
    "text": "Try It Yourself - Solution 1\nScript: show-lines.sh\n#!/bin/bash\n# Show file info\n\nwc -l \"$1\"\nhead -n 5 \"$1\"\nUsage:\n$ bash show-lines.sh myfile.txt"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---question-2",
    "href": "slides/07-script.html#try-it-yourself---question-2",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Question 2",
    "text": "Try It Yourself - Question 2\nWrite a script process-data.sh that:\n\nTakes multiple data files as arguments\nFor each file, shows the filename\nCounts lines in that file"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---solution-2",
    "href": "slides/07-script.html#try-it-yourself---solution-2",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Solution 2",
    "text": "Try It Yourself - Solution 2\nScript: process-data.sh\n#!/bin/bash\n# Process multiple files\n\nfor file in \"$@\"\ndo\n    echo \"File: $file\"\n    wc -l \"$file\"\ndone\nUsage:\n$ bash process-data.sh data1.txt data2.txt data3.txt"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---question-3",
    "href": "slides/07-script.html#try-it-yourself---question-3",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Question 3",
    "text": "Try It Yourself - Question 3\nYou have a script:\n#!/bin/bash\nhead -n 10 \"$1\" | tail -n 5\nWhat’s wrong with this approach for production use?"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---solution-3",
    "href": "slides/07-script.html#try-it-yourself---solution-3",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Solution 3",
    "text": "Try It Yourself - Solution 3\nIssues:\n\n❌ No comments - what does it do?\n❌ No error checking - what if file doesn’t exist?\n❌ Not flexible - hardcoded to lines 10 and 5\n\nBetter version:\n#!/bin/bash\n# Extract lines N to M from a file\n# Usage: bash extract.sh N M filename\n\nstart=$1\nend=$2\nfile=$3\n\nhead -n \"$end\" \"$file\" | tail -n $(($end - $start + 1))"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---question-4",
    "href": "slides/07-script.html#try-it-yourself---question-4",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Question 4",
    "text": "Try It Yourself - Question 4\nYou want to use arithmetic in a script.\nHow do you calculate 5 + 3?"
  },
  {
    "objectID": "slides/07-script.html#try-it-yourself---solution-4",
    "href": "slides/07-script.html#try-it-yourself---solution-4",
    "title": "Episode 7: Shell Scripts",
    "section": "Try It Yourself - Solution 4",
    "text": "Try It Yourself - Solution 4\nUsing $(( )):\nresult=$((5 + 3))\necho $result  # Prints 8\nIn a script:\n#!/bin/bash\nstart=$1\nend=$2\nmiddle=$(( ($start + $end) / 2 ))\necho \"Middle is $middle\""
  },
  {
    "objectID": "slides/07-script.html#best-practices-for-scripts",
    "href": "slides/07-script.html#best-practices-for-scripts",
    "title": "Episode 7: Shell Scripts",
    "section": "Best Practices for Scripts",
    "text": "Best Practices for Scripts\n\n\nUse comments to explain what the script does\nQuote variables always: \"$1\"\nUse meaningful names: filename not x\nCheck errors: Does the file exist?\nTest thoroughly before using on real data\nDocument usage with examples\nVersion control your scripts (git!)"
  },
  {
    "objectID": "slides/07-script.html#key-points",
    "href": "slides/07-script.html#key-points",
    "title": "Episode 7: Shell Scripts",
    "section": "Key Points",
    "text": "Key Points\n\nScripts save and reuse commands\n\n\n$1, $2, etc. are command-line arguments\n\n\n$@ means all arguments\n\n\nAlways quote variables: \"$var\"\n\n\nComments document your work\n\n\nchmod u+x makes scripts executable\n\n\nScripts are essential for automation"
  },
  {
    "objectID": "slides/09-awk.html#what-is-awk",
    "href": "slides/09-awk.html#what-is-awk",
    "title": "Episode 9: AWK for Text Processing",
    "section": "What is AWK?",
    "text": "What is AWK?\nAWK = Text processing program\n\nReads files line by line\nSplits each line into fields\nApplies pattern-action rules\nPerforms calculations and aggregations\n\nPerfect for CSV and tabular data!"
  },
  {
    "objectID": "slides/09-awk.html#sample-data",
    "href": "slides/09-awk.html#sample-data",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Sample Data",
    "text": "Sample Data\nA simple data file:\nchr1  100  200  feature1\nchr2  150  300  feature2\nchr3  200  400  feature3\nColumns separated by spaces."
  },
  {
    "objectID": "slides/09-awk.html#basic-awk-pattern",
    "href": "slides/09-awk.html#basic-awk-pattern",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Basic AWK Pattern",
    "text": "Basic AWK Pattern\nawk '{action}' file.txt\nThe {action} applies to every line."
  },
  {
    "objectID": "slides/09-awk.html#simplest-action-print-everything",
    "href": "slides/09-awk.html#simplest-action-print-everything",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Simplest Action: Print Everything",
    "text": "Simplest Action: Print Everything\n$ awk '{print $0}' data.txt\n$0 = the entire line\nSame as cat data.txt!"
  },
  {
    "objectID": "slides/09-awk.html#field-variables-1-2-etc.",
    "href": "slides/09-awk.html#field-variables-1-2-etc.",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Field Variables: $1, $2, etc.",
    "text": "Field Variables: $1, $2, etc.\nEach column is a field:\n\n$1 = first column\n$2 = second column\n$3 = third column\n$NF = last column"
  },
  {
    "objectID": "slides/09-awk.html#print-specific-columns",
    "href": "slides/09-awk.html#print-specific-columns",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Print Specific Columns",
    "text": "Print Specific Columns\nShow first and third columns:\n$ awk '{print $1, $3}' data.txt\nchr1 200\nchr2 300\nchr3 400\nCommas add spaces between columns!"
  },
  {
    "objectID": "slides/09-awk.html#print-with-custom-text",
    "href": "slides/09-awk.html#print-with-custom-text",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Print with Custom Text",
    "text": "Print with Custom Text\n$ awk '{print \"chr\",$2,$4}' data.txt\nchr 100 feature1\nchr 150 feature2\nchr 200 feature3\nStrings go in quotes."
  },
  {
    "objectID": "slides/09-awk.html#the-nf-variable",
    "href": "slides/09-awk.html#the-nf-variable",
    "title": "Episode 9: AWK for Text Processing",
    "section": "The NF Variable",
    "text": "The NF Variable\nNF = Number of Fields\n$ awk '{print NF}' data.txt\n4\n4\n4\nEach line has 4 fields."
  },
  {
    "objectID": "slides/09-awk.html#last-field-nf",
    "href": "slides/09-awk.html#last-field-nf",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Last Field: $NF",
    "text": "Last Field: $NF\nPrint the last field of each line:\n$ awk '{print $NF}' data.txt\nfeature1\nfeature2\nfeature3\nWorks even if lines have different numbers of fields!"
  },
  {
    "objectID": "slides/09-awk.html#handling-different-field-separators",
    "href": "slides/09-awk.html#handling-different-field-separators",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Handling Different Field Separators",
    "text": "Handling Different Field Separators\nBy default, AWK splits on spaces and tabs.\nFor comma-separated (CSV) files:\n$ awk -F \",\" '{print $2}' data.csv\nThe -F flag sets the field separator!"
  },
  {
    "objectID": "slides/09-awk.html#field-separator-examples",
    "href": "slides/09-awk.html#field-separator-examples",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Field Separator Examples",
    "text": "Field Separator Examples\n\n\n\nCommand\nPurpose\n\n\n\n\nawk -F \":\" '{print $1}'\nColon separator\n\n\nawk -F \"\\t\" '{print $2}'\nTab separator\n\n\nawk -F \",\" '{print $3}'\nComma separator\n\n\nawk '{print $2}'\nDefault (space/tab)"
  },
  {
    "objectID": "slides/09-awk.html#pattern-action-model",
    "href": "slides/09-awk.html#pattern-action-model",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Pattern-Action Model",
    "text": "Pattern-Action Model\nApply action only to matching lines:\nawk '/PATTERN/ {action}' file\n\nPattern: lines to match (regex)\nAction: what to do with matching lines"
  },
  {
    "objectID": "slides/09-awk.html#pattern-example-start-of-line",
    "href": "slides/09-awk.html#pattern-example-start-of-line",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Pattern Example: Start of Line",
    "text": "Pattern Example: Start of Line\nFind lines starting with “ATOM”:\n$ awk '/^ATOM/ {print}' protein.pdb\nShows only lines beginning with “ATOM”."
  },
  {
    "objectID": "slides/09-awk.html#pattern-example-specific-column",
    "href": "slides/09-awk.html#pattern-example-specific-column",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Pattern Example: Specific Column",
    "text": "Pattern Example: Specific Column\nProcess lines where column 2 &gt; 100:\n$ awk '$2 &gt; 100 {print $0}' data.txt\nchr1  150  300  feature2\nchr3  200  400  feature3"
  },
  {
    "objectID": "slides/09-awk.html#multiple-patterns",
    "href": "slides/09-awk.html#multiple-patterns",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Multiple Patterns",
    "text": "Multiple Patterns\nApply different actions to different patterns:\nawk '/^ATOM/ {count++} /^HETATM/ {other++} \\\n    END {print count, other}' protein.pdb"
  },
  {
    "objectID": "slides/09-awk.html#the-end-block",
    "href": "slides/09-awk.html#the-end-block",
    "title": "Episode 9: AWK for Text Processing",
    "section": "The END Block",
    "text": "The END Block\nRun after all lines are processed\nPerfect for printing totals:\n$ awk '{sum += $2} END {print sum}' data.txt\nSums all values in column 2."
  },
  {
    "objectID": "slides/09-awk.html#the-nr-variable",
    "href": "slides/09-awk.html#the-nr-variable",
    "title": "Episode 9: AWK for Text Processing",
    "section": "The NR Variable",
    "text": "The NR Variable\nNR = Number of Records (lines)\nTotal lines in a file:\n$ awk 'END {print NR}' data.txt\n3\nMore reliable than wc -l!"
  },
  {
    "objectID": "slides/09-awk.html#counting-lines-robustly",
    "href": "slides/09-awk.html#counting-lines-robustly",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Counting Lines Robustly",
    "text": "Counting Lines Robustly\nCompare approaches:\n$ wc -l file.txt        # May undercount if no final newline\n$ awk 'END {print NR}' file.txt  # Always accurate"
  },
  {
    "objectID": "slides/09-awk.html#conditional-counting",
    "href": "slides/09-awk.html#conditional-counting",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Conditional Counting",
    "text": "Conditional Counting\nCount matching lines:\n$ awk '/^ATOM/ {count++} END {print count}' protein.pdb\nIncrement counter only for matching lines."
  },
  {
    "objectID": "slides/09-awk.html#safe-counter-initialization",
    "href": "slides/09-awk.html#safe-counter-initialization",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Safe Counter Initialization",
    "text": "Safe Counter Initialization\nAvoid undefined variable errors:\n$ awk '/^ATOM/ {c++} END {print c+0}' protein.pdb\nAdding +0 safely prints 0 if no matches."
  },
  {
    "objectID": "slides/09-awk.html#field-extraction-example",
    "href": "slides/09-awk.html#field-extraction-example",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Field Extraction Example",
    "text": "Field Extraction Example\nExtract coordinates from PDB:\n$ awk '/^ATOM/ {print $7,$8,$9}' protein.pdb\nShows x, y, z coordinates of each atom."
  },
  {
    "objectID": "slides/09-awk.html#arithmetic-in-awk",
    "href": "slides/09-awk.html#arithmetic-in-awk",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Arithmetic in AWK",
    "text": "Arithmetic in AWK\n$ awk '{sum += $1} END {print sum}' numbers.txt\nCalculate average:\n$ awk '{sum += $1; count++} \\\n       END {print sum/count}' numbers.txt"
  },
  {
    "objectID": "slides/09-awk.html#string-operations",
    "href": "slides/09-awk.html#string-operations",
    "title": "Episode 9: AWK for Text Processing",
    "section": "String Operations",
    "text": "String Operations\nLength of a field:\n$ awk '{print length($1)}' data.txt\nConcatenation:\n$ awk '{print $1 \"_\" $2}' data.txt"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---question-1",
    "href": "slides/09-awk.html#try-it-yourself---question-1",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Question 1",
    "text": "Try It Yourself - Question 1\nGiven a file with 3 columns of numbers:\n10 20 30\n5  15 25\nWrite an AWK command to print: 1. Just the second column 2. Just the last column 3. All three columns"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---solution-1",
    "href": "slides/09-awk.html#try-it-yourself---solution-1",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Solution 1",
    "text": "Try It Yourself - Solution 1\nSecond column only:\n$ awk '{print $2}' file.txt\n20\n15\nLast column:\n$ awk '{print $NF}' file.txt\nAll three:\n$ awk '{print $1, $2, $3}' file.txt"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---question-2",
    "href": "slides/09-awk.html#try-it-yourself---question-2",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Question 2",
    "text": "Try It Yourself - Question 2\nCount total number of lines in a file\n(Use AWK to be sure about the count)"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---solution-2",
    "href": "slides/09-awk.html#try-it-yourself---solution-2",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Solution 2",
    "text": "Try It Yourself - Solution 2\nRobust line counting:\n$ awk 'END {print NR}' file.txt\nThis is more reliable than wc -l!"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---question-3",
    "href": "slides/09-awk.html#try-it-yourself---question-3",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Question 3",
    "text": "Try It Yourself - Question 3\nYou have a CSV file with salary data:\nname,salary\nAlice,50000\nBob,60000\nCharlie,55000\nCalculate the total salary."
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---solution-3",
    "href": "slides/09-awk.html#try-it-yourself---solution-3",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Solution 3",
    "text": "Try It Yourself - Solution 3\nUsing AWK with CSV:\n$ awk -F \",\" 'NR &gt; 1 {sum += $2} \\\n              END {print sum}' salaries.csv\nBreaking it down: - -F \",\" = comma separator - NR &gt; 1 = skip header line - sum += $2 = add salary column - END = print total"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---question-4",
    "href": "slides/09-awk.html#try-it-yourself---question-4",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Question 4",
    "text": "Try It Yourself - Question 4\nFind lines where column 1 equals “chr1”\nHint: Use pattern matching"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---solution-4",
    "href": "slides/09-awk.html#try-it-yourself---solution-4",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Solution 4",
    "text": "Try It Yourself - Solution 4\nMatching first column:\n$ awk '$1 == \"chr1\" {print}' data.txt\nOr shorter:\n$ awk '$1 == \"chr1\"' data.txt\n(Default action is print)"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---question-5",
    "href": "slides/09-awk.html#try-it-yourself---question-5",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Question 5",
    "text": "Try It Yourself - Question 5\nCount atoms in a PDB file\n(Only count lines starting with “ATOM”)"
  },
  {
    "objectID": "slides/09-awk.html#try-it-yourself---solution-5",
    "href": "slides/09-awk.html#try-it-yourself---solution-5",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Try It Yourself - Solution 5",
    "text": "Try It Yourself - Solution 5\nCount ATOM records:\n$ awk '/^ATOM/ {count++} END {print count+0}' protein.pdb\nOr use grep:\n$ grep -c \"^ATOM\" protein.pdb\nBoth work!"
  },
  {
    "objectID": "slides/09-awk.html#advanced-variables-in-awk",
    "href": "slides/09-awk.html#advanced-variables-in-awk",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Advanced: Variables in AWK",
    "text": "Advanced: Variables in AWK\nDefine your own variables:\n$ awk 'BEGIN {total=0} {total += $1} \\\n       END {print total}' data.txt\n\nBEGIN runs before processing\n{total += $1} in main loop\nEND prints result"
  },
  {
    "objectID": "slides/09-awk.html#awk-programs-from-files",
    "href": "slides/09-awk.html#awk-programs-from-files",
    "title": "Episode 9: AWK for Text Processing",
    "section": "AWK Programs from Files",
    "text": "AWK Programs from Files\nFor complex AWK scripts, use a file:\nCreate count-atoms.awk:\n/^ATOM/ {\n    count++\n    x += $7\n    y += $8\n    z += $9\n}\n\nEND {\n    print \"Atoms:\", count\n    print \"Avg X:\", x/count\n    print \"Avg Y:\", y/count\n    print \"Avg Z:\", z/count\n}\nRun it:\n$ awk -f count-atoms.awk protein.pdb"
  },
  {
    "objectID": "slides/09-awk.html#key-points",
    "href": "slides/09-awk.html#key-points",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Key Points",
    "text": "Key Points\n\n$1, $2 access columns\n\n\n$NF is the last column\n\n\n$0 is the entire line\n\n\n-F sets field separator\n\n\nPatterns select matching lines\n\n\nEND block runs after all lines\n\n\nNR counts total lines\n\n\nUse count++ for aggregation"
  },
  {
    "objectID": "slides/09-awk.html#thank-you",
    "href": "slides/09-awk.html#thank-you",
    "title": "Episode 9: AWK for Text Processing",
    "section": "Thank You!",
    "text": "Thank You!\nYou’ve completed the Unix Shell Workshop!\nYou now know how to:\n✓ Navigate the file system\n✓ Manage files and directories\n✓ Combine commands with pipes\n✓ Automate with loops and scripts\n✓ Find files and search text\n✓ Process data with AWK\nNext steps:\n\nPractice on your own data\nRead man pages for more options\nBuild useful scripts for your work\nShare what you learn!"
  }
]