
# Episode 9: AWK for Text Processing

::: {.callout-tip icon="false" .nonincremental}
## Questions

- How do I print specific columns from a text table?
- How can I use patterns to select only certain lines in a file?
- How do I count lines or matched lines in a file?
:::

::: {.callout-tip icon="false" .nonincremental}
## Objectives

- Select and print fields with `$0`, `$1`, `$2`, `$NF`, and `NF`
- Use field separator (`-F`) to handle CSV input
- Match lines using regex like `/^ATOM/`
- Count lines with counter and `END` block
- Explain difference between `wc -l` and `awk 'END {print NR}'`
:::

## Counting Lines: The Problem

**Using `wc -l`:**

```bash
wc -l example.txt
```

**The issue**: `wc` counts newlines only.

If last line has **no carriage return**, result is **off by one**.

## `awk`: A Better Solution

**AWK** = command-line program for text processing.

- Takes instructions and one or more files
- Executes on each line
- Instructions in single quotes or from file

## Basic `awk` Syntax

```bash
awk '{print $0}' example.txt
```

Same output as `cat example.txt`.

Structure:
- `{}` surrounds instructions
- `print` sends output to terminal
- `$0` = **entire current line** (variable)

## How `awk` Works

AWK **automatically splits** each line by spaces.

Columns stored in variables:
- `$1` = first column
- `$2` = second column
- `$3` = third column
- And so on...

## Printing Entire Line

```bash
awk '{print $0}' example.txt
```

`$0` means "the whole line".

Same as `cat` but using AWK!

## Printing Specific Columns

Print only second column:

```bash
awk '{print $2}' example.txt
```

Print multiple columns (second and fourth):

```bash
awk '{print $2, $4}' example.txt
```

**Commas add spaces** between output values.

## Adding Text to Output

Print with custom text:

```bash
awk '{print "chr", $2, $4}' example.txt
```

```output
chr value2 value4
chr value2 value4
chr value2 value4
```

**Text must be in quotes**.

## The NF Variable

**NF** = Number of Fields (columns)

```bash
awk '{print NF}' example.txt
```

Shows how many columns in each row.

Useful when files have **variable column counts**.

## Example: Lines with Different Columns

Some lines have 6 fields, others have 7:

```bash
awk '{print "This line has", NF, "columns. The last one contains", $NF}' example.txt
```

`NF` gives column count for **current line**.

## The Last Column: `$NF`

Print the **last column** without knowing its number:

```bash
awk '{print $NF}' example.txt
```

Perfect when:
- Files are huge
- Lines have different column counts
- You only need the final value

## Field Separator Formats

::: {.callout-note}
Out there we have different file formats: our data may be comma separated (CSV), tab separated (TSV), by semicolon or by any other character.
:::

## Field Separators: Default Behavior

By default, AWK splits on **spaces and tabs**.

For other separators, use `-F` flag.

## Field Separator: Comma (-F ",")

For **CSV files**:

```bash
awk -F "," '{print $2}' example.csv
```

Note: comma becomes the **separator**, not part of field!

Spaces in fields are now **part of the value**.

## Field Separator: Other Examples

**Colon separator:**

```bash
awk -F ":" '{print $1}' /etc/passwd
```

**Tab separator:**

```bash
awk -F "\t" '{print $2}' file.tsv
```

## Pattern-Action Model

**Run action only on matching lines**

```bash
awk '/PATTERN/ {action}' file
```

- **Pattern**: regex to match
- **Action**: what to do if matched

## Regex Pattern: Start of Line (^)

Print only lines starting with "ATOM":

```bash
awk '/^ATOM/ {print $0}' example.pdb
```

`^` means **beginning of line**.

## Multiple Patterns

Apply different actions to different patterns:

```bash
awk '/^ATOM/ {count1++} /^HEADER/ {count2++}' file.pdb
```

Or print specific fields from matching lines:

```bash
awk '/^ATOM/ {print $7, $8, $9}' file.pdb
```

**Example**: Print x, y, z coordinates of atoms.

Combined patterns printing fields and header last field (from episode example):

```bash
awk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb
```

## The END Block

**Runs after all lines are processed**

Perfect for **printing totals and summaries**.

```bash
awk '{sum += $2} END {print sum}' file.txt
```

Sums values from column 2 across all lines.

## The NR Variable

**NR** = Number of Records (total lines processed)

After file is read, `NR` = **line count**:

```bash
awk 'END {print NR}' example.txt
```

More **robust than `wc -l`** (handles missing final newline).

## Comparing Line Counting Methods

**Using wc:**

```bash
wc -l file.txt
```

May undercount if last line lacks newline!

**Using AWK:**

```bash
awk 'END {print NR}' file.txt
```

Always counts correctly!

## Counting Matching Lines

Count only lines starting with "ATOM":

```bash
awk '/^ATOM/ {count++} END {print count}' file.pdb
```

- `/^ATOM/` = match lines starting with ATOM
- `count++` = increment counter
- `END` = print final count

## Safe Counter Initialization

Avoid errors if no lines match:

```bash
awk '/^ATOM/ {c++} END {print c+0}' file.pdb
```

Adding `+0` safely prints **0 if no matches**.

## Multiple Counters in a Pattern

Count atoms and sum their coordinates:

```bash
awk '/^ATOM/ {count++; x += $7; y += $8; z += $9} \
    END {print count, x, y, z}' file.pdb
```

- `count++` = count atoms
- `x += $7` = sum x coordinates
- `END` = print all totals

## Challenge: Counting and Selecting (Simple)

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

Using only the ideas covered above (field selection, patterns, `NF`, and `END`):

1. Write an `awk` command that prints the number of lines in `example.txt`.
2. Write an `awk` command that prints the number of lines in `example.pdb` that start with `ATOM`.
3. Write an `awk` command that prints the last field of each `ATOM` line in `example.pdb` (just the values, one per line).

Bonus (optional): Print both the count of `ATOM` lines and, at the end, the total number of characters across all those last fields.

:::

## Solution: Counting and Selecting

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

**1) Total lines (robust):**

```bash
awk 'END {print NR}' example.txt
```

**2) Count lines starting with `ATOM`:**

```bash
awk '/^ATOM/ {c++} END {print c+0}' example.pdb
```

**3) Last field of each `ATOM` line:**

```bash
awk '/^ATOM/ {print $NF}' example.pdb
```

**Bonus (count and accumulate character lengths of last field):**

```bash
awk '/^ATOM/ {c++; total += length($NF)} END {print "ATOM lines:", c+0; print "Total chars in last field:", total+0}' example.pdb
```

Explanation:
- `NR` gives total lines after reading the file.
- `/^ATOM/` pattern restricts actions to lines starting with `ATOM`.
- `$NF` is the last field; `length($NF)` measures its size.
- Counters (`c`, `total`) are printed in `END`.

:::

## Built-in Functions

**length()**: measure string length

```bash
awk '{print length($1)}' file.txt
```

**String concatenation**:

```bash
awk '{print $1 "_" $2}' file.txt
```

Joins fields with underscore.

## Arithmetic and Aggregation

**Sum values:**

```bash
awk '{sum += $1} END {print sum}' numbers.txt
```

**Calculate average:**

```bash
awk '{sum += $1; count++} END {print sum/count}' numbers.txt
```

## Variable Assignment

Set variables in AWK:

```bash
awk '{x = $2 * 2; print x}' file.txt
```

Use variables in calculations throughout.

## BEGIN Block (Advanced)

Initialize variables **before processing**:

```bash
awk 'BEGIN {total=0} {total += $1} END {print total}' file.txt
```

- `BEGIN` runs first (before any lines)
- `{total += $1}` processes each line
- `END` prints result

## `awk` Programs from Files

For complex scripts, save to file.

Create `script.awk`:

```awk
/^ATOM/ {
    count++
    x += $7
    y += $8
    z += $9
}

END {
    print "Atoms:", count
    if (count > 0) {
        print "Avg X:", x/count
        print "Avg Y:", y/count
        print "Avg Z:", z/count
    }
}
```

Run it:

```bash
awk -f script.awk protein.pdb
```

## Real-World Example 1

Extract chromosome and position from BED file:

```bash
awk -F "\t" '{print $1, $2, $3}' file.bed
```

## Real-World Example 2

Count records by type:

```bash
awk '{type[$1]++} END {for (t in type) print t, type[t]}' data.txt
```

## Real-World Example 3

Filter and sum:

```bash
awk '$3 > 1000 {sum += $3} END {print sum}' file.txt
```

Only sum values in column 3 greater than 1000.

## Key Concepts Summary

| Concept | Meaning |
|---------|---------|
| `$0` | Entire line |
| `$1, $2, ...` | Columns (fields) |
| `NF` | Number of fields |
| `$NF` | Last field |
| `NR` | Line number / total lines |
| `-F` | Field separator |
| `/pattern/` | Regex match |
| `END` | After all lines |

---

## You've Completed the Unix Shell Workshop!

**Congratulations! ðŸŽ‰**

You now know how to:

âœ“ Navigate files and directories  
âœ“ Manage and create files  
âœ“ Combine commands with pipes  
âœ“ Write loops and shell scripts  
âœ“ Find files and search text  
âœ“ Process data with AWK  