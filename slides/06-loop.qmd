
# Episode 6: Loops

::: {.callout-tip icon="false" .nonincremental}
## Questions

- How can I perform the same actions on many different files?
:::

::: {.callout-tip icon="false" .nonincremental}
## Objectives

- Write a loop that applies one or more commands to each file in a set
- Trace loop variable values during execution
- Explain difference between variable name and value
- Explain why spaces and special characters shouldn't be in filenames
- Demonstrate how to view recently executed commands
- Re-run recently executed commands without retyping
:::

## What Are Loops?

**Loops** are a programming construct which allow us to repeat a command or set of commands for each item in a list.

As such they are key to productivity improvements through automation.

Similar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes).

## Loop Structure

```bash
# The word "for" indicates the start of a "For-loop" command
for thing in list_of_things
# The word "do" indicates the start of job execution list
do
    # Execute command(s) using the variable
    operation_using/command $thing
# The word "done" indicates the end of a loop
done
```

Three keywords: `for`, `do`, `done`

## Example Files

Suppose we have several hundred genome data files named `basilisk.dat`, `minotaur.dat`, and `unicorn.dat`.

For this example, we'll use the `exercise-data/creatures` directory which only has three example files, but the principles can be applied to many many more files at once.

The structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines.

## Looking at the Files

Let's look at the files:

```bash
head -n 5 basilisk.dat minotaur.dat unicorn.dat
```

We would like to print out the classification for each species, which is given on the second line of each file.

For each file, we would need to execute the command `head -n 2` and pipe this to `tail -n 1`.

## General Form of a Loop

We'll use a loop to solve this problem, but first let's look at the general form of a loop:

```bash
for filename in basilisk.dat minotaur.dat unicorn.dat
do
    echo $filename
done
```

```output
basilisk.dat
minotaur.dat
unicorn.dat
```

## Follow the Prompt

When typing a loop, shell prompt changes:

```bash
$ for filename in basilisk.dat minotaur.dat unicorn.dat
> do
>     echo $filename
> done
```

The `>` prompt reminds you the command isn't complete yet.

A semicolon `;` can separate commands on one line.

## Same Symbols, Different Meanings

- **Shell prints `>` or `$`**: it's a prompt (expects input)
- **You type `>` or `$`**: it's an instruction (redirect or variable)

Context matters!

## Loop Iteration

Each time loop runs, variable holds next value:

- **First**: `$filename` = `basilisk.dat`
- **Second**: `$filename` = `minotaur.dat`
- **Third**: `$filename` = `unicorn.dat`

Then shell exits loop (no more items).

## Variable Substitution

Use `$varname` to access the value.

The `$` tells shell: **treat this as a variable, not literal text**.

Replace with actual value before executing command.

## Practical Loop Example

Get classification line from creature files:

```bash
for filename in basilisk.dat minotaur.dat unicorn.dat
do
    echo $filename
    head -n 2 $filename | tail -n 1
done
```

```output
basilisk.dat
CLASSIFICATION: basiliscus vulgaris
minotaur.dat
CLASSIFICATION: bos hominus
unicorn.dat
CLASSIFICATION: equus monoceros
```

## Variable Name vs Value

Variable name: `filename` (the name)

Variable value: `basilisk.dat` (the data)

Use `$filename` to get the **value**, not the name.

## Variable Naming

Two syntaxes:

```bash
echo $filename      # Simple
echo ${filename}    # With braces (clearer)
```

Braces useful when variable next to text:

```bash
echo ${filename}.bak    # Shows: basilisk.dat.bak
echo $filename.bak      # Looks for variable "filename.bak"!
```

## Variable Naming Tips

- Use **meaningful names**: `filename`, not `x`
- Helps others (and future you) understand code
- Increases odds people interpret it correctly

The shell doesn't care---only we do!

## Loops with Numbers

Loops work with any list, not just filenames:

```bash
for number in 0 1 2 3 4 5
do
    echo $number
done
```

## Challenge: Write Your Own Loop

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

How would you write a loop that echoes all 10 numbers from 0 to 9?

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

```bash
for loop_variable in 0 1 2 3 4 5 6 7 8 9
do
    echo $loop_variable
done
```

```output
0
1
2
3
4
5
6
7
8
9
```

Alternatively, try replacing the enumeration of integers `0 1 2 3 4 5 6 7 8 9` by `{0..9}` to obtain an identical output.

:::

## Challenge: Variables in Loops

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

In `shell-lesson-data/exercise-data/alkanes`, `ls *.pdb` gives:

```output
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
```

**First code:**

```bash
for datafile in *.pdb
do
    ls *.pdb
done
```

**Second code:**

```bash
for datafile in *.pdb
do
    ls $datafile
done
```

What's the difference?

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

**First code:** lists ALL `.pdb` files **each iteration** (6 times total).

Shell expands `*.pdb` in loop body for each iteration.

**Second code:** lists ONE file **per iteration** (6 different files).

Variable `$datafile` evaluates to current file each time.

Second code is cleaner and what we usually want!

:::

## Challenge: Limiting Sets of Files (c*)

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

In `shell-lesson-data/exercise-data/alkanes`, what does this loop output?

```bash
for filename in c*
do
    ls $filename
done
```

1. No files listed
2. All files are listed
3. Only `cubane.pdb`, `octane.pdb`, `pentane.pdb`
4. Only `cubane.pdb`

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

**Option 4 is correct.**

`*` matches zero or more characters.

`c*` matches any filename **starting with 'c'** (only `cubane.pdb`).

:::

## Challenge: Limiting Sets (*c*)

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

How different is this loop?

```bash
for filename in *c*
do
    ls $filename
done
```

1. Same files listed
2. All files are listed now
3. No files listed now
4. `cubane.pdb` and `octane.pdb`
5. Only `octane.pdb`

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

**Option 4 is correct.**

`*c*` matches filename with 'c' **anywhere in name** (before or after).

Matches: `cubane.pdb` (c at start) and `octane.pdb` (c in middle).

:::

## Challenge: Saving to File with >

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

In `shell-lesson-data/exercise-data/alkanes`, what does this loop do?

```bash
for alkanes in *.pdb
do
    echo $alkanes
    cat $alkanes > alkanes.pdb
done
```

1. Prints all 6 files; only `propane.pdb` saved to `alkanes.pdb`
2. Prints 3 files; all concatenated and saved to `alkanes.pdb`
3. Prints 5 files; only `propane.pdb` saved to `alkanes.pdb`
4. None of the above

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

**Option 1 is correct.**

Each iteration: `>` **overwrites** (not appends).

Last file processed (`propane.pdb`) is final content.

Use `>>` to append instead!

:::

## Challenge: Saving to File with >>

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

In `shell-lesson-data/exercise-data/alkanes`, what does this loop do?

```bash
for datafile in *.pdb
do
    cat $datafile >> all.pdb
done
```

1. All files up to `pentane.pdb` concatenated
2. Only `ethane.pdb` saved
3. All 6 files concatenated to `all.pdb`
4. All 5 files concatenated

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

**Option 3 is correct.**

`>>` **appends** each file (doesn't overwrite).

All 6 files concatenated to `all.pdb`.

Nothing printed (output redirected to file).

:::

## Another Practical Example

In `shell-lesson-data/exercise-data/creatures`:

```bash
for filename in *.dat
do
    echo $filename
    head -n 100 $filename | tail -n 20
done
```

**Loop body:** two commands
- Echo filename
- Select lines 81-100 (or all if fewer than 100)

## Spaces in Filenames

Shell uses spaces to **separate items**!

Filenames with spaces: `red dragon.dat`, `purple unicorn.dat`

Must quote them:

```bash
for filename in "red dragon.dat" "purple unicorn.dat"
do
    head -n 100 "$filename" | tail -n 20
done
```

**Always quote variables** to be safe: `"$filename"`

It is simpler to **avoid using spaces** (or other special characters) in filenames.

## What Happens Without Quotes?

The files `red dragon.dat` and `purple unicorn.dat` don't exist, so if we run the code without quotes around `$filename`, we get errors:

```error
head: cannot open 'red' for reading: No such file or directory
head: cannot open 'dragon.dat' for reading: No such file or directory
head: cannot open 'purple' for reading: No such file or directory
```

With quotes, we'd see:

```error
head: cannot open 'red dragon.dat' for reading: No such file or directory
head: cannot open 'purple unicorn.dat' for reading: No such file or directory
```

## Why Quote Variables?

Without quotes:
- Shell splits by spaces
- `"red dragon.dat"` becomes two items: `red`, `dragon.dat`
- Commands fail

With quotes:
- Treated as single item
- Commands work correctly

**Best practice**: Avoid spaces in filenames entirely (use `-` or `_`).

## Backing Up Files in a Loop

**Problem**: Copy all `.dat` files to `original-` versions.

**Can't do this:**

```bash
cp *.dat original-*.dat  # ERROR!
```

Expands to: `cp basilisk.dat minotaur.dat unicorn.dat original-*.dat`

Shell sees 4 arguments, expects last to be directory!

## Solution: Use a Loop

```bash
for filename in *.dat
do
    cp $filename original-$filename
done
```

Each iteration:
- `$filename` = `basilisk.dat` → `cp basilisk.dat original-basilisk.dat`
- `$filename` = `minotaur.dat` → `cp minotaur.dat original-minotaur.dat`
- `$filename` = `unicorn.dat` → `cp unicorn.dat original-unicorn.dat`

## Testing Loops with `echo`

**Hard to verify** loop did what you want (no output from `cp`).

**Solution**: Use `echo` to print commands without executing:

```bash
for filename in *.dat
do
    echo cp $filename original-$filename
done
```

See what **would** run, verify correctness, then remove `echo`!

The judicious use of `echo` is a good **debugging technique**.

## Loop Flow Chart

The following diagram shows what happens when the modified loop is executed, and demonstrates how the judicious use of `echo` is a good debugging technique.

![](../episodes/fig/shell_script_for_loop_flow_chart.svg){alt='For loop flow chart showing variable assignment and iteration'}

## Nelle's Pipeline: Processing Files

Nelle is now ready to process her data files using `goostats.sh` --- a shell script written by her supervisor.

This calculates some **statistics from a protein sample file** and takes two arguments:

1. an input file (containing the raw data)
2. an output file (to store the calculated statistics)

Since she's still learning how to use the shell, she decides to **build up the required commands in stages**.

## Nelle Tests File Selection

Her first step is to make sure that she can select the right input files --- remember, these are ones whose names end in 'A' or 'B', rather than 'Z'.

Moving to the `north-pacific-gyre` directory, Nelle types:

```bash
cd
cd Desktop/shell-lesson-data/north-pacific-gyre
for datafile in NENE*A.txt NENE*B.txt
do
    echo $datafile
done
```

```output
NENE01729A.txt
NENE01736A.txt
NENE01751A.txt
...
NENE02040B.txt
NENE02043B.txt
```

Good! Selects correct files.

## Nelle Builds Output Filenames

Her next step is to decide what to call the files that the `goostats.sh` analysis program will create.

Prefixing each input file's name with 'stats' seems simple, so she modifies her loop:

```bash
for datafile in NENE*A.txt NENE*B.txt
do
    echo $datafile stats-$datafile
done
```

```output
NENE01729A.txt stats-NENE01729A.txt
NENE01736A.txt stats-NENE01736A.txt
NENE01751A.txt stats-NENE01751A.txt
...
NENE02040B.txt stats-NENE02040B.txt
NENE02043B.txt stats-NENE02043B.txt
```

Perfect! Ready to process.

She hasn't actually run `goostats.sh` yet, but now she's sure she can select the right files and generate the right output filenames.

## Command History

**Typing same command repeatedly is tedious!**

Shell remembers recent commands.

**View history:**

```bash
history
```

Shows numbered list of previous commands.

## Accessing History

| Method | What it does |
|--------|-------------|
| `↑` | Previous command |
| `↓` | Next command |
| `!42` | Run command #42 |
| `Ctrl-R` | Search history |

## One-Liner Loop

Press **Up arrow**:

```bash
for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done
```

Entire loop on one line using semicolons `;`

Same as multi-line version!

## Beginning and End

::: {.callout-note}

## Beginning and End

We can move to the beginning of a line in the shell by typing <kbd>Ctrl</kbd>+<kbd>A</kbd> and to the end using <kbd>Ctrl</kbd>+<kbd>E</kbd>.

:::

## Those Who Know History

::: {.callout-note}

## Those Who Know History Can Choose to Repeat It

Another way to repeat previous work is to use the `history` command to get a list of the last few hundred commands that have been executed, and then to use `!123` (where `123` is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:

```bash
history | tail -n 5
```

```output
  456  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done
  457  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done
  458  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; done
  459  cd ..
  460  history | tail -n 5
```

then she can re-run `bash goostats.sh` on all her files by typing `!457`.

:::

## Other history Commands

::: {.callout-note}

## Other history Commands

There are a number of other shortcut commands for getting at the history:

- <kbd>Ctrl</kbd>+<kbd>R</kbd> enters a history search mode 'reverse-i-search' and finds the most recent command in your history that matches the text you enter next. Press <kbd>Ctrl</kbd>+<kbd>R</kbd> one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit <kbd>Return</kbd> to run the command.
- `!!` retrieves the immediately preceding command (you may or may not find this more convenient than using <kbd>↑</kbd>)
- `!$` retrieves the last word of the last command. That's useful more often than you might expect: after `bash goostats.sh NENE01729B.txt stats-NENE01729B.txt`, you can type `less !$` to look at the file `stats-NENE01729B.txt`, which is quicker than doing <kbd>↑</kbd> and editing the command-line.

:::

## Challenge: Doing a Dry Run

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

A loop is a way to do many things at once --- or to make many mistakes at once if it does the wrong thing. One way to check what a loop *would* do is to `echo` the commands it would run instead of actually running them.

Suppose we want to preview the commands the following loop will execute without actually running those commands:

```bash
for datafile in *.pdb
do
    cat $datafile >> all.pdb
done
```

What is the difference between the two loops below, and which one would we want to run?

```bash
# Version 1
for datafile in *.pdb
do
    echo cat $datafile >> all.pdb
done
```

```bash
# Version 2
for datafile in *.pdb
do
    echo "cat $datafile >> all.pdb"
done
```

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

The second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also *does not* modify nor create the file `all.pdb`, as the `>>` is treated literally as part of a string rather than as a redirection instruction.

The first version appends the output from the command `echo cat $datafile` to the file, `all.pdb`. This file will just contain the list; `cat cubane.pdb`, `cat ethane.pdb`, `cat methane.pdb` etc.

Try both versions for yourself to see the output! Be sure to open the `all.pdb` file to view its contents.

:::

## Challenge: Nested Loops

::: {.callout-note .challenge-callout icon="false" style="border-left: 4px solid #ffc107;"}

## Challenge

Suppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds *and* different temperatures.  What would be the result of the following code:

```bash
for species in cubane ethane methane
do
    for temperature in 25 30 37 40
    do
        mkdir $species-$temperature
    done
done
```

:::

## Solution

::: {.callout-tip .solution-callout collapse="true" icon="false" style="border-left: 4px solid #ffc107;"}

## Solution

We have a nested loop, i.e. contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.

Try running the code for yourself to see which directories are created!

:::
